/*! For license information please see 72524.250dce41.iframe.bundle.js.LICENSE.txt */
(self.webpackChunk_storiny_monorepo=self.webpackChunk_storiny_monorepo||[]).push([[72524],{"./node_modules/@hello-pangea/dnd/dist/dnd.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{JY:()=>DragDropContext,sx:()=>PublicDraggable,gL:()=>ConnectedDroppable$1});var react=__webpack_require__("./node_modules/next/dist/compiled/react/index.js"),react_dom=__webpack_require__("./node_modules/next/dist/compiled/react-dom/index.js"),redux=__webpack_require__("./node_modules/redux/es/redux.js"),es=__webpack_require__("./node_modules/react-redux/es/index.js");function useMemoOne(getResult,inputs){var initial=(0,react.useState)((function(){return{inputs,result:getResult()}}))[0],isFirstRun=(0,react.useRef)(!0),committed=(0,react.useRef)(initial),cache=isFirstRun.current||Boolean(inputs&&committed.current.inputs&&function areInputsEqual(newInputs,lastInputs){if(newInputs.length!==lastInputs.length)return!1;for(var i=0;i<newInputs.length;i++)if(newInputs[i]!==lastInputs[i])return!1;return!0}(inputs,committed.current.inputs))?committed.current:{inputs,result:getResult()};return(0,react.useEffect)((function(){isFirstRun.current=!1,committed.current=cache}),[cache]),cache.result}var useMemo=useMemoOne,useCallback=function useCallbackOne(callback,inputs){return useMemoOne((function(){return callback}),inputs)},tiny_invariant=__webpack_require__("./node_modules/tiny-invariant/dist/esm/tiny-invariant.js"),getRect=function getRect(_ref){var top=_ref.top,right=_ref.right,bottom=_ref.bottom,left=_ref.left;return{top,right,bottom,left,width:right-left,height:bottom-top,x:left,y:top,center:{x:(right+left)/2,y:(bottom+top)/2}}},expand=function expand(target,expandBy){return{top:target.top-expandBy.top,left:target.left-expandBy.left,bottom:target.bottom+expandBy.bottom,right:target.right+expandBy.right}},shrink=function shrink(target,shrinkBy){return{top:target.top+shrinkBy.top,left:target.left+shrinkBy.left,bottom:target.bottom-shrinkBy.bottom,right:target.right-shrinkBy.right}},noSpacing={top:0,right:0,bottom:0,left:0},createBox=function createBox(_ref2){var borderBox=_ref2.borderBox,_ref2$margin=_ref2.margin,margin=void 0===_ref2$margin?noSpacing:_ref2$margin,_ref2$border=_ref2.border,border=void 0===_ref2$border?noSpacing:_ref2$border,_ref2$padding=_ref2.padding,padding=void 0===_ref2$padding?noSpacing:_ref2$padding,marginBox=getRect(expand(borderBox,margin)),paddingBox=getRect(shrink(borderBox,border)),contentBox=getRect(shrink(paddingBox,padding));return{marginBox,borderBox:getRect(borderBox),paddingBox,contentBox,margin,border,padding}},parse=function parse(raw){var value=raw.slice(0,-2);if("px"!==raw.slice(-2))return 0;var result=Number(value);return isNaN(result)&&(0,tiny_invariant.A)(!1),result},offset=function offset(original,change){var borderBox=original.borderBox,border=original.border,margin=original.margin,padding=original.padding,shifted=function shift(target,shiftBy){return{top:target.top+shiftBy.y,left:target.left+shiftBy.x,bottom:target.bottom+shiftBy.y,right:target.right+shiftBy.x}}(borderBox,change);return createBox({borderBox:shifted,border,margin,padding})},withScroll=function withScroll(original,scroll){return void 0===scroll&&(scroll=function getWindowScroll(){return{x:window.pageXOffset,y:window.pageYOffset}}()),offset(original,scroll)},calculateBox=function calculateBox(borderBox,styles){var margin={top:parse(styles.marginTop),right:parse(styles.marginRight),bottom:parse(styles.marginBottom),left:parse(styles.marginLeft)},padding={top:parse(styles.paddingTop),right:parse(styles.paddingRight),bottom:parse(styles.paddingBottom),left:parse(styles.paddingLeft)},border={top:parse(styles.borderTopWidth),right:parse(styles.borderRightWidth),bottom:parse(styles.borderBottomWidth),left:parse(styles.borderLeftWidth)};return createBox({borderBox,margin,padding,border})},getBox=function getBox(el){var borderBox=el.getBoundingClientRect(),styles=window.getComputedStyle(el);return calculateBox(borderBox,styles)},memoize_one_esm=__webpack_require__("./node_modules/memoize-one/dist/memoize-one.esm.js");const raf_schd_esm=function rafSchd(fn){var lastArgs=[],frameId=null,wrapperFn=function wrapperFn(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];lastArgs=args,frameId||(frameId=requestAnimationFrame((function(){frameId=null,fn.apply(void 0,lastArgs)})))};return wrapperFn.cancel=function(){frameId&&(cancelAnimationFrame(frameId),frameId=null)},wrapperFn};var esm_extends=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/extends.js");__webpack_require__("./node_modules/console-browserify/index.js");function log(type,message){}log.bind(null,"warn"),log.bind(null,"error");function noop$2(){}function bindEvents(el,bindings,sharedOptions){const unbindings=bindings.map((binding=>{const options=function getOptions(shared,fromBinding){return{...shared,...fromBinding}}(sharedOptions,binding.options);return el.addEventListener(binding.eventName,binding.fn,options),function unbind(){el.removeEventListener(binding.eventName,binding.fn,options)}}));return function unbindAll(){unbindings.forEach((unbind=>{unbind()}))}}const isProduction=!0,prefix$1="Invariant failed";class RbdInvariant extends Error{}function invariant(condition,message){if(!condition)throw new RbdInvariant(isProduction?prefix$1:`${prefix$1}: ${message||""}`)}RbdInvariant.prototype.toString=function toString(){return this.message};class ErrorBoundary extends react.Component{constructor(...args){super(...args),this.callbacks=null,this.unbind=noop$2,this.onWindowError=event=>{const callbacks=this.getCallbacks();callbacks.isDragging()&&callbacks.tryAbort();event.error instanceof RbdInvariant&&event.preventDefault()},this.getCallbacks=()=>{if(!this.callbacks)throw new Error("Unable to find AppCallbacks in <ErrorBoundary/>");return this.callbacks},this.setCallbacks=callbacks=>{this.callbacks=callbacks}}componentDidMount(){this.unbind=bindEvents(window,[{eventName:"error",fn:this.onWindowError}])}componentDidCatch(err){if(!(err instanceof RbdInvariant))throw err;this.setState({})}componentWillUnmount(){this.unbind()}render(){return this.props.children(this.setCallbacks)}}const position=index=>index+1,withLocation=(source,destination)=>{const isInHomeList=source.droppableId===destination.droppableId,startPosition=position(source.index),endPosition=position(destination.index);return isInHomeList?`\n      You have moved the item from position ${startPosition}\n      to position ${endPosition}\n    `:`\n    You have moved the item from position ${startPosition}\n    in list ${source.droppableId}\n    to list ${destination.droppableId}\n    in position ${endPosition}\n  `},withCombine=(id,source,combine)=>source.droppableId===combine.droppableId?`\n      The item ${id}\n      has been combined with ${combine.draggableId}`:`\n      The item ${id}\n      in list ${source.droppableId}\n      has been combined with ${combine.draggableId}\n      in list ${combine.droppableId}\n    `,returnedToStart=source=>`\n  The item has returned to its starting position\n  of ${position(source.index)}\n`,preset={dragHandleUsageInstructions:"\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n",onDragStart:start=>`\n  You have lifted an item in position ${position(start.source.index)}\n`,onDragUpdate:update=>{const location=update.destination;if(location)return withLocation(update.source,location);const combine=update.combine;return combine?withCombine(update.draggableId,update.source,combine):"You are over an area that cannot be dropped on"},onDragEnd:result=>{if("CANCEL"===result.reason)return`\n      Movement cancelled.\n      ${returnedToStart(result.source)}\n    `;const location=result.destination,combine=result.combine;return location?`\n      You have dropped the item.\n      ${withLocation(result.source,location)}\n    `:combine?`\n      You have dropped the item.\n      ${withCombine(result.draggableId,result.source,combine)}\n    `:`\n    The item has been dropped while not over a drop area.\n    ${returnedToStart(result.source)}\n  `}};var preset$1=preset;const origin={x:0,y:0},add=(point1,point2)=>({x:point1.x+point2.x,y:point1.y+point2.y}),subtract=(point1,point2)=>({x:point1.x-point2.x,y:point1.y-point2.y}),isEqual$1=(point1,point2)=>point1.x===point2.x&&point1.y===point2.y,negate=point=>({x:0!==point.x?-point.x:0,y:0!==point.y?-point.y:0}),patch=(line,value,otherValue=0)=>"x"===line?{x:value,y:otherValue}:{x:otherValue,y:value},distance=(point1,point2)=>Math.sqrt((point2.x-point1.x)**2+(point2.y-point1.y)**2),closest$1=(target,points)=>Math.min(...points.map((point=>distance(target,point)))),apply=fn=>point=>({x:fn(point.x),y:fn(point.y)});const offsetByPosition=(spacing,point)=>({top:spacing.top+point.y,left:spacing.left+point.x,bottom:spacing.bottom+point.y,right:spacing.right+point.x}),getCorners=spacing=>[{x:spacing.left,y:spacing.top},{x:spacing.right,y:spacing.top},{x:spacing.left,y:spacing.bottom},{x:spacing.right,y:spacing.bottom}],clip=(target,frame)=>frame&&frame.shouldClipSubject?((frame,subject)=>{const result=getRect({top:Math.max(subject.top,frame.top),right:Math.min(subject.right,frame.right),bottom:Math.min(subject.bottom,frame.bottom),left:Math.max(subject.left,frame.left)});return result.width<=0||result.height<=0?null:result})(frame.pageMarginBox,target):getRect(target);var getSubject=({page,withPlaceholder,axis,frame})=>{const scrolled=((target,frame)=>frame?offsetByPosition(target,frame.scroll.diff.displacement):target)(page.marginBox,frame),increased=((target,axis,withPlaceholder)=>withPlaceholder&&withPlaceholder.increasedBy?{...target,[axis.end]:target[axis.end]+withPlaceholder.increasedBy[axis.line]}:target)(scrolled,axis,withPlaceholder);return{page,withPlaceholder,active:clip(increased,frame)}},scrollDroppable=(droppable,newScroll)=>{droppable.frame||invariant(!1);const scrollable=droppable.frame,scrollDiff=subtract(newScroll,scrollable.scroll.initial),scrollDisplacement=negate(scrollDiff),frame={...scrollable,scroll:{initial:scrollable.scroll.initial,current:newScroll,diff:{value:scrollDiff,displacement:scrollDisplacement},max:scrollable.scroll.max}},subject=getSubject({page:droppable.subject.page,withPlaceholder:droppable.subject.withPlaceholder,axis:droppable.axis,frame});return{...droppable,frame,subject}};const toDroppableMap=(0,memoize_one_esm.A)((droppables=>droppables.reduce(((previous,current)=>(previous[current.descriptor.id]=current,previous)),{}))),toDraggableMap=(0,memoize_one_esm.A)((draggables=>draggables.reduce(((previous,current)=>(previous[current.descriptor.id]=current,previous)),{}))),toDroppableList=(0,memoize_one_esm.A)((droppables=>Object.values(droppables))),toDraggableList=(0,memoize_one_esm.A)((draggables=>Object.values(draggables)));var getDraggablesInsideDroppable=(0,memoize_one_esm.A)(((droppableId,draggables)=>{const result=toDraggableList(draggables).filter((draggable=>droppableId===draggable.descriptor.droppableId)).sort(((a,b)=>a.descriptor.index-b.descriptor.index));return result}));function tryGetDestination(impact){return impact.at&&"REORDER"===impact.at.type?impact.at.destination:null}function tryGetCombine(impact){return impact.at&&"COMBINE"===impact.at.type?impact.at.combine:null}var removeDraggableFromList=(0,memoize_one_esm.A)(((remove,list)=>list.filter((item=>item.descriptor.id!==remove.descriptor.id)))),isHomeOf=(draggable,destination)=>draggable.descriptor.droppableId===destination.descriptor.id;const noDisplacedBy={point:origin,value:0},emptyGroups={invisible:{},visible:{},all:[]};var noImpact$1={displaced:emptyGroups,displacedBy:noDisplacedBy,at:null},isWithin=(lowerBound,upperBound)=>value=>lowerBound<=value&&value<=upperBound,isPartiallyVisibleThroughFrame=frame=>{const isWithinVertical=isWithin(frame.top,frame.bottom),isWithinHorizontal=isWithin(frame.left,frame.right);return subject=>{if(isWithinVertical(subject.top)&&isWithinVertical(subject.bottom)&&isWithinHorizontal(subject.left)&&isWithinHorizontal(subject.right))return!0;const isPartiallyVisibleVertically=isWithinVertical(subject.top)||isWithinVertical(subject.bottom),isPartiallyVisibleHorizontally=isWithinHorizontal(subject.left)||isWithinHorizontal(subject.right);if(isPartiallyVisibleVertically&&isPartiallyVisibleHorizontally)return!0;const isBiggerVertically=subject.top<frame.top&&subject.bottom>frame.bottom,isBiggerHorizontally=subject.left<frame.left&&subject.right>frame.right;if(isBiggerVertically&&isBiggerHorizontally)return!0;return isBiggerVertically&&isPartiallyVisibleHorizontally||isBiggerHorizontally&&isPartiallyVisibleVertically}},isTotallyVisibleThroughFrame=frame=>{const isWithinVertical=isWithin(frame.top,frame.bottom),isWithinHorizontal=isWithin(frame.left,frame.right);return subject=>isWithinVertical(subject.top)&&isWithinVertical(subject.bottom)&&isWithinHorizontal(subject.left)&&isWithinHorizontal(subject.right)};const vertical={direction:"vertical",line:"y",crossAxisLine:"x",start:"top",end:"bottom",size:"height",crossAxisStart:"left",crossAxisEnd:"right",crossAxisSize:"width"},horizontal={direction:"horizontal",line:"x",crossAxisLine:"y",start:"left",end:"right",size:"width",crossAxisStart:"top",crossAxisEnd:"bottom",crossAxisSize:"height"};const isVisible$1=({target:toBeDisplaced,destination,viewport,withDroppableDisplacement,isVisibleThroughFrameFn})=>{const displacedTarget=withDroppableDisplacement?((target,destination)=>{const displacement=destination.frame?destination.frame.scroll.diff.displacement:origin;return offsetByPosition(target,displacement)})(toBeDisplaced,destination):toBeDisplaced;return((target,destination,isVisibleThroughFrameFn)=>!!destination.subject.active&&isVisibleThroughFrameFn(destination.subject.active)(target))(displacedTarget,destination,isVisibleThroughFrameFn)&&((target,viewport,isVisibleThroughFrameFn)=>isVisibleThroughFrameFn(viewport)(target))(displacedTarget,viewport,isVisibleThroughFrameFn)},isTotallyVisible=args=>isVisible$1({...args,isVisibleThroughFrameFn:isTotallyVisibleThroughFrame});function getDisplacementGroups({afterDragging,destination,displacedBy,viewport,forceShouldAnimate,last}){return afterDragging.reduce((function process(groups,draggable){const target=function getTarget(draggable,displacedBy){const marginBox=draggable.page.marginBox,expandBy={top:displacedBy.point.y,right:0,bottom:0,left:displacedBy.point.x};return getRect(expand(marginBox,expandBy))}(draggable,displacedBy),id=draggable.descriptor.id;groups.all.push(id);var args;if(!(args={target,destination,viewport,withDroppableDisplacement:!0},isVisible$1({...args,isVisibleThroughFrameFn:isPartiallyVisibleThroughFrame})))return groups.invisible[draggable.descriptor.id]=!0,groups;const shouldAnimate=((id,last,forceShouldAnimate)=>{if("boolean"==typeof forceShouldAnimate)return forceShouldAnimate;if(!last)return!0;const{invisible,visible}=last;if(invisible[id])return!1;const previous=visible[id];return!previous||previous.shouldAnimate})(id,last,forceShouldAnimate),displacement={draggableId:id,shouldAnimate};return groups.visible[id]=displacement,groups}),{all:[],visible:{},invisible:{}})}function goAtEnd({insideDestination,inHomeList,displacedBy,destination}){const newIndex=function getIndexOfLastItem(draggables,options){if(!draggables.length)return 0;const indexOfLastItem=draggables[draggables.length-1].descriptor.index;return options.inHomeList?indexOfLastItem:indexOfLastItem+1}(insideDestination,{inHomeList});return{displaced:emptyGroups,displacedBy,at:{type:"REORDER",destination:{droppableId:destination.descriptor.id,index:newIndex}}}}function calculateReorderImpact({draggable,insideDestination,destination,viewport,displacedBy,last,index,forceShouldAnimate}){const inHomeList=isHomeOf(draggable,destination);if(null==index)return goAtEnd({insideDestination,inHomeList,displacedBy,destination});const match=insideDestination.find((item=>item.descriptor.index===index));if(!match)return goAtEnd({insideDestination,inHomeList,displacedBy,destination});const withoutDragging=removeDraggableFromList(draggable,insideDestination),sliceFrom=insideDestination.indexOf(match);return{displaced:getDisplacementGroups({afterDragging:withoutDragging.slice(sliceFrom),destination,displacedBy,last,viewport:viewport.frame,forceShouldAnimate}),displacedBy,at:{type:"REORDER",destination:{droppableId:destination.descriptor.id,index}}}}function didStartAfterCritical(draggableId,afterCritical){return Boolean(afterCritical.effected[draggableId])}var moveToNextIndex=({isMovingForward,isInHomeList,draggable,draggables,destination,insideDestination,previousImpact,viewport,afterCritical})=>{const wasAt=previousImpact.at;if(wasAt||invariant(!1),"REORDER"===wasAt.type){const newIndex=(({isMovingForward,isInHomeList,insideDestination,location})=>{if(!insideDestination.length)return null;const currentIndex=location.index,proposedIndex=isMovingForward?currentIndex+1:currentIndex-1,firstIndex=insideDestination[0].descriptor.index,lastIndex=insideDestination[insideDestination.length-1].descriptor.index;return proposedIndex<firstIndex||proposedIndex>(isInHomeList?lastIndex:lastIndex+1)?null:proposedIndex})({isMovingForward,isInHomeList,location:wasAt.destination,insideDestination});return null==newIndex?null:calculateReorderImpact({draggable,insideDestination,destination,viewport,last:previousImpact.displaced,displacedBy:previousImpact.displacedBy,index:newIndex})}const newIndex=(({isMovingForward,destination,draggables,combine,afterCritical})=>{if(!destination.isCombineEnabled)return null;const combineId=combine.draggableId,combineWithIndex=draggables[combineId].descriptor.index;return didStartAfterCritical(combineId,afterCritical)?isMovingForward?combineWithIndex:combineWithIndex-1:isMovingForward?combineWithIndex+1:combineWithIndex})({isMovingForward,destination,displaced:previousImpact.displaced,draggables,combine:wasAt.combine,afterCritical});return null==newIndex?null:calculateReorderImpact({draggable,insideDestination,destination,viewport,last:previousImpact.displaced,displacedBy:previousImpact.displacedBy,index:newIndex})},whenCombining=({afterCritical,impact,draggables})=>{const combine=tryGetCombine(impact);combine||invariant(!1);const combineWith=combine.draggableId,center=draggables[combineWith].page.borderBox.center,displaceBy=(({displaced,afterCritical,combineWith,displacedBy})=>{const isDisplaced=Boolean(displaced.visible[combineWith]||displaced.invisible[combineWith]);return didStartAfterCritical(combineWith,afterCritical)?isDisplaced?origin:negate(displacedBy.point):isDisplaced?displacedBy.point:origin})({displaced:impact.displaced,afterCritical,combineWith,displacedBy:impact.displacedBy});return add(center,displaceBy)};const distanceFromStartToBorderBoxCenter=(axis,box)=>box.margin[axis.start]+box.borderBox[axis.size]/2,getCrossAxisBorderBoxCenter=(axis,target,isMoving)=>target[axis.crossAxisStart]+isMoving.margin[axis.crossAxisStart]+isMoving.borderBox[axis.crossAxisSize]/2,goAfter=({axis,moveRelativeTo,isMoving})=>patch(axis.line,moveRelativeTo.marginBox[axis.end]+distanceFromStartToBorderBoxCenter(axis,isMoving),getCrossAxisBorderBoxCenter(axis,moveRelativeTo.marginBox,isMoving)),goBefore=({axis,moveRelativeTo,isMoving})=>patch(axis.line,moveRelativeTo.marginBox[axis.start]-((axis,box)=>box.margin[axis.end]+box.borderBox[axis.size]/2)(axis,isMoving),getCrossAxisBorderBoxCenter(axis,moveRelativeTo.marginBox,isMoving));var whenReordering=({impact,draggable,draggables,droppable,afterCritical})=>{const insideDestination=getDraggablesInsideDroppable(droppable.descriptor.id,draggables),draggablePage=draggable.page,axis=droppable.axis;if(!insideDestination.length)return(({axis,moveInto,isMoving})=>patch(axis.line,moveInto.contentBox[axis.start]+distanceFromStartToBorderBoxCenter(axis,isMoving),getCrossAxisBorderBoxCenter(axis,moveInto.contentBox,isMoving)))({axis,moveInto:droppable.page,isMoving:draggablePage});const{displaced,displacedBy}=impact,closestAfter=displaced.all[0];if(closestAfter){const closest=draggables[closestAfter];if(didStartAfterCritical(closestAfter,afterCritical))return goBefore({axis,moveRelativeTo:closest.page,isMoving:draggablePage});const withDisplacement=offset(closest.page,displacedBy.point);return goBefore({axis,moveRelativeTo:withDisplacement,isMoving:draggablePage})}const last=insideDestination[insideDestination.length-1];if(last.descriptor.id===draggable.descriptor.id)return draggablePage.borderBox.center;if(didStartAfterCritical(last.descriptor.id,afterCritical)){const page=offset(last.page,negate(afterCritical.displacedBy.point));return goAfter({axis,moveRelativeTo:page,isMoving:draggablePage})}return goAfter({axis,moveRelativeTo:last.page,isMoving:draggablePage})},withDroppableDisplacement=(droppable,point)=>{const frame=droppable.frame;return frame?add(point,frame.scroll.diff.displacement):point};var getPageBorderBoxCenterFromImpact=args=>{const withoutDisplacement=(({impact,draggable,droppable,draggables,afterCritical})=>{const original=draggable.page.borderBox.center,at=impact.at;return droppable&&at?"REORDER"===at.type?whenReordering({impact,draggable,draggables,droppable,afterCritical}):whenCombining({impact,draggables,afterCritical}):original})(args),droppable=args.droppable;return droppable?withDroppableDisplacement(droppable,withoutDisplacement):withoutDisplacement},scrollViewport=(viewport,newScroll)=>{const diff=subtract(newScroll,viewport.scroll.initial),displacement=negate(diff);return{frame:getRect({top:newScroll.y,bottom:newScroll.y+viewport.frame.height,left:newScroll.x,right:newScroll.x+viewport.frame.width}),scroll:{initial:viewport.scroll.initial,max:viewport.scroll.max,current:newScroll,diff:{value:diff,displacement}}}};function getDraggables$1(ids,draggables){return ids.map((id=>draggables[id]))}var getClientFromPageBorderBoxCenter=({pageBorderBoxCenter,draggable,viewport})=>{const withoutPageScrollChange=((viewport,point)=>add(viewport.scroll.diff.displacement,point))(viewport,pageBorderBoxCenter),offset=subtract(withoutPageScrollChange,draggable.page.borderBox.center);return add(draggable.client.borderBox.center,offset)},isTotallyVisibleInNewLocation=({draggable,destination,newPageBorderBoxCenter,viewport,withDroppableDisplacement,onlyOnMainAxis=!1})=>{const changeNeeded=subtract(newPageBorderBoxCenter,draggable.page.borderBox.center),args={target:offsetByPosition(draggable.page.borderBox,changeNeeded),destination,withDroppableDisplacement,viewport};return onlyOnMainAxis?(args=>{return isVisible$1({...args,isVisibleThroughFrameFn:(axis=args.destination.axis,frame=>{const isWithinVertical=isWithin(frame.top,frame.bottom),isWithinHorizontal=isWithin(frame.left,frame.right);return subject=>axis===vertical?isWithinVertical(subject.top)&&isWithinVertical(subject.bottom):isWithinHorizontal(subject.left)&&isWithinHorizontal(subject.right)})});var axis})(args):isTotallyVisible(args)},moveToNextPlace=({isMovingForward,draggable,destination,draggables,previousImpact,viewport,previousPageBorderBoxCenter,previousClientSelection,afterCritical})=>{if(!destination.isEnabled)return null;const insideDestination=getDraggablesInsideDroppable(destination.descriptor.id,draggables),isInHomeList=isHomeOf(draggable,destination),impact=(({isMovingForward,draggable,destination,insideDestination,previousImpact})=>{if(!destination.isCombineEnabled)return null;if(!tryGetDestination(previousImpact))return null;function getImpact(target){const at={type:"COMBINE",combine:{draggableId:target,droppableId:destination.descriptor.id}};return{...previousImpact,at}}const all=previousImpact.displaced.all,closestId=all.length?all[0]:null;if(isMovingForward)return closestId?getImpact(closestId):null;const withoutDraggable=removeDraggableFromList(draggable,insideDestination);if(!closestId)return withoutDraggable.length?getImpact(withoutDraggable[withoutDraggable.length-1].descriptor.id):null;const indexOfClosest=withoutDraggable.findIndex((d=>d.descriptor.id===closestId));-1===indexOfClosest&&invariant(!1);const proposedIndex=indexOfClosest-1;return proposedIndex<0?null:getImpact(withoutDraggable[proposedIndex].descriptor.id)})({isMovingForward,draggable,destination,insideDestination,previousImpact})||moveToNextIndex({isMovingForward,isInHomeList,draggable,draggables,destination,insideDestination,previousImpact,viewport,afterCritical});if(!impact)return null;const pageBorderBoxCenter=getPageBorderBoxCenterFromImpact({impact,draggable,droppable:destination,draggables,afterCritical});if(isTotallyVisibleInNewLocation({draggable,destination,newPageBorderBoxCenter:pageBorderBoxCenter,viewport:viewport.frame,withDroppableDisplacement:!1,onlyOnMainAxis:!0})){return{clientSelection:getClientFromPageBorderBoxCenter({pageBorderBoxCenter,draggable,viewport}),impact,scrollJumpRequest:null}}const distance=subtract(pageBorderBoxCenter,previousPageBorderBoxCenter),cautious=(({impact,viewport,destination,draggables,maxScrollChange})=>{const scrolledViewport=scrollViewport(viewport,add(viewport.scroll.current,maxScrollChange)),scrolledDroppable=destination.frame?scrollDroppable(destination,add(destination.frame.scroll.current,maxScrollChange)):destination,last=impact.displaced,withViewportScroll=getDisplacementGroups({afterDragging:getDraggables$1(last.all,draggables),destination,displacedBy:impact.displacedBy,viewport:scrolledViewport.frame,last,forceShouldAnimate:!1}),withDroppableScroll=getDisplacementGroups({afterDragging:getDraggables$1(last.all,draggables),destination:scrolledDroppable,displacedBy:impact.displacedBy,viewport:viewport.frame,last,forceShouldAnimate:!1}),invisible={},visible={},groups=[last,withViewportScroll,withDroppableScroll];return last.all.forEach((id=>{const displacement=function tryGetVisible(id,groups){for(let i=0;i<groups.length;i++){const displacement=groups[i].visible[id];if(displacement)return displacement}return null}(id,groups);displacement?visible[id]=displacement:invisible[id]=!0})),{...impact,displaced:{all:last.all,invisible,visible}}})({impact,viewport,destination,draggables,maxScrollChange:distance});return{clientSelection:previousClientSelection,impact:cautious,scrollJumpRequest:distance}};const getKnownActive=droppable=>{const rect=droppable.subject.active;return rect||invariant(!1),rect};const getCurrentPageBorderBoxCenter=(draggable,afterCritical)=>{const original=draggable.page.borderBox.center;return didStartAfterCritical(draggable.descriptor.id,afterCritical)?subtract(original,afterCritical.displacedBy.point):original},getCurrentPageBorderBox=(draggable,afterCritical)=>{const original=draggable.page.borderBox;return didStartAfterCritical(draggable.descriptor.id,afterCritical)?offsetByPosition(original,negate(afterCritical.displacedBy.point)):original};var getDisplacedBy=(0,memoize_one_esm.A)((function getDisplacedBy(axis,displaceBy){const displacement=displaceBy[axis.line];return{value:displacement,point:patch(axis.line,displacement)}}));const withMaxScroll=(frame,max)=>({...frame,scroll:{...frame.scroll,max}}),addPlaceholder=(droppable,draggable,draggables)=>{const frame=droppable.frame;isHomeOf(draggable,droppable)&&invariant(!1),droppable.subject.withPlaceholder&&invariant(!1);const placeholderSize=getDisplacedBy(droppable.axis,draggable.displaceBy).point,requiredGrowth=((droppable,placeholderSize,draggables)=>{const axis=droppable.axis;if("virtual"===droppable.descriptor.mode)return patch(axis.line,placeholderSize[axis.line]);const availableSpace=droppable.subject.page.contentBox[axis.size],needsToGrowBy=getDraggablesInsideDroppable(droppable.descriptor.id,draggables).reduce(((sum,dimension)=>sum+dimension.client.marginBox[axis.size]),0)+placeholderSize[axis.line]-availableSpace;return needsToGrowBy<=0?null:patch(axis.line,needsToGrowBy)})(droppable,placeholderSize,draggables),added={placeholderSize,increasedBy:requiredGrowth,oldFrameMaxScroll:droppable.frame?droppable.frame.scroll.max:null};if(!frame){const subject=getSubject({page:droppable.subject.page,withPlaceholder:added,axis:droppable.axis,frame:droppable.frame});return{...droppable,subject}}const maxScroll=requiredGrowth?add(frame.scroll.max,requiredGrowth):frame.scroll.max,newFrame=withMaxScroll(frame,maxScroll),subject=getSubject({page:droppable.subject.page,withPlaceholder:added,axis:droppable.axis,frame:newFrame});return{...droppable,subject,frame:newFrame}};var moveCrossAxis=({isMovingForward,previousPageBorderBoxCenter,draggable,isOver,draggables,droppables,viewport,afterCritical})=>{const destination=(({isMovingForward,pageBorderBoxCenter,source,droppables,viewport})=>{const active=source.subject.active;if(!active)return null;const axis=source.axis,isBetweenSourceClipped=isWithin(active[axis.start],active[axis.end]),candidates=toDroppableList(droppables).filter((droppable=>droppable!==source)).filter((droppable=>droppable.isEnabled)).filter((droppable=>Boolean(droppable.subject.active))).filter((droppable=>isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable)))).filter((droppable=>{const activeOfTarget=getKnownActive(droppable);return isMovingForward?active[axis.crossAxisEnd]<activeOfTarget[axis.crossAxisEnd]:activeOfTarget[axis.crossAxisStart]<active[axis.crossAxisStart]})).filter((droppable=>{const activeOfTarget=getKnownActive(droppable),isBetweenDestinationClipped=isWithin(activeOfTarget[axis.start],activeOfTarget[axis.end]);return isBetweenSourceClipped(activeOfTarget[axis.start])||isBetweenSourceClipped(activeOfTarget[axis.end])||isBetweenDestinationClipped(active[axis.start])||isBetweenDestinationClipped(active[axis.end])})).sort(((a,b)=>{const first=getKnownActive(a)[axis.crossAxisStart],second=getKnownActive(b)[axis.crossAxisStart];return isMovingForward?first-second:second-first})).filter(((droppable,index,array)=>getKnownActive(droppable)[axis.crossAxisStart]===getKnownActive(array[0])[axis.crossAxisStart]));if(!candidates.length)return null;if(1===candidates.length)return candidates[0];const contains=candidates.filter((droppable=>isWithin(getKnownActive(droppable)[axis.start],getKnownActive(droppable)[axis.end])(pageBorderBoxCenter[axis.line])));return 1===contains.length?contains[0]:contains.length>1?contains.sort(((a,b)=>getKnownActive(a)[axis.start]-getKnownActive(b)[axis.start]))[0]:candidates.sort(((a,b)=>{const first=closest$1(pageBorderBoxCenter,getCorners(getKnownActive(a))),second=closest$1(pageBorderBoxCenter,getCorners(getKnownActive(b)));return first!==second?first-second:getKnownActive(a)[axis.start]-getKnownActive(b)[axis.start]}))[0]})({isMovingForward,pageBorderBoxCenter:previousPageBorderBoxCenter,source:isOver,droppables,viewport});if(!destination)return null;const insideDestination=getDraggablesInsideDroppable(destination.descriptor.id,draggables),moveRelativeTo=(({pageBorderBoxCenter,viewport,destination,insideDestination,afterCritical})=>{const sorted=insideDestination.filter((draggable=>isTotallyVisible({target:getCurrentPageBorderBox(draggable,afterCritical),destination,viewport:viewport.frame,withDroppableDisplacement:!0}))).sort(((a,b)=>{const distanceToA=distance(pageBorderBoxCenter,withDroppableDisplacement(destination,getCurrentPageBorderBoxCenter(a,afterCritical))),distanceToB=distance(pageBorderBoxCenter,withDroppableDisplacement(destination,getCurrentPageBorderBoxCenter(b,afterCritical)));return distanceToA<distanceToB?-1:distanceToB<distanceToA?1:a.descriptor.index-b.descriptor.index}));return sorted[0]||null})({pageBorderBoxCenter:previousPageBorderBoxCenter,viewport,destination,insideDestination,afterCritical}),impact=(({previousPageBorderBoxCenter,moveRelativeTo,insideDestination,draggable,draggables,destination,viewport,afterCritical})=>{if(!moveRelativeTo){if(insideDestination.length)return null;const proposed={displaced:emptyGroups,displacedBy:noDisplacedBy,at:{type:"REORDER",destination:{droppableId:destination.descriptor.id,index:0}}},proposedPageBorderBoxCenter=getPageBorderBoxCenterFromImpact({impact:proposed,draggable,droppable:destination,draggables,afterCritical}),withPlaceholder=isHomeOf(draggable,destination)?destination:addPlaceholder(destination,draggable,draggables);return isTotallyVisibleInNewLocation({draggable,destination:withPlaceholder,newPageBorderBoxCenter:proposedPageBorderBoxCenter,viewport:viewport.frame,withDroppableDisplacement:!1,onlyOnMainAxis:!0})?proposed:null}const isGoingBeforeTarget=Boolean(previousPageBorderBoxCenter[destination.axis.line]<=moveRelativeTo.page.borderBox.center[destination.axis.line]),proposedIndex=(()=>{const relativeTo=moveRelativeTo.descriptor.index;return moveRelativeTo.descriptor.id===draggable.descriptor.id||isGoingBeforeTarget?relativeTo:relativeTo+1})(),displacedBy=getDisplacedBy(destination.axis,draggable.displaceBy);return calculateReorderImpact({draggable,insideDestination,destination,viewport,displacedBy,last:emptyGroups,index:proposedIndex})})({previousPageBorderBoxCenter,destination,draggable,draggables,moveRelativeTo,insideDestination,viewport,afterCritical});if(!impact)return null;const pageBorderBoxCenter=getPageBorderBoxCenterFromImpact({impact,draggable,droppable:destination,draggables,afterCritical});return{clientSelection:getClientFromPageBorderBoxCenter({pageBorderBoxCenter,draggable,viewport}),impact,scrollJumpRequest:null}},whatIsDraggedOver=impact=>{const at=impact.at;return at?"REORDER"===at.type?at.destination.droppableId:at.combine.droppableId:null};var moveInDirection=({state,type})=>{const isActuallyOver=((impact,droppables)=>{const id=whatIsDraggedOver(impact);return id?droppables[id]:null})(state.impact,state.dimensions.droppables),isMainAxisMovementAllowed=Boolean(isActuallyOver),home=state.dimensions.droppables[state.critical.droppable.id],isOver=isActuallyOver||home,direction=isOver.axis.direction,isMovingOnMainAxis="vertical"===direction&&("MOVE_UP"===type||"MOVE_DOWN"===type)||"horizontal"===direction&&("MOVE_LEFT"===type||"MOVE_RIGHT"===type);if(isMovingOnMainAxis&&!isMainAxisMovementAllowed)return null;const isMovingForward="MOVE_DOWN"===type||"MOVE_RIGHT"===type,draggable=state.dimensions.draggables[state.critical.draggable.id],previousPageBorderBoxCenter=state.current.page.borderBoxCenter,{draggables,droppables}=state.dimensions;return isMovingOnMainAxis?moveToNextPlace({isMovingForward,previousPageBorderBoxCenter,draggable,destination:isOver,draggables,viewport:state.viewport,previousClientSelection:state.current.client.selection,previousImpact:state.impact,afterCritical:state.afterCritical}):moveCrossAxis({isMovingForward,previousPageBorderBoxCenter,draggable,isOver,draggables,droppables,viewport:state.viewport,afterCritical:state.afterCritical})};function isMovementAllowed(state){return"DRAGGING"===state.phase||"COLLECTING"===state.phase}function isPositionInFrame(frame){const isWithinVertical=isWithin(frame.top,frame.bottom),isWithinHorizontal=isWithin(frame.left,frame.right);return function run(point){return isWithinVertical(point.y)&&isWithinHorizontal(point.x)}}function getDroppableOver({pageBorderBox,draggable,droppables}){const candidates=toDroppableList(droppables).filter((item=>{if(!item.isEnabled)return!1;const active=item.subject.active;if(!active)return!1;if(!function getHasOverlap(first,second){return first.left<second.right&&first.right>second.left&&first.top<second.bottom&&first.bottom>second.top}(pageBorderBox,active))return!1;if(isPositionInFrame(active)(pageBorderBox.center))return!0;const axis=item.axis,childCenter=active.center[axis.crossAxisLine],crossAxisStart=pageBorderBox[axis.crossAxisStart],crossAxisEnd=pageBorderBox[axis.crossAxisEnd],isContained=isWithin(active[axis.crossAxisStart],active[axis.crossAxisEnd]),isStartContained=isContained(crossAxisStart),isEndContained=isContained(crossAxisEnd);return!isStartContained&&!isEndContained||(isStartContained?crossAxisStart<childCenter:crossAxisEnd>childCenter)}));return candidates.length?1===candidates.length?candidates[0].descriptor.id:function getFurthestAway({pageBorderBox,draggable,candidates}){const startCenter=draggable.page.borderBox.center,sorted=candidates.map((candidate=>{const axis=candidate.axis,target=patch(candidate.axis.line,pageBorderBox.center[axis.line],candidate.page.borderBox.center[axis.crossAxisLine]);return{id:candidate.descriptor.id,distance:distance(startCenter,target)}})).sort(((a,b)=>b.distance-a.distance));return sorted[0]?sorted[0].id:null}({pageBorderBox,draggable,candidates}):null}const offsetRectByPosition=(rect,point)=>getRect(offsetByPosition(rect,point));function getIsDisplaced({displaced,id}){return Boolean(displaced.visible[id]||displaced.invisible[id])}var getDragImpact=({pageOffset,draggable,draggables,droppables,previousImpact,viewport,afterCritical})=>{const pageBorderBox=offsetRectByPosition(draggable.page.borderBox,pageOffset),destinationId=getDroppableOver({pageBorderBox,draggable,droppables});if(!destinationId)return noImpact$1;const destination=droppables[destinationId],insideDestination=getDraggablesInsideDroppable(destination.descriptor.id,draggables),pageBorderBoxWithDroppableScroll=((droppable,area)=>{const frame=droppable.frame;return frame?offsetRectByPosition(area,frame.scroll.diff.value):area})(destination,pageBorderBox);return(({draggable,pageBorderBoxWithDroppableScroll:targetRect,previousImpact,destination,insideDestination,afterCritical})=>{if(!destination.isCombineEnabled)return null;const axis=destination.axis,displacedBy=getDisplacedBy(destination.axis,draggable.displaceBy),displacement=displacedBy.value,targetStart=targetRect[axis.start],targetEnd=targetRect[axis.end],combineWith=removeDraggableFromList(draggable,insideDestination).find((child=>{const id=child.descriptor.id,childRect=child.page.borderBox,threshold=childRect[axis.size]/4,didStartAfterCritical$1=didStartAfterCritical(id,afterCritical),isDisplaced=getIsDisplaced({displaced:previousImpact.displaced,id});return didStartAfterCritical$1?isDisplaced?targetEnd>childRect[axis.start]+threshold&&targetEnd<childRect[axis.end]-threshold:targetStart>childRect[axis.start]-displacement+threshold&&targetStart<childRect[axis.end]-displacement-threshold:isDisplaced?targetEnd>childRect[axis.start]+displacement+threshold&&targetEnd<childRect[axis.end]+displacement-threshold:targetStart>childRect[axis.start]+threshold&&targetStart<childRect[axis.end]-threshold}));return combineWith?{displacedBy,displaced:previousImpact.displaced,at:{type:"COMBINE",combine:{draggableId:combineWith.descriptor.id,droppableId:destination.descriptor.id}}}:null})({pageBorderBoxWithDroppableScroll,draggable,previousImpact,destination,insideDestination,afterCritical})||(({pageBorderBoxWithDroppableScroll:targetRect,draggable,destination,insideDestination,last,viewport,afterCritical})=>{const axis=destination.axis,displacedBy=getDisplacedBy(destination.axis,draggable.displaceBy),displacement=displacedBy.value,targetStart=targetRect[axis.start],targetEnd=targetRect[axis.end],newIndex=function atIndex({draggable,closest,inHomeList}){return closest?inHomeList&&closest.descriptor.index>draggable.descriptor.index?closest.descriptor.index-1:closest.descriptor.index:null}({draggable,closest:removeDraggableFromList(draggable,insideDestination).find((child=>{const id=child.descriptor.id,childCenter=child.page.borderBox.center[axis.line],didStartAfterCritical$1=didStartAfterCritical(id,afterCritical),isDisplaced=getIsDisplaced({displaced:last,id});return didStartAfterCritical$1?isDisplaced?targetEnd<=childCenter:targetStart<childCenter-displacement:isDisplaced?targetEnd<=childCenter+displacement:targetStart<childCenter}))||null,inHomeList:isHomeOf(draggable,destination)});return calculateReorderImpact({draggable,insideDestination,destination,viewport,last,displacedBy,index:newIndex})})({pageBorderBoxWithDroppableScroll,draggable,destination,insideDestination,last:previousImpact.displaced,viewport,afterCritical})},patchDroppableMap=(droppables,updated)=>({...droppables,[updated.descriptor.id]:updated});const clearUnusedPlaceholder=({previousImpact,impact,droppables})=>{const last=whatIsDraggedOver(previousImpact),now=whatIsDraggedOver(impact);if(!last)return droppables;if(last===now)return droppables;const lastDroppable=droppables[last];if(!lastDroppable.subject.withPlaceholder)return droppables;const updated=(droppable=>{const added=droppable.subject.withPlaceholder;added||invariant(!1);const frame=droppable.frame;if(!frame){const subject=getSubject({page:droppable.subject.page,axis:droppable.axis,frame:null,withPlaceholder:null});return{...droppable,subject}}const oldMaxScroll=added.oldFrameMaxScroll;oldMaxScroll||invariant(!1);const newFrame=withMaxScroll(frame,oldMaxScroll),subject=getSubject({page:droppable.subject.page,axis:droppable.axis,frame:newFrame,withPlaceholder:null});return{...droppable,subject,frame:newFrame}})(lastDroppable);return patchDroppableMap(droppables,updated)};var update=({state,clientSelection:forcedClientSelection,dimensions:forcedDimensions,viewport:forcedViewport,impact:forcedImpact,scrollJumpRequest})=>{const viewport=forcedViewport||state.viewport,dimensions=forcedDimensions||state.dimensions,clientSelection=forcedClientSelection||state.current.client.selection,offset=subtract(clientSelection,state.initial.client.selection),client={offset,selection:clientSelection,borderBoxCenter:add(state.initial.client.borderBoxCenter,offset)},page={selection:add(client.selection,viewport.scroll.current),borderBoxCenter:add(client.borderBoxCenter,viewport.scroll.current),offset:add(client.offset,viewport.scroll.diff.value)},current={client,page};if("COLLECTING"===state.phase)return{...state,dimensions,viewport,current};const draggable=dimensions.draggables[state.critical.draggable.id],newImpact=forcedImpact||getDragImpact({pageOffset:page.offset,draggable,draggables:dimensions.draggables,droppables:dimensions.droppables,previousImpact:state.impact,viewport,afterCritical:state.afterCritical}),withUpdatedPlaceholders=(({draggable,draggables,droppables,previousImpact,impact})=>{const cleaned=clearUnusedPlaceholder({previousImpact,impact,droppables}),isOver=whatIsDraggedOver(impact);if(!isOver)return cleaned;const droppable=droppables[isOver];if(isHomeOf(draggable,droppable))return cleaned;if(droppable.subject.withPlaceholder)return cleaned;const patched=addPlaceholder(droppable,draggable,draggables);return patchDroppableMap(cleaned,patched)})({draggable,impact:newImpact,previousImpact:state.impact,draggables:dimensions.draggables,droppables:dimensions.droppables});return{...state,current,dimensions:{draggables:dimensions.draggables,droppables:withUpdatedPlaceholders},impact:newImpact,viewport,scrollJumpRequest:scrollJumpRequest||null,forceShouldAnimate:!scrollJumpRequest&&null}};var recompute=({impact,viewport,draggables,destination,forceShouldAnimate})=>{const last=impact.displaced,afterDragging=function getDraggables(ids,draggables){return ids.map((id=>draggables[id]))}(last.all,draggables),displaced=getDisplacementGroups({afterDragging,destination,displacedBy:impact.displacedBy,viewport:viewport.frame,forceShouldAnimate,last});return{...impact,displaced}},getClientBorderBoxCenter=({impact,draggable,droppable,draggables,viewport,afterCritical})=>{const pageBorderBoxCenter=getPageBorderBoxCenterFromImpact({impact,draggable,draggables,droppable,afterCritical});return getClientFromPageBorderBoxCenter({pageBorderBoxCenter,draggable,viewport})},refreshSnap=({state,dimensions:forcedDimensions,viewport:forcedViewport})=>{"SNAP"!==state.movementMode&&invariant(!1);const needsVisibilityCheck=state.impact,viewport=forcedViewport||state.viewport,dimensions=forcedDimensions||state.dimensions,{draggables,droppables}=dimensions,draggable=draggables[state.critical.draggable.id],isOver=whatIsDraggedOver(needsVisibilityCheck);isOver||invariant(!1);const destination=droppables[isOver],impact=recompute({impact:needsVisibilityCheck,viewport,destination,draggables}),clientSelection=getClientBorderBoxCenter({impact,draggable,droppable:destination,draggables,viewport,afterCritical:state.afterCritical});return update({impact,clientSelection,state,dimensions,viewport})},getLiftEffect=({draggable,home,draggables,viewport})=>{const displacedBy=getDisplacedBy(home.axis,draggable.displaceBy),insideHome=getDraggablesInsideDroppable(home.descriptor.id,draggables),rawIndex=insideHome.indexOf(draggable);-1===rawIndex&&invariant(!1);const afterDragging=insideHome.slice(rawIndex+1),effected=afterDragging.reduce(((previous,item)=>(previous[item.descriptor.id]=!0,previous)),{}),afterCritical={inVirtualList:"virtual"===home.descriptor.mode,displacedBy,effected};var descriptor;return{impact:{displaced:getDisplacementGroups({afterDragging,destination:home,displacedBy,last:null,viewport:viewport.frame,forceShouldAnimate:!1}),displacedBy,at:{type:"REORDER",destination:(descriptor=draggable.descriptor,{index:descriptor.index,droppableId:descriptor.droppableId})}},afterCritical}};const start=key=>{0},finish=key=>{0};var adjustAdditionsForScrollChanges=({additions,updatedDroppables,viewport})=>{const windowScrollChange=viewport.scroll.diff.value;return additions.map((draggable=>{const droppableId=draggable.descriptor.droppableId,frame=(droppable=>{const frame=droppable.frame;return frame||invariant(!1),frame})(updatedDroppables[droppableId]),droppableScrollChange=frame.scroll.diff.value,moved=(({draggable,offset:offset$1,initialWindowScroll})=>{const client=offset(draggable.client,offset$1),page=withScroll(client,initialWindowScroll);return{...draggable,placeholder:{...draggable.placeholder,client},client,page}})({draggable,offset:add(windowScrollChange,droppableScrollChange),initialWindowScroll:viewport.scroll.initial});return moved}))};const isSnapping=state=>"SNAP"===state.movementMode,postDroppableChange=(state,updated,isEnabledChanging)=>{const dimensions=((dimensions,updated)=>({draggables:dimensions.draggables,droppables:patchDroppableMap(dimensions.droppables,updated)}))(state.dimensions,updated);return!isSnapping(state)||isEnabledChanging?update({state,dimensions}):refreshSnap({state,dimensions})};function removeScrollJumpRequest(state){return state.isDragging&&"SNAP"===state.movementMode?{...state,scrollJumpRequest:null}:state}const idle$2={phase:"IDLE",completed:null,shouldFlush:!1};var reducer=(state=idle$2,action)=>{if("FLUSH"===action.type)return{...idle$2,shouldFlush:!0};if("INITIAL_PUBLISH"===action.type){"IDLE"!==state.phase&&invariant(!1);const{critical,clientSelection,viewport,dimensions,movementMode}=action.payload,draggable=dimensions.draggables[critical.draggable.id],home=dimensions.droppables[critical.droppable.id],client={selection:clientSelection,borderBoxCenter:draggable.client.borderBox.center,offset:origin},initial={client,page:{selection:add(client.selection,viewport.scroll.initial),borderBoxCenter:add(client.selection,viewport.scroll.initial),offset:add(client.selection,viewport.scroll.diff.value)}},isWindowScrollAllowed=toDroppableList(dimensions.droppables).every((item=>!item.isFixedOnPage)),{impact,afterCritical}=getLiftEffect({draggable,home,draggables:dimensions.draggables,viewport});return{phase:"DRAGGING",isDragging:!0,critical,movementMode,dimensions,initial,current:initial,isWindowScrollAllowed,impact,afterCritical,onLiftImpact:impact,viewport,scrollJumpRequest:null,forceShouldAnimate:null}}if("COLLECTION_STARTING"===action.type){if("COLLECTING"===state.phase||"DROP_PENDING"===state.phase)return state;"DRAGGING"!==state.phase&&invariant(!1);return{...state,phase:"COLLECTING"}}if("PUBLISH_WHILE_DRAGGING"===action.type)return"COLLECTING"!==state.phase&&"DROP_PENDING"!==state.phase&&invariant(!1),(({state,published})=>{start();const withScrollChange=published.modified.map((update=>{const existing=state.dimensions.droppables[update.droppableId];return scrollDroppable(existing,update.scroll)})),droppables={...state.dimensions.droppables,...toDroppableMap(withScrollChange)},updatedAdditions=toDraggableMap(adjustAdditionsForScrollChanges({additions:published.additions,updatedDroppables:droppables,viewport:state.viewport})),draggables={...state.dimensions.draggables,...updatedAdditions};published.removals.forEach((id=>{delete draggables[id]}));const dimensions={droppables,draggables},wasOverId=whatIsDraggedOver(state.impact),wasOver=wasOverId?dimensions.droppables[wasOverId]:null,draggable=dimensions.draggables[state.critical.draggable.id],home=dimensions.droppables[state.critical.droppable.id],{impact:onLiftImpact,afterCritical}=getLiftEffect({draggable,home,draggables,viewport:state.viewport}),previousImpact=wasOver&&wasOver.isCombineEnabled?state.impact:onLiftImpact,impact=getDragImpact({pageOffset:state.current.page.offset,draggable:dimensions.draggables[state.critical.draggable.id],draggables:dimensions.draggables,droppables:dimensions.droppables,previousImpact,viewport:state.viewport,afterCritical});finish();const draggingState={...state,phase:"DRAGGING",impact,onLiftImpact,dimensions,afterCritical,forceShouldAnimate:!1};return"COLLECTING"===state.phase?draggingState:{...draggingState,phase:"DROP_PENDING",reason:state.reason,isWaiting:!1}})({state,published:action.payload});if("MOVE"===action.type){if("DROP_PENDING"===state.phase)return state;isMovementAllowed(state)||invariant(!1);const{client:clientSelection}=action.payload;return isEqual$1(clientSelection,state.current.client.selection)?state:update({state,clientSelection,impact:isSnapping(state)?state.impact:null})}if("UPDATE_DROPPABLE_SCROLL"===action.type){if("DROP_PENDING"===state.phase)return removeScrollJumpRequest(state);if("COLLECTING"===state.phase)return removeScrollJumpRequest(state);isMovementAllowed(state)||invariant(!1);const{id,newScroll}=action.payload,target=state.dimensions.droppables[id];if(!target)return state;const scrolled=scrollDroppable(target,newScroll);return postDroppableChange(state,scrolled,!1)}if("UPDATE_DROPPABLE_IS_ENABLED"===action.type){if("DROP_PENDING"===state.phase)return state;isMovementAllowed(state)||invariant(!1);const{id,isEnabled}=action.payload,target=state.dimensions.droppables[id];target||invariant(!1),target.isEnabled===isEnabled&&invariant(!1);const updated={...target,isEnabled};return postDroppableChange(state,updated,!0)}if("UPDATE_DROPPABLE_IS_COMBINE_ENABLED"===action.type){if("DROP_PENDING"===state.phase)return state;isMovementAllowed(state)||invariant(!1);const{id,isCombineEnabled}=action.payload,target=state.dimensions.droppables[id];target||invariant(!1),target.isCombineEnabled===isCombineEnabled&&invariant(!1);const updated={...target,isCombineEnabled};return postDroppableChange(state,updated,!0)}if("MOVE_BY_WINDOW_SCROLL"===action.type){if("DROP_PENDING"===state.phase||"DROP_ANIMATING"===state.phase)return state;isMovementAllowed(state)||invariant(!1),state.isWindowScrollAllowed||invariant(!1);const newScroll=action.payload.newScroll;if(isEqual$1(state.viewport.scroll.current,newScroll))return removeScrollJumpRequest(state);const viewport=scrollViewport(state.viewport,newScroll);return isSnapping(state)?refreshSnap({state,viewport}):update({state,viewport})}if("UPDATE_VIEWPORT_MAX_SCROLL"===action.type){if(!isMovementAllowed(state))return state;const maxScroll=action.payload.maxScroll;if(isEqual$1(maxScroll,state.viewport.scroll.max))return state;const withMaxScroll={...state.viewport,scroll:{...state.viewport.scroll,max:maxScroll}};return{...state,viewport:withMaxScroll}}if("MOVE_UP"===action.type||"MOVE_DOWN"===action.type||"MOVE_LEFT"===action.type||"MOVE_RIGHT"===action.type){if("COLLECTING"===state.phase||"DROP_PENDING"===state.phase)return state;"DRAGGING"!==state.phase&&invariant(!1);const result=moveInDirection({state,type:action.type});return result?update({state,impact:result.impact,clientSelection:result.clientSelection,scrollJumpRequest:result.scrollJumpRequest}):state}if("DROP_PENDING"===action.type){const reason=action.payload.reason;"COLLECTING"!==state.phase&&invariant(!1);return{...state,phase:"DROP_PENDING",isWaiting:!0,reason}}if("DROP_ANIMATE"===action.type){const{completed,dropDuration,newHomeClientOffset}=action.payload;"DRAGGING"!==state.phase&&"DROP_PENDING"!==state.phase&&invariant(!1);return{phase:"DROP_ANIMATING",completed,dropDuration,newHomeClientOffset,dimensions:state.dimensions}}if("DROP_COMPLETE"===action.type){const{completed}=action.payload;return{phase:"IDLE",completed,shouldFlush:!1}}return state};const lift$1=args=>({type:"LIFT",payload:args}),publishWhileDragging=args=>({type:"PUBLISH_WHILE_DRAGGING",payload:args}),collectionStarting=()=>({type:"COLLECTION_STARTING",payload:null}),updateDroppableScroll=args=>({type:"UPDATE_DROPPABLE_SCROLL",payload:args}),updateDroppableIsEnabled=args=>({type:"UPDATE_DROPPABLE_IS_ENABLED",payload:args}),updateDroppableIsCombineEnabled=args=>({type:"UPDATE_DROPPABLE_IS_COMBINE_ENABLED",payload:args}),move=args=>({type:"MOVE",payload:args}),moveUp=()=>({type:"MOVE_UP",payload:null}),moveDown=()=>({type:"MOVE_DOWN",payload:null}),moveRight=()=>({type:"MOVE_RIGHT",payload:null}),moveLeft=()=>({type:"MOVE_LEFT",payload:null}),flush=()=>({type:"FLUSH",payload:null}),completeDrop=args=>({type:"DROP_COMPLETE",payload:args}),drop$1=args=>({type:"DROP",payload:args}),dropAnimationFinished=()=>({type:"DROP_ANIMATION_FINISHED",payload:null});const curves_drop="cubic-bezier(.2,1,.1,1)",combine_opacity={drop:0,combining:.7},combine_scale={drop:.75},timings={outOfTheWay:.2,minDropTime:.33,maxDropTime:.55},outOfTheWayTiming=`${timings.outOfTheWay}s ${"cubic-bezier(0.2, 0, 0, 1)"}`,transitions={fluid:`opacity ${outOfTheWayTiming}`,snap:`transform ${outOfTheWayTiming}, opacity ${outOfTheWayTiming}`,drop:duration=>{const timing=`${duration}s ${curves_drop}`;return`transform ${timing}, opacity ${timing}`},outOfTheWay:`transform ${outOfTheWayTiming}`,placeholder:`height ${outOfTheWayTiming}, width ${outOfTheWayTiming}, margin ${outOfTheWayTiming}`},moveTo=offset=>isEqual$1(offset,origin)?void 0:`translate(${offset.x}px, ${offset.y}px)`,transforms_moveTo=moveTo,transforms_drop=(offset,isCombining)=>{const translate=moveTo(offset);if(translate)return isCombining?`${translate} scale(${combine_scale.drop})`:translate},{minDropTime,maxDropTime}=timings,dropTimeRange=maxDropTime-minDropTime;var drop=({getState,dispatch})=>next=>action=>{if("DROP"!==action.type)return void next(action);const state=getState(),reason=action.payload.reason;if("COLLECTING"===state.phase)return void dispatch((args=>({type:"DROP_PENDING",payload:args}))({reason}));if("IDLE"===state.phase)return;"DROP_PENDING"===state.phase&&state.isWaiting&&invariant(!1),"DRAGGING"!==state.phase&&"DROP_PENDING"!==state.phase&&invariant(!1);const critical=state.critical,dimensions=state.dimensions,draggable=dimensions.draggables[state.critical.draggable.id],{impact,didDropInsideDroppable}=(({draggables,reason,lastImpact,home,viewport,onLiftImpact})=>{if(!lastImpact.at||"DROP"!==reason)return{impact:recompute({draggables,impact:onLiftImpact,destination:home,viewport,forceShouldAnimate:!0}),didDropInsideDroppable:!1};return"REORDER"===lastImpact.at.type?{impact:lastImpact,didDropInsideDroppable:!0}:{impact:{...lastImpact,displaced:emptyGroups},didDropInsideDroppable:!0}})({reason,lastImpact:state.impact,afterCritical:state.afterCritical,onLiftImpact:state.onLiftImpact,home:state.dimensions.droppables[state.critical.droppable.id],viewport:state.viewport,draggables:state.dimensions.draggables}),destination=didDropInsideDroppable?tryGetDestination(impact):null,combine=didDropInsideDroppable?tryGetCombine(impact):null,source={index:critical.draggable.index,droppableId:critical.droppable.id},result={draggableId:draggable.descriptor.id,type:draggable.descriptor.type,source,reason,mode:state.movementMode,destination,combine},newHomeClientOffset=(({impact,draggable,dimensions,viewport,afterCritical})=>{const{draggables,droppables}=dimensions,droppableId=whatIsDraggedOver(impact),destination=droppableId?droppables[droppableId]:null,home=droppables[draggable.descriptor.droppableId],newClientCenter=getClientBorderBoxCenter({impact,draggable,draggables,afterCritical,droppable:destination||home,viewport});return subtract(newClientCenter,draggable.client.borderBox.center)})({impact,draggable,dimensions,viewport:state.viewport,afterCritical:state.afterCritical}),completed={critical:state.critical,afterCritical:state.afterCritical,result,impact};if(!(!isEqual$1(state.current.client.offset,newHomeClientOffset)||Boolean(result.combine)))return void dispatch(completeDrop({completed}));const dropDuration=(({current,destination,reason})=>{const distance$1=distance(current,destination);if(distance$1<=0)return minDropTime;if(distance$1>=1500)return maxDropTime;const duration=minDropTime+dropTimeRange*(distance$1/1500);return Number(("CANCEL"===reason?.6*duration:duration).toFixed(2))})({current:state.current.client.offset,destination:newHomeClientOffset,reason});dispatch((args=>({type:"DROP_ANIMATE",payload:args}))({newHomeClientOffset,dropDuration,completed}))},dnd_esm_getWindowScroll=()=>({x:window.pageXOffset,y:window.pageYOffset});function getScrollListener({onWindowScroll}){const scheduled=raf_schd_esm((function updateScroll(){onWindowScroll(dnd_esm_getWindowScroll())})),binding=function getWindowScrollBinding(update){return{eventName:"scroll",options:{passive:!0,capture:!1},fn:event=>{event.target!==window&&event.target!==window.document||update()}}}(scheduled);let unbind=noop$2;function isActive(){return unbind!==noop$2}return{start:function start(){isActive()&&invariant(!1),unbind=bindEvents(window,[binding])},stop:function stop(){isActive()||invariant(!1),scheduled.cancel(),unbind(),unbind=noop$2},isActive}}var scrollListener$1=store=>{const listener=getScrollListener({onWindowScroll:newScroll=>{store.dispatch({type:"MOVE_BY_WINDOW_SCROLL",payload:{newScroll}})}});return next=>action=>{listener.isActive()||"INITIAL_PUBLISH"!==action.type||listener.start(),listener.isActive()&&(action=>"DROP_COMPLETE"===action.type||"DROP_ANIMATE"===action.type||"FLUSH"===action.type)(action)&&listener.stop(),next(action)}},getAsyncMarshal=()=>{const entries=[];return{add:fn=>{const timerId=setTimeout((()=>(timerId=>{const index=entries.findIndex((item=>item.timerId===timerId));-1===index&&invariant(!1);const[entry]=entries.splice(index,1);entry.callback()})(timerId))),entry={timerId,callback:fn};entries.push(entry)},flush:()=>{if(!entries.length)return;const shallow=[...entries];entries.length=0,shallow.forEach((entry=>{clearTimeout(entry.timerId),entry.callback()}))}}};const withTimings=(key,fn)=>{start(),fn(),finish()},getDragStart=(critical,mode)=>({draggableId:critical.draggable.id,type:critical.droppable.type,source:{droppableId:critical.droppable.id,index:critical.draggable.index},mode});function execute(responder,data,announce,getDefaultMessage){if(!responder)return void announce(getDefaultMessage(data));const willExpire=(announce=>{let wasCalled=!1,isExpired=!1;const timeoutId=setTimeout((()=>{isExpired=!0})),result=message=>{wasCalled||isExpired||(wasCalled=!0,announce(message),clearTimeout(timeoutId))};return result.wasCalled=()=>wasCalled,result})(announce);responder(data,{announce:willExpire}),willExpire.wasCalled()||announce(getDefaultMessage(data))}var responders=(getResponders,announce)=>{const publisher=((getResponders,announce)=>{const asyncMarshal=getAsyncMarshal();let dragging=null;const drop=result=>{dragging||invariant(!1),dragging=null,withTimings(0,(()=>execute(getResponders().onDragEnd,result,announce,preset$1.onDragEnd)))};return{beforeCapture:(draggableId,mode)=>{dragging&&invariant(!1),withTimings(0,(()=>{const fn=getResponders().onBeforeCapture;fn&&fn({draggableId,mode})}))},beforeStart:(critical,mode)=>{dragging&&invariant(!1),withTimings(0,(()=>{const fn=getResponders().onBeforeDragStart;fn&&fn(getDragStart(critical,mode))}))},start:(critical,mode)=>{dragging&&invariant(!1);const data=getDragStart(critical,mode);dragging={mode,lastCritical:critical,lastLocation:data.source,lastCombine:null},asyncMarshal.add((()=>{withTimings(0,(()=>execute(getResponders().onDragStart,data,announce,preset$1.onDragStart)))}))},update:(critical,impact)=>{const location=tryGetDestination(impact),combine=tryGetCombine(impact);dragging||invariant(!1);const hasCriticalChanged=!((first,second)=>{if(first===second)return!0;const isDraggableEqual=first.draggable.id===second.draggable.id&&first.draggable.droppableId===second.draggable.droppableId&&first.draggable.type===second.draggable.type&&first.draggable.index===second.draggable.index,isDroppableEqual=first.droppable.id===second.droppable.id&&first.droppable.type===second.droppable.type;return isDraggableEqual&&isDroppableEqual})(critical,dragging.lastCritical);hasCriticalChanged&&(dragging.lastCritical=critical);const hasLocationChanged=(second=location,!(null==(first=dragging.lastLocation)&&null==second||null!=first&&null!=second&&first.droppableId===second.droppableId&&first.index===second.index));var first,second;hasLocationChanged&&(dragging.lastLocation=location);const hasGroupingChanged=!((first,second)=>null==first&&null==second||null!=first&&null!=second&&first.draggableId===second.draggableId&&first.droppableId===second.droppableId)(dragging.lastCombine,combine);if(hasGroupingChanged&&(dragging.lastCombine=combine),!hasCriticalChanged&&!hasLocationChanged&&!hasGroupingChanged)return;const data={...getDragStart(critical,dragging.mode),combine,destination:location};asyncMarshal.add((()=>{withTimings(0,(()=>execute(getResponders().onDragUpdate,data,announce,preset$1.onDragUpdate)))}))},flush:()=>{dragging||invariant(!1),asyncMarshal.flush()},drop,abort:()=>{if(!dragging)return;const result={...getDragStart(dragging.lastCritical,dragging.mode),combine:null,destination:null,reason:"CANCEL"};drop(result)}}})(getResponders,announce);return store=>next=>action=>{if("BEFORE_INITIAL_CAPTURE"===action.type)return void publisher.beforeCapture(action.payload.draggableId,action.payload.movementMode);if("INITIAL_PUBLISH"===action.type){const critical=action.payload.critical;return publisher.beforeStart(critical,action.payload.movementMode),next(action),void publisher.start(critical,action.payload.movementMode)}if("DROP_COMPLETE"===action.type){const result=action.payload.completed.result;return publisher.flush(),next(action),void publisher.drop(result)}if(next(action),"FLUSH"===action.type)return void publisher.abort();const state=store.getState();"DRAGGING"===state.phase&&publisher.update(state.critical,state.impact)}};var dropAnimationFinish=store=>next=>action=>{if("DROP_ANIMATION_FINISHED"!==action.type)return void next(action);const state=store.getState();"DROP_ANIMATING"!==state.phase&&invariant(!1),store.dispatch(completeDrop({completed:state.completed}))};var dropAnimationFlushOnScroll=store=>{let unbind=null,frameId=null;return next=>action=>{if("FLUSH"!==action.type&&"DROP_COMPLETE"!==action.type&&"DROP_ANIMATION_FINISHED"!==action.type||function clear(){frameId&&(cancelAnimationFrame(frameId),frameId=null),unbind&&(unbind(),unbind=null)}(),next(action),"DROP_ANIMATE"!==action.type)return;const binding={eventName:"scroll",options:{capture:!0,passive:!1,once:!0},fn:function flushDropAnimation(){"DROP_ANIMATING"===store.getState().phase&&store.dispatch({type:"DROP_ANIMATION_FINISHED",payload:null})}};frameId=requestAnimationFrame((()=>{frameId=null,unbind=bindEvents(window,[binding])}))}};var pendingDrop$1=store=>next=>action=>{if(next(action),"PUBLISH_WHILE_DRAGGING"!==action.type)return;const postActionState=store.getState();"DROP_PENDING"===postActionState.phase&&(postActionState.isWaiting||store.dispatch(drop$1({reason:postActionState.reason})))};const composeEnhancers=redux.Zz;var createStore=({dimensionMarshal,focusMarshal,styleMarshal,getResponders,announce,autoScroller})=>{return(0,redux.y$)(reducer,composeEnhancers((0,redux.Tw)((marshal=styleMarshal,()=>next=>action=>{"INITIAL_PUBLISH"===action.type&&marshal.dragging(),"DROP_ANIMATE"===action.type&&marshal.dropping(action.payload.completed.result.reason),"FLUSH"!==action.type&&"DROP_COMPLETE"!==action.type||marshal.resting(),next(action)}),(marshal=>()=>next=>action=>{"DROP_COMPLETE"!==action.type&&"FLUSH"!==action.type&&"DROP_ANIMATE"!==action.type||marshal.stopPublishing(),next(action)})(dimensionMarshal),(marshal=>({getState,dispatch})=>next=>action=>{if("LIFT"!==action.type)return void next(action);const{id,clientSelection,movementMode}=action.payload,initial=getState();"DROP_ANIMATING"===initial.phase&&dispatch(completeDrop({completed:initial.completed})),"IDLE"!==getState().phase&&invariant(!1),dispatch(flush()),dispatch({type:"BEFORE_INITIAL_CAPTURE",payload:{draggableId:id,movementMode}});const request={draggableId:id,scrollOptions:{shouldPublishImmediately:"SNAP"===movementMode}},{critical,dimensions,viewport}=marshal.startPublishing(request);dispatch({type:"INITIAL_PUBLISH",payload:{critical,dimensions,clientSelection,movementMode,viewport}})})(dimensionMarshal),drop,dropAnimationFinish,dropAnimationFlushOnScroll,pendingDrop$1,(autoScroller=>store=>next=>action=>{if((action=>"DROP_COMPLETE"===action.type||"DROP_ANIMATE"===action.type||"FLUSH"===action.type)(action))return autoScroller.stop(),void next(action);if("INITIAL_PUBLISH"===action.type){next(action);const state=store.getState();return"DRAGGING"!==state.phase&&invariant(!1),void autoScroller.start(state)}next(action),autoScroller.scroll(store.getState())})(autoScroller),scrollListener$1,(marshal=>{let isWatching=!1;return()=>next=>action=>{if("INITIAL_PUBLISH"===action.type)return isWatching=!0,marshal.tryRecordFocus(action.payload.critical.draggable.id),next(action),void marshal.tryRestoreFocusRecorded();if(next(action),isWatching){if("FLUSH"===action.type)return isWatching=!1,void marshal.tryRestoreFocusRecorded();if("DROP_COMPLETE"===action.type){isWatching=!1;const result=action.payload.completed.result;result.combine&&marshal.tryShiftRecord(result.draggableId,result.combine.draggableId),marshal.tryRestoreFocusRecorded()}}}})(focusMarshal),responders(getResponders,announce))));var marshal};var getMaxScroll=({scrollHeight,scrollWidth,height,width})=>{const maxScroll=subtract({x:scrollWidth,y:scrollHeight},{x:width,y:height});return{x:Math.max(0,maxScroll.x),y:Math.max(0,maxScroll.y)}},getDocumentElement=()=>{const doc=document.documentElement;return doc||invariant(!1),doc},getMaxWindowScroll=()=>{const doc=getDocumentElement();return getMaxScroll({scrollHeight:doc.scrollHeight,scrollWidth:doc.scrollWidth,width:doc.clientWidth,height:doc.clientHeight})},getInitialPublish=({critical,scrollOptions,registry})=>{start();const viewport=(()=>{const scroll=dnd_esm_getWindowScroll(),maxScroll=getMaxWindowScroll(),top=scroll.y,left=scroll.x,doc=getDocumentElement(),width=doc.clientWidth,height=doc.clientHeight;return{frame:getRect({top,left,right:left+width,bottom:top+height}),scroll:{initial:scroll,current:scroll,max:maxScroll,diff:{value:origin,displacement:origin}}}})(),windowScroll=viewport.scroll.current,home=critical.droppable,droppables=registry.droppable.getAllByType(home.type).map((entry=>entry.callbacks.getDimensionAndWatchScroll(windowScroll,scrollOptions))),draggables=registry.draggable.getAllByType(critical.draggable.type).map((entry=>entry.getDimension(windowScroll))),dimensions={draggables:toDraggableMap(draggables),droppables:toDroppableMap(droppables)};finish();return{dimensions,critical,viewport}};function shouldPublishUpdate(registry,dragging,entry){if(entry.descriptor.id===dragging.id)return!1;if(entry.descriptor.type!==dragging.type)return!1;return"virtual"===registry.droppable.getById(entry.descriptor.droppableId).descriptor.mode}var createDimensionMarshal=(registry,callbacks)=>{let collection=null;const publisher=function createPublisher({registry,callbacks}){let staging={additions:{},removals:{},modified:{}},frameId=null;const collect=()=>{frameId||(callbacks.collectionStarting(),frameId=requestAnimationFrame((()=>{frameId=null,start();const{additions,removals,modified}=staging,added=Object.keys(additions).map((id=>registry.draggable.getById(id).getDimension(origin))).sort(((a,b)=>a.descriptor.index-b.descriptor.index)),updated=Object.keys(modified).map((id=>({droppableId:id,scroll:registry.droppable.getById(id).callbacks.getScrollWhileDragging()}))),result={additions:added,removals:Object.keys(removals),modified:updated};staging={additions:{},removals:{},modified:{}},finish(),callbacks.publish(result)})))};return{add:entry=>{const id=entry.descriptor.id;staging.additions[id]=entry,staging.modified[entry.descriptor.droppableId]=!0,staging.removals[id]&&delete staging.removals[id],collect()},remove:entry=>{const descriptor=entry.descriptor;staging.removals[descriptor.id]=!0,staging.modified[descriptor.droppableId]=!0,staging.additions[descriptor.id]&&delete staging.additions[descriptor.id],collect()},stop:()=>{frameId&&(cancelAnimationFrame(frameId),frameId=null,staging={additions:{},removals:{},modified:{}})}}}({callbacks:{publish:callbacks.publishWhileDragging,collectionStarting:callbacks.collectionStarting},registry}),subscriber=event=>{collection||invariant(!1);const dragging=collection.critical.draggable;"ADDITION"===event.type&&shouldPublishUpdate(registry,dragging,event.value)&&publisher.add(event.value),"REMOVAL"===event.type&&shouldPublishUpdate(registry,dragging,event.value)&&publisher.remove(event.value)},marshal={updateDroppableIsEnabled:(id,isEnabled)=>{registry.droppable.exists(id)||invariant(!1),collection&&callbacks.updateDroppableIsEnabled({id,isEnabled})},updateDroppableIsCombineEnabled:(id,isCombineEnabled)=>{collection&&(registry.droppable.exists(id)||invariant(!1),callbacks.updateDroppableIsCombineEnabled({id,isCombineEnabled}))},scrollDroppable:(id,change)=>{collection&&registry.droppable.getById(id).callbacks.scroll(change)},updateDroppableScroll:(id,newScroll)=>{collection&&(registry.droppable.exists(id)||invariant(!1),callbacks.updateDroppableScroll({id,newScroll}))},startPublishing:request=>{collection&&invariant(!1);const entry=registry.draggable.getById(request.draggableId),home=registry.droppable.getById(entry.descriptor.droppableId),critical={draggable:entry.descriptor,droppable:home.descriptor},unsubscribe=registry.subscribe(subscriber);return collection={critical,unsubscribe},getInitialPublish({critical,registry,scrollOptions:request.scrollOptions})},stopPublishing:()=>{if(!collection)return;publisher.stop();const home=collection.critical.droppable;registry.droppable.getAllByType(home.type).forEach((entry=>entry.callbacks.dragStopped())),collection.unsubscribe(),collection=null}};return marshal},canStartDrag=(state,id)=>"IDLE"===state.phase||"DROP_ANIMATING"===state.phase&&(state.completed.result.draggableId!==id&&"DROP"===state.completed.result.reason),scrollWindow=change=>{window.scrollBy(change.x,change.y)};const getScrollableDroppables=(0,memoize_one_esm.A)((droppables=>toDroppableList(droppables).filter((droppable=>!!droppable.isEnabled&&!!droppable.frame))));var getBestScrollableDroppable=({center,destination,droppables})=>{if(destination){const dimension=droppables[destination];return dimension.frame?dimension:null}const dimension=((target,droppables)=>{const maybe=getScrollableDroppables(droppables).find((droppable=>(droppable.frame||invariant(!1),isPositionInFrame(droppable.frame.pageMarginBox)(target))))||null;return maybe})(center,droppables);return dimension};const defaultAutoScrollerOptions={startFromPercentage:.25,maxScrollAtPercentage:.05,maxPixelScroll:28,ease:percentage=>percentage**2,durationDampening:{stopDampeningAt:1200,accelerateAt:360},disabled:!1};var getPercentage=({startOfRange,endOfRange,current})=>{const range=endOfRange-startOfRange;if(0===range)return 0;return(current-startOfRange)/range},getValue=({distanceToEdge,thresholds,dragStartTime,shouldUseTimeDampening,getAutoScrollerOptions})=>{const scroll=((distanceToEdge,thresholds,getAutoScrollerOptions=()=>defaultAutoScrollerOptions)=>{const autoScrollerOptions=getAutoScrollerOptions();if(distanceToEdge>thresholds.startScrollingFrom)return 0;if(distanceToEdge<=thresholds.maxScrollValueAt)return autoScrollerOptions.maxPixelScroll;if(distanceToEdge===thresholds.startScrollingFrom)return 1;const percentageFromStartScrollingFrom=1-getPercentage({startOfRange:thresholds.maxScrollValueAt,endOfRange:thresholds.startScrollingFrom,current:distanceToEdge}),scroll=autoScrollerOptions.maxPixelScroll*autoScrollerOptions.ease(percentageFromStartScrollingFrom);return Math.ceil(scroll)})(distanceToEdge,thresholds,getAutoScrollerOptions);return 0===scroll?0:shouldUseTimeDampening?Math.max(((proposedScroll,dragStartTime,getAutoScrollerOptions)=>{const autoScrollerOptions=getAutoScrollerOptions(),accelerateAt=autoScrollerOptions.durationDampening.accelerateAt,stopAt=autoScrollerOptions.durationDampening.stopDampeningAt,startOfRange=dragStartTime,endOfRange=stopAt,runTime=Date.now()-startOfRange;if(runTime>=stopAt)return proposedScroll;if(runTime<accelerateAt)return 1;const betweenAccelerateAtAndStopAtPercentage=getPercentage({startOfRange:accelerateAt,endOfRange,current:runTime}),scroll=proposedScroll*autoScrollerOptions.ease(betweenAccelerateAtAndStopAtPercentage);return Math.ceil(scroll)})(scroll,dragStartTime,getAutoScrollerOptions),1):scroll},getScrollOnAxis=({container,distanceToEdges,dragStartTime,axis,shouldUseTimeDampening,getAutoScrollerOptions})=>{const thresholds=((container,axis,getAutoScrollerOptions=()=>defaultAutoScrollerOptions)=>{const autoScrollerOptions=getAutoScrollerOptions();return{startScrollingFrom:container[axis.size]*autoScrollerOptions.startFromPercentage,maxScrollValueAt:container[axis.size]*autoScrollerOptions.maxScrollAtPercentage}})(container,axis,getAutoScrollerOptions);return distanceToEdges[axis.end]<distanceToEdges[axis.start]?getValue({distanceToEdge:distanceToEdges[axis.end],thresholds,dragStartTime,shouldUseTimeDampening,getAutoScrollerOptions}):-1*getValue({distanceToEdge:distanceToEdges[axis.start],thresholds,dragStartTime,shouldUseTimeDampening,getAutoScrollerOptions})};const clean=apply((value=>0===value?0:value));var getScroll$1=({dragStartTime,container,subject,center,shouldUseTimeDampening,getAutoScrollerOptions})=>{const distanceToEdges={top:center.y-container.top,right:container.right-center.x,bottom:container.bottom-center.y,left:center.x-container.left},y=getScrollOnAxis({container,distanceToEdges,dragStartTime,axis:vertical,shouldUseTimeDampening,getAutoScrollerOptions}),x=getScrollOnAxis({container,distanceToEdges,dragStartTime,axis:horizontal,shouldUseTimeDampening,getAutoScrollerOptions}),required=clean({x,y});if(isEqual$1(required,origin))return null;const limited=(({container,subject,proposedScroll})=>{const isTooBigVertically=subject.height>container.height,isTooBigHorizontally=subject.width>container.width;return isTooBigHorizontally||isTooBigVertically?isTooBigHorizontally&&isTooBigVertically?null:{x:isTooBigHorizontally?0:proposedScroll.x,y:isTooBigVertically?0:proposedScroll.y}:proposedScroll})({container,subject,proposedScroll:required});return limited?isEqual$1(limited,origin)?null:limited:null};const smallestSigned=apply((value=>0===value?0:value>0?1:-1)),getOverlap=(()=>{const getRemainder=(target,max)=>target<0?target:target>max?target-max:0;return({current,max,change})=>{const targetScroll=add(current,change),overlap={x:getRemainder(targetScroll.x,max.x),y:getRemainder(targetScroll.y,max.y)};return isEqual$1(overlap,origin)?null:overlap}})(),canPartiallyScroll=({max:rawMax,current,change})=>{const max={x:Math.max(current.x,rawMax.x),y:Math.max(current.y,rawMax.y)},smallestChange=smallestSigned(change),overlap=getOverlap({max,current,change:smallestChange});return!overlap||(0!==smallestChange.x&&0===overlap.x||0!==smallestChange.y&&0===overlap.y)},canScrollWindow=(viewport,change)=>canPartiallyScroll({current:viewport.scroll.current,max:viewport.scroll.max,change}),canScrollDroppable=(droppable,change)=>{const frame=droppable.frame;return!!frame&&canPartiallyScroll({current:frame.scroll.current,max:frame.scroll.max,change})};var dnd_esm_scroll=({state,dragStartTime,shouldUseTimeDampening,scrollWindow,scrollDroppable,getAutoScrollerOptions})=>{const center=state.current.page.borderBoxCenter,subject=state.dimensions.draggables[state.critical.draggable.id].page.marginBox;if(state.isWindowScrollAllowed){const change=(({viewport,subject,center,dragStartTime,shouldUseTimeDampening,getAutoScrollerOptions})=>{const scroll=getScroll$1({dragStartTime,container:viewport.frame,subject,center,shouldUseTimeDampening,getAutoScrollerOptions});return scroll&&canScrollWindow(viewport,scroll)?scroll:null})({dragStartTime,viewport:state.viewport,subject,center,shouldUseTimeDampening,getAutoScrollerOptions});if(change)return void scrollWindow(change)}const droppable=getBestScrollableDroppable({center,destination:whatIsDraggedOver(state.impact),droppables:state.dimensions.droppables});if(!droppable)return;const change=(({droppable,subject,center,dragStartTime,shouldUseTimeDampening,getAutoScrollerOptions})=>{const frame=droppable.frame;if(!frame)return null;const scroll=getScroll$1({dragStartTime,container:frame.pageMarginBox,subject,center,shouldUseTimeDampening,getAutoScrollerOptions});return scroll&&canScrollDroppable(droppable,scroll)?scroll:null})({dragStartTime,droppable,subject,center,shouldUseTimeDampening,getAutoScrollerOptions});change&&scrollDroppable(droppable.descriptor.id,change)},createJumpScroller=({move,scrollDroppable,scrollWindow})=>{const scrollDroppableAsMuchAsItCan=(droppable,change)=>{if(!canScrollDroppable(droppable,change))return change;const overlap=((droppable,change)=>{const frame=droppable.frame;return frame&&canScrollDroppable(droppable,change)?getOverlap({current:frame.scroll.current,max:frame.scroll.max,change}):null})(droppable,change);if(!overlap)return scrollDroppable(droppable.descriptor.id,change),null;const whatTheDroppableCanScroll=subtract(change,overlap);scrollDroppable(droppable.descriptor.id,whatTheDroppableCanScroll);return subtract(change,whatTheDroppableCanScroll)},scrollWindowAsMuchAsItCan=(isWindowScrollAllowed,viewport,change)=>{if(!isWindowScrollAllowed)return change;if(!canScrollWindow(viewport,change))return change;const overlap=((viewport,change)=>{if(!canScrollWindow(viewport,change))return null;const max=viewport.scroll.max,current=viewport.scroll.current;return getOverlap({current,max,change})})(viewport,change);if(!overlap)return scrollWindow(change),null;const whatTheWindowCanScroll=subtract(change,overlap);scrollWindow(whatTheWindowCanScroll);return subtract(change,whatTheWindowCanScroll)};return state=>{const request=state.scrollJumpRequest;if(!request)return;const destination=whatIsDraggedOver(state.impact);destination||invariant(!1);const droppableRemainder=scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination],request);if(!droppableRemainder)return;const viewport=state.viewport,windowRemainder=scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed,viewport,droppableRemainder);windowRemainder&&((state,offset)=>{const client=add(state.current.client.selection,offset);move({client})})(state,windowRemainder)}},createAutoScroller=({scrollDroppable,scrollWindow,move,getAutoScrollerOptions})=>{const fluidScroller=(({scrollWindow,scrollDroppable,getAutoScrollerOptions=()=>defaultAutoScrollerOptions})=>{const scheduleWindowScroll=raf_schd_esm(scrollWindow),scheduleDroppableScroll=raf_schd_esm(scrollDroppable);let dragging=null;const tryScroll=state=>{dragging||invariant(!1);const{shouldUseTimeDampening,dragStartTime}=dragging;dnd_esm_scroll({state,scrollWindow:scheduleWindowScroll,scrollDroppable:scheduleDroppableScroll,dragStartTime,shouldUseTimeDampening,getAutoScrollerOptions})};return{start:state=>{start(),dragging&&invariant(!1);const dragStartTime=Date.now();let wasScrollNeeded=!1;const fakeScrollCallback=()=>{wasScrollNeeded=!0};dnd_esm_scroll({state,dragStartTime:0,shouldUseTimeDampening:!1,scrollWindow:fakeScrollCallback,scrollDroppable:fakeScrollCallback,getAutoScrollerOptions}),dragging={dragStartTime,shouldUseTimeDampening:wasScrollNeeded},finish(),wasScrollNeeded&&tryScroll(state)},stop:()=>{dragging&&(scheduleWindowScroll.cancel(),scheduleDroppableScroll.cancel(),dragging=null)},scroll:tryScroll}})({scrollWindow,scrollDroppable,getAutoScrollerOptions}),jumpScroll=createJumpScroller({move,scrollWindow,scrollDroppable});return{scroll:state=>{getAutoScrollerOptions().disabled||"DRAGGING"!==state.phase||("FLUID"!==state.movementMode?state.scrollJumpRequest&&jumpScroll(state):fluidScroller.scroll(state))},start:fluidScroller.start,stop:fluidScroller.stop}};const prefix="data-rfd",dragHandle=(()=>{const base=`${prefix}-drag-handle`;return{base,draggableId:`${base}-draggable-id`,contextId:`${base}-context-id`}})(),draggable=(()=>{const base=`${prefix}-draggable`;return{base,contextId:`${base}-context-id`,id:`${base}-id`}})(),droppable=(()=>{const base=`${prefix}-droppable`;return{base,contextId:`${base}-context-id`,id:`${base}-id`}})(),scrollContainer={contextId:`${prefix}-scroll-container-context-id`},getStyles=(rules,property)=>rules.map((rule=>{const value=rule.styles[property];return value?`${rule.selector} { ${value} }`:""})).join(" ");var getStyles$1=contextId=>{const getSelector=(context=contextId,attribute=>`[${attribute}="${context}"]`);var context;const dragHandle$1=(()=>{const grabCursor="\n      cursor: -webkit-grab;\n      cursor: grab;\n    ";return{selector:getSelector(dragHandle.contextId),styles:{always:"\n          -webkit-touch-callout: none;\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n          touch-action: manipulation;\n        ",resting:grabCursor,dragging:"pointer-events: none;",dropAnimating:grabCursor}}})(),rules=[(()=>{const transition=`\n      transition: ${transitions.outOfTheWay};\n    `;return{selector:getSelector(draggable.contextId),styles:{dragging:transition,dropAnimating:transition,userCancel:transition}}})(),dragHandle$1,{selector:getSelector(droppable.contextId),styles:{always:"overflow-anchor: none;"}},{selector:"body",styles:{dragging:"\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        overflow-anchor: none;\n      "}}];return{always:getStyles(rules,"always"),resting:getStyles(rules,"resting"),dragging:getStyles(rules,"dragging"),dropAnimating:getStyles(rules,"dropAnimating"),userCancel:getStyles(rules,"userCancel")}};var useLayoutEffect="undefined"!=typeof window&&void 0!==window.document&&void 0!==window.document.createElement?react.useLayoutEffect:react.useEffect;const getHead=()=>{const head=document.querySelector("head");return head||invariant(!1),head},createStyleEl=nonce=>{const el=document.createElement("style");return nonce&&el.setAttribute("nonce",nonce),el.type="text/css",el};function querySelectorAll(parentNode,selector){return Array.from(parentNode.querySelectorAll(selector))}var getWindowFromEl=el=>el&&el.ownerDocument&&el.ownerDocument.defaultView?el.ownerDocument.defaultView:window;function isHtmlElement(el){return el instanceof getWindowFromEl(el).HTMLElement}function findDragHandle(contextId,draggableId){const selector=`[${dragHandle.contextId}="${contextId}"]`,possible=querySelectorAll(document,selector);if(!possible.length)return null;const handle=possible.find((el=>el.getAttribute(dragHandle.draggableId)===draggableId));return handle&&isHtmlElement(handle)?handle:null}function createRegistry(){const entries={draggables:{},droppables:{}},subscribers=[];function notify(event){subscribers.length&&subscribers.forEach((cb=>cb(event)))}function findDraggableById(id){return entries.draggables[id]||null}function findDroppableById(id){return entries.droppables[id]||null}return{draggable:{register:entry=>{entries.draggables[entry.descriptor.id]=entry,notify({type:"ADDITION",value:entry})},update:(entry,last)=>{const current=entries.draggables[last.descriptor.id];current&&current.uniqueId===entry.uniqueId&&(delete entries.draggables[last.descriptor.id],entries.draggables[entry.descriptor.id]=entry)},unregister:entry=>{const draggableId=entry.descriptor.id,current=findDraggableById(draggableId);current&&entry.uniqueId===current.uniqueId&&(delete entries.draggables[draggableId],entries.droppables[entry.descriptor.droppableId]&&notify({type:"REMOVAL",value:entry}))},getById:function getDraggableById(id){const entry=findDraggableById(id);return entry||invariant(!1),entry},findById:findDraggableById,exists:id=>Boolean(findDraggableById(id)),getAllByType:type=>Object.values(entries.draggables).filter((entry=>entry.descriptor.type===type))},droppable:{register:entry=>{entries.droppables[entry.descriptor.id]=entry},unregister:entry=>{const current=findDroppableById(entry.descriptor.id);current&&entry.uniqueId===current.uniqueId&&delete entries.droppables[entry.descriptor.id]},getById:function getDroppableById(id){const entry=findDroppableById(id);return entry||invariant(!1),entry},findById:findDroppableById,exists:id=>Boolean(findDroppableById(id)),getAllByType:type=>Object.values(entries.droppables).filter((entry=>entry.descriptor.type===type))},subscribe:function subscribe(cb){return subscribers.push(cb),function unsubscribe(){const index=subscribers.indexOf(cb);-1!==index&&subscribers.splice(index,1)}},clean:function clean(){entries.draggables={},entries.droppables={},subscribers.length=0}}}var StoreContext=react.createContext(null),getBodyElement=()=>{const body=document.body;return body||invariant(!1),body};var visuallyHidden$1={position:"absolute",width:"1px",height:"1px",margin:"-1px",border:"0",padding:"0",overflow:"hidden",clip:"rect(0 0 0 0)","clip-path":"inset(100%)"};const getId=contextId=>`rfd-announcement-${contextId}`;const defaults={separator:"::"};var useUniqueId$1=function useUniqueId(prefix,options=defaults){const id=react.useId();return useMemo((()=>`${prefix}${options.separator}${id}`),[options.separator,prefix,id])};var AppContext=react.createContext(null);function useDev(useHook){0}function useDevSetupWarning(fn,inputs){useDev()}function usePrevious(current){const ref=(0,react.useRef)(current);return(0,react.useEffect)((()=>{ref.current=current})),ref}function isDragging(state){return"IDLE"!==state.phase&&"DROP_ANIMATING"!==state.phase&&state.isDragging}const tab=9,enter=13,pageUp=33,pageDown=34,end=35,home=36,preventedKeys={[enter]:!0,[tab]:!0};var preventStandardKeyEvents=event=>{preventedKeys[event.keyCode]&&event.preventDefault()};var supportedPageVisibilityEventName=(()=>{const base="visibilitychange";if("undefined"==typeof document)return base;return[base,`ms${base}`,`webkit${base}`,`moz${base}`,`o${base}`].find((eventName=>`on${eventName}`in document))||base})();const idle$1={type:"IDLE"};function getCaptureBindings({cancel,completed,getPhase,setPhase}){return[{eventName:"mousemove",fn:event=>{const{button,clientX,clientY}=event;if(0!==button)return;const point={x:clientX,y:clientY},phase=getPhase();if("DRAGGING"===phase.type)return event.preventDefault(),void phase.actions.move(point);"PENDING"!==phase.type&&invariant(!1);if(!function isSloppyClickThresholdExceeded(original,current){return Math.abs(current.x-original.x)>=5||Math.abs(current.y-original.y)>=5}(phase.point,point))return;event.preventDefault();const actions=phase.actions.fluidLift(point);setPhase({type:"DRAGGING",actions})}},{eventName:"mouseup",fn:event=>{const phase=getPhase();"DRAGGING"===phase.type?(event.preventDefault(),phase.actions.drop({shouldBlockNextClick:!0}),completed()):cancel()}},{eventName:"mousedown",fn:event=>{"DRAGGING"===getPhase().type&&event.preventDefault(),cancel()}},{eventName:"keydown",fn:event=>{if("PENDING"!==getPhase().type)return 27===event.keyCode?(event.preventDefault(),void cancel()):void preventStandardKeyEvents(event);cancel()}},{eventName:"resize",fn:cancel},{eventName:"scroll",options:{passive:!0,capture:!1},fn:()=>{"PENDING"===getPhase().type&&cancel()}},{eventName:"webkitmouseforcedown",fn:event=>{const phase=getPhase();"IDLE"===phase.type&&invariant(!1),phase.actions.shouldRespectForcePress()?cancel():event.preventDefault()}},{eventName:supportedPageVisibilityEventName,fn:cancel}]}function noop$1(){}const scrollJumpKeys={[pageDown]:!0,[pageUp]:!0,[home]:!0,[end]:!0};function getDraggingBindings(actions,stop){function cancel(){stop(),actions.cancel()}return[{eventName:"keydown",fn:event=>27===event.keyCode?(event.preventDefault(),void cancel()):32===event.keyCode?(event.preventDefault(),void function drop(){stop(),actions.drop()}()):40===event.keyCode?(event.preventDefault(),void actions.moveDown()):38===event.keyCode?(event.preventDefault(),void actions.moveUp()):39===event.keyCode?(event.preventDefault(),void actions.moveRight()):37===event.keyCode?(event.preventDefault(),void actions.moveLeft()):void(scrollJumpKeys[event.keyCode]?event.preventDefault():preventStandardKeyEvents(event))},{eventName:"mousedown",fn:cancel},{eventName:"mouseup",fn:cancel},{eventName:"click",fn:cancel},{eventName:"touchstart",fn:cancel},{eventName:"resize",fn:cancel},{eventName:"wheel",fn:cancel,options:{passive:!0}},{eventName:supportedPageVisibilityEventName,fn:cancel}]}const idle={type:"IDLE"};const interactiveTagNames=["input","button","textarea","select","option","optgroup","video","audio"];function isAnInteractiveElement(parent,current){if(null==current)return!1;if(interactiveTagNames.includes(current.tagName.toLowerCase()))return!0;const attribute=current.getAttribute("contenteditable");return"true"===attribute||""===attribute||current!==parent&&isAnInteractiveElement(parent,current.parentElement)}function isEventInInteractiveElement(draggable,event){const target=event.target;return!!isHtmlElement(target)&&isAnInteractiveElement(draggable,target)}var getBorderBoxCenterPosition=el=>getRect(el.getBoundingClientRect()).center;const supportedMatchesName=(()=>{if("undefined"==typeof document)return"matches";return["matches","msMatchesSelector","webkitMatchesSelector"].find((name=>name in Element.prototype))||"matches"})();function closestPonyfill(el,selector){return null==el?null:el[supportedMatchesName](selector)?el:closestPonyfill(el.parentElement,selector)}function closest(el,selector){return el.closest?el.closest(selector):closestPonyfill(el,selector)}function findClosestDragHandleFromEvent(contextId,event){const target=event.target;if(!function isElement(el){return el instanceof getWindowFromEl(el).Element}(target))return null;const selector=function getSelector(contextId){return`[${dragHandle.contextId}="${contextId}"]`}(contextId),handle=closest(target,selector);return handle&&isHtmlElement(handle)?handle:null}function preventDefault(event){event.preventDefault()}function isActive({expected,phase,isLockActive,shouldWarn}){return!!isLockActive()&&expected===phase}function canStart({lockAPI,store,registry,draggableId}){if(lockAPI.isClaimed())return!1;const entry=registry.draggable.findById(draggableId);return!!entry&&(!!entry.options.isEnabled&&!!canStartDrag(store.getState(),draggableId))}function tryStart({lockAPI,contextId,store,registry,draggableId,forceSensorStop,sourceEvent}){if(!canStart({lockAPI,store,registry,draggableId}))return null;const entry=registry.draggable.getById(draggableId),el=function findDraggable(contextId,draggableId){const selector=`[${draggable.contextId}="${contextId}"]`,draggable$1=querySelectorAll(document,selector).find((el=>el.getAttribute(draggable.id)===draggableId));return draggable$1&&isHtmlElement(draggable$1)?draggable$1:null}(contextId,entry.descriptor.id);if(!el)return null;if(sourceEvent&&!entry.options.canDragInteractiveElements&&isEventInInteractiveElement(el,sourceEvent))return null;const lock=lockAPI.claim(forceSensorStop||noop$2);let phase="PRE_DRAG";function getShouldRespectForcePress(){return entry.options.shouldRespectForcePress}function isLockActive(){return lockAPI.isActive(lock)}const tryDispatchWhenDragging=function tryDispatch(expected,getAction){isActive({expected,phase,isLockActive,shouldWarn:!0})&&store.dispatch(getAction())}.bind(null,"DRAGGING");function lift(args){function completed(){lockAPI.release(),phase="COMPLETED"}function finish(reason,options={shouldBlockNextClick:!1}){if(args.cleanup(),options.shouldBlockNextClick){const unbind=bindEvents(window,[{eventName:"click",fn:preventDefault,options:{once:!0,passive:!1,capture:!0}}]);setTimeout(unbind)}completed(),store.dispatch(drop$1({reason}))}return"PRE_DRAG"!==phase&&(completed(),invariant(!1)),store.dispatch(lift$1(args.liftActionArgs)),phase="DRAGGING",{isActive:()=>isActive({expected:"DRAGGING",phase,isLockActive,shouldWarn:!1}),shouldRespectForcePress:getShouldRespectForcePress,drop:options=>finish("DROP",options),cancel:options=>finish("CANCEL",options),...args.actions}}return{isActive:()=>isActive({expected:"PRE_DRAG",phase,isLockActive,shouldWarn:!1}),shouldRespectForcePress:getShouldRespectForcePress,fluidLift:function fluidLift(clientSelection){const move$1=raf_schd_esm((client=>{tryDispatchWhenDragging((()=>move({client})))}));return{...lift({liftActionArgs:{id:draggableId,clientSelection,movementMode:"FLUID"},cleanup:()=>move$1.cancel(),actions:{move:move$1}}),move:move$1}},snapLift:function snapLift(){const actions={moveUp:()=>tryDispatchWhenDragging(moveUp),moveRight:()=>tryDispatchWhenDragging(moveRight),moveDown:()=>tryDispatchWhenDragging(moveDown),moveLeft:()=>tryDispatchWhenDragging(moveLeft)};return lift({liftActionArgs:{id:draggableId,clientSelection:getBorderBoxCenterPosition(el),movementMode:"SNAP"},cleanup:noop$2,actions})},abort:function abortPreDrag(){isActive({expected:"PRE_DRAG",phase,isLockActive,shouldWarn:!0})&&lockAPI.release()}}}const defaultSensors=[function useMouseSensor(api){const phaseRef=(0,react.useRef)(idle$1),unbindEventsRef=(0,react.useRef)(noop$2),startCaptureBinding=useMemo((()=>({eventName:"mousedown",fn:function onMouseDown(event){if(event.defaultPrevented)return;if(0!==event.button)return;if(event.ctrlKey||event.metaKey||event.shiftKey||event.altKey)return;const draggableId=api.findClosestDraggableId(event);if(!draggableId)return;const actions=api.tryGetLock(draggableId,stop,{sourceEvent:event});if(!actions)return;event.preventDefault();const point={x:event.clientX,y:event.clientY};unbindEventsRef.current(),startPendingDrag(actions,point)}})),[api]),preventForcePressBinding=useMemo((()=>({eventName:"webkitmouseforcewillbegin",fn:event=>{if(event.defaultPrevented)return;const id=api.findClosestDraggableId(event);if(!id)return;const options=api.findOptionsForDraggable(id);options&&(options.shouldRespectForcePress||api.canGetLock(id)&&event.preventDefault())}})),[api]),listenForCapture=useCallback((function listenForCapture(){unbindEventsRef.current=bindEvents(window,[preventForcePressBinding,startCaptureBinding],{passive:!1,capture:!0})}),[preventForcePressBinding,startCaptureBinding]),stop=useCallback((()=>{"IDLE"!==phaseRef.current.type&&(phaseRef.current=idle$1,unbindEventsRef.current(),listenForCapture())}),[listenForCapture]),cancel=useCallback((()=>{const phase=phaseRef.current;stop(),"DRAGGING"===phase.type&&phase.actions.cancel({shouldBlockNextClick:!0}),"PENDING"===phase.type&&phase.actions.abort()}),[stop]),bindCapturingEvents=useCallback((function bindCapturingEvents(){const bindings=getCaptureBindings({cancel,completed:stop,getPhase:()=>phaseRef.current,setPhase:phase=>{phaseRef.current=phase}});unbindEventsRef.current=bindEvents(window,bindings,{capture:!0,passive:!1})}),[cancel,stop]),startPendingDrag=useCallback((function startPendingDrag(actions,point){"IDLE"!==phaseRef.current.type&&invariant(!1),phaseRef.current={type:"PENDING",point,actions},bindCapturingEvents()}),[bindCapturingEvents]);useLayoutEffect((function mount(){return listenForCapture(),function unmount(){unbindEventsRef.current()}}),[listenForCapture])},function useKeyboardSensor(api){const unbindEventsRef=(0,react.useRef)(noop$1),startCaptureBinding=useMemo((()=>({eventName:"keydown",fn:function onKeyDown(event){if(event.defaultPrevented)return;if(32!==event.keyCode)return;const draggableId=api.findClosestDraggableId(event);if(!draggableId)return;const preDrag=api.tryGetLock(draggableId,stop,{sourceEvent:event});if(!preDrag)return;event.preventDefault();let isCapturing=!0;const actions=preDrag.snapLift();function stop(){isCapturing||invariant(!1),isCapturing=!1,unbindEventsRef.current(),listenForCapture()}unbindEventsRef.current(),unbindEventsRef.current=bindEvents(window,getDraggingBindings(actions,stop),{capture:!0,passive:!1})}})),[api]),listenForCapture=useCallback((function tryStartCapture(){unbindEventsRef.current=bindEvents(window,[startCaptureBinding],{passive:!1,capture:!0})}),[startCaptureBinding]);useLayoutEffect((function mount(){return listenForCapture(),function unmount(){unbindEventsRef.current()}}),[listenForCapture])},function useTouchSensor(api){const phaseRef=(0,react.useRef)(idle),unbindEventsRef=(0,react.useRef)(noop$2),getPhase=useCallback((function getPhase(){return phaseRef.current}),[]),setPhase=useCallback((function setPhase(phase){phaseRef.current=phase}),[]),startCaptureBinding=useMemo((()=>({eventName:"touchstart",fn:function onTouchStart(event){if(event.defaultPrevented)return;const draggableId=api.findClosestDraggableId(event);if(!draggableId)return;const actions=api.tryGetLock(draggableId,stop,{sourceEvent:event});if(!actions)return;const touch=event.touches[0],{clientX,clientY}=touch,point={x:clientX,y:clientY};unbindEventsRef.current(),startPendingDrag(actions,point)}})),[api]),listenForCapture=useCallback((function listenForCapture(){unbindEventsRef.current=bindEvents(window,[startCaptureBinding],{capture:!0,passive:!1})}),[startCaptureBinding]),stop=useCallback((()=>{const current=phaseRef.current;"IDLE"!==current.type&&("PENDING"===current.type&&clearTimeout(current.longPressTimerId),setPhase(idle),unbindEventsRef.current(),listenForCapture())}),[listenForCapture,setPhase]),cancel=useCallback((()=>{const phase=phaseRef.current;stop(),"DRAGGING"===phase.type&&phase.actions.cancel({shouldBlockNextClick:!0}),"PENDING"===phase.type&&phase.actions.abort()}),[stop]),bindCapturingEvents=useCallback((function bindCapturingEvents(){const options={capture:!0,passive:!1},args={cancel,completed:stop,getPhase},unbindTarget=bindEvents(window,function getHandleBindings({cancel,completed,getPhase}){return[{eventName:"touchmove",options:{capture:!1},fn:event=>{const phase=getPhase();if("DRAGGING"!==phase.type)return void cancel();phase.hasMoved=!0;const{clientX,clientY}=event.touches[0],point={x:clientX,y:clientY};event.preventDefault(),phase.actions.move(point)}},{eventName:"touchend",fn:event=>{const phase=getPhase();"DRAGGING"===phase.type?(event.preventDefault(),phase.actions.drop({shouldBlockNextClick:!0}),completed()):cancel()}},{eventName:"touchcancel",fn:event=>{"DRAGGING"===getPhase().type?(event.preventDefault(),cancel()):cancel()}},{eventName:"touchforcechange",fn:event=>{const phase=getPhase();"IDLE"===phase.type&&invariant(!1);const touch=event.touches[0];if(!touch)return;if(!(touch.force>=.15))return;const shouldRespect=phase.actions.shouldRespectForcePress();if("PENDING"!==phase.type)return shouldRespect?phase.hasMoved?void event.preventDefault():void cancel():void event.preventDefault();shouldRespect&&cancel()}},{eventName:supportedPageVisibilityEventName,fn:cancel}]}(args),options),unbindWindow=bindEvents(window,function getWindowBindings({cancel,getPhase}){return[{eventName:"orientationchange",fn:cancel},{eventName:"resize",fn:cancel},{eventName:"contextmenu",fn:event=>{event.preventDefault()}},{eventName:"keydown",fn:event=>{"DRAGGING"===getPhase().type?(27===event.keyCode&&event.preventDefault(),cancel()):cancel()}},{eventName:supportedPageVisibilityEventName,fn:cancel}]}(args),options);unbindEventsRef.current=function unbindAll(){unbindTarget(),unbindWindow()}}),[cancel,getPhase,stop]),startDragging=useCallback((function startDragging(){const phase=getPhase();"PENDING"!==phase.type&&invariant(!1);const actions=phase.actions.fluidLift(phase.point);setPhase({type:"DRAGGING",actions,hasMoved:!1})}),[getPhase,setPhase]),startPendingDrag=useCallback((function startPendingDrag(actions,point){"IDLE"!==getPhase().type&&invariant(!1);const longPressTimerId=setTimeout(startDragging,120);setPhase({type:"PENDING",point,actions,longPressTimerId}),bindCapturingEvents()}),[bindCapturingEvents,getPhase,setPhase,startDragging]);useLayoutEffect((function mount(){return listenForCapture(),function unmount(){unbindEventsRef.current();const phase=getPhase();"PENDING"===phase.type&&(clearTimeout(phase.longPressTimerId),setPhase(idle))}}),[getPhase,listenForCapture,setPhase]),useLayoutEffect((function webkitHack(){return bindEvents(window,[{eventName:"touchmove",fn:()=>{},options:{capture:!1,passive:!1}}])}),[])}];function useSensorMarshal({contextId,store,registry,customSensors,enableDefaultSensors}){const useSensors=[...enableDefaultSensors?defaultSensors:[],...customSensors||[]],lockAPI=(0,react.useState)((()=>function create(){let lock=null;function release(){lock||invariant(!1),lock=null}return{isClaimed:function isClaimed(){return Boolean(lock)},isActive:function isActive(value){return value===lock},claim:function claim(abandon){lock&&invariant(!1);const newLock={abandon};return lock=newLock,newLock},release,tryAbandon:function tryAbandon(){lock&&(lock.abandon(),release())}}}()))[0],tryAbandonLock=useCallback((function tryAbandonLock(previous,current){isDragging(previous)&&!isDragging(current)&&lockAPI.tryAbandon()}),[lockAPI]);useLayoutEffect((function listenToStore(){let previous=store.getState();return store.subscribe((()=>{const current=store.getState();tryAbandonLock(previous,current),previous=current}))}),[lockAPI,store,tryAbandonLock]),useLayoutEffect((()=>lockAPI.tryAbandon),[lockAPI.tryAbandon]);const canGetLock=useCallback((draggableId=>canStart({lockAPI,registry,store,draggableId})),[lockAPI,registry,store]),tryGetLock=useCallback(((draggableId,forceStop,options)=>tryStart({lockAPI,registry,contextId,store,draggableId,forceSensorStop:forceStop||null,sourceEvent:options&&options.sourceEvent?options.sourceEvent:null})),[contextId,lockAPI,registry,store]),findClosestDraggableId=useCallback((event=>function tryGetClosestDraggableIdFromEvent(contextId,event){const handle=findClosestDragHandleFromEvent(contextId,event);return handle?handle.getAttribute(dragHandle.draggableId):null}(contextId,event)),[contextId]),findOptionsForDraggable=useCallback((id=>{const entry=registry.draggable.findById(id);return entry?entry.options:null}),[registry.draggable]),tryReleaseLock=useCallback((function tryReleaseLock(){lockAPI.isClaimed()&&(lockAPI.tryAbandon(),"IDLE"!==store.getState().phase&&store.dispatch(flush()))}),[lockAPI,store]),isLockClaimed=useCallback((()=>lockAPI.isClaimed()),[lockAPI]),api=useMemo((()=>({canGetLock,tryGetLock,findClosestDraggableId,findOptionsForDraggable,tryReleaseLock,isLockClaimed})),[canGetLock,tryGetLock,findClosestDraggableId,findOptionsForDraggable,tryReleaseLock,isLockClaimed]);!function useValidateSensorHooks(sensorHooks){useDev()}();for(let i=0;i<useSensors.length;i++)useSensors[i](api)}const createResponders=props=>({onBeforeCapture:t=>{const onBeforeCapureCallback=()=>{props.onBeforeCapture&&props.onBeforeCapture(t)};react.version.startsWith("16")||react.version.startsWith("17")?onBeforeCapureCallback():(0,react_dom.flushSync)(onBeforeCapureCallback)},onBeforeDragStart:props.onBeforeDragStart,onDragStart:props.onDragStart,onDragEnd:props.onDragEnd,onDragUpdate:props.onDragUpdate}),createAutoScrollerOptions=props=>({...defaultAutoScrollerOptions,...props.autoScrollerOptions,durationDampening:{...defaultAutoScrollerOptions.durationDampening,...props.autoScrollerOptions}});function getStore(lazyRef){return lazyRef.current||invariant(!1),lazyRef.current}function App(props){const{contextId,setCallbacks,sensors,nonce,dragHandleUsageInstructions}=props,lazyStoreRef=(0,react.useRef)(null);!function useStartupValidation(){useDevSetupWarning()}();const lastPropsRef=usePrevious(props),getResponders=useCallback((()=>createResponders(lastPropsRef.current)),[lastPropsRef]),getAutoScrollerOptions=useCallback((()=>createAutoScrollerOptions(lastPropsRef.current)),[lastPropsRef]),announce=function useAnnouncer(contextId){const id=useMemo((()=>getId(contextId)),[contextId]),ref=(0,react.useRef)(null);return(0,react.useEffect)((function setup(){const el=document.createElement("div");return ref.current=el,el.id=id,el.setAttribute("aria-live","assertive"),el.setAttribute("aria-atomic","true"),(0,esm_extends.A)(el.style,visuallyHidden$1),getBodyElement().appendChild(el),function cleanup(){setTimeout((function remove(){const body=getBodyElement();body.contains(el)&&body.removeChild(el),el===ref.current&&(ref.current=null)}))}}),[id]),useCallback((message=>{const el=ref.current;el&&(el.textContent=message)}),[])}(contextId),dragHandleUsageInstructionsId=function useHiddenTextElement({contextId,text}){const uniqueId=useUniqueId$1("hidden-text",{separator:"-"}),id=useMemo((()=>function getElementId({contextId,uniqueId}){return`rfd-hidden-text-${contextId}-${uniqueId}`}({contextId,uniqueId})),[uniqueId,contextId]);return(0,react.useEffect)((function mount(){const el=document.createElement("div");return el.id=id,el.textContent=text,el.style.display="none",getBodyElement().appendChild(el),function unmount(){const body=getBodyElement();body.contains(el)&&body.removeChild(el)}}),[id,text]),id}({contextId,text:dragHandleUsageInstructions}),styleMarshal=function useStyleMarshal(contextId,nonce){const styles=useMemo((()=>getStyles$1(contextId)),[contextId]),alwaysRef=(0,react.useRef)(null),dynamicRef=(0,react.useRef)(null),setDynamicStyle=useCallback((0,memoize_one_esm.A)((proposed=>{const el=dynamicRef.current;el||invariant(!1),el.textContent=proposed})),[]),setAlwaysStyle=useCallback((proposed=>{const el=alwaysRef.current;el||invariant(!1),el.textContent=proposed}),[]);useLayoutEffect((()=>{(alwaysRef.current||dynamicRef.current)&&invariant(!1);const always=createStyleEl(nonce),dynamic=createStyleEl(nonce);return alwaysRef.current=always,dynamicRef.current=dynamic,always.setAttribute(`${prefix}-always`,contextId),dynamic.setAttribute(`${prefix}-dynamic`,contextId),getHead().appendChild(always),getHead().appendChild(dynamic),setAlwaysStyle(styles.always),setDynamicStyle(styles.resting),()=>{const remove=ref=>{const current=ref.current;current||invariant(!1),getHead().removeChild(current),ref.current=null};remove(alwaysRef),remove(dynamicRef)}}),[nonce,setAlwaysStyle,setDynamicStyle,styles.always,styles.resting,contextId]);const dragging=useCallback((()=>setDynamicStyle(styles.dragging)),[setDynamicStyle,styles.dragging]),dropping=useCallback((reason=>{setDynamicStyle("DROP"!==reason?styles.userCancel:styles.dropAnimating)}),[setDynamicStyle,styles.dropAnimating,styles.userCancel]),resting=useCallback((()=>{dynamicRef.current&&setDynamicStyle(styles.resting)}),[setDynamicStyle,styles.resting]);return useMemo((()=>({dragging,dropping,resting})),[dragging,dropping,resting])}(contextId,nonce),lazyDispatch=useCallback((action=>{getStore(lazyStoreRef).dispatch(action)}),[]),marshalCallbacks=useMemo((()=>(0,redux.zH)({publishWhileDragging,updateDroppableScroll,updateDroppableIsEnabled,updateDroppableIsCombineEnabled,collectionStarting},lazyDispatch)),[lazyDispatch]),registry=function useRegistry(){const registry=useMemo(createRegistry,[]);return(0,react.useEffect)((()=>function unmount(){react.version.startsWith("16")||react.version.startsWith("17")?requestAnimationFrame(registry.clean):registry.clean()}),[registry]),registry}(),dimensionMarshal=useMemo((()=>createDimensionMarshal(registry,marshalCallbacks)),[registry,marshalCallbacks]),autoScroller=useMemo((()=>createAutoScroller({scrollWindow,scrollDroppable:dimensionMarshal.scrollDroppable,getAutoScrollerOptions,...(0,redux.zH)({move},lazyDispatch)})),[dimensionMarshal.scrollDroppable,lazyDispatch,getAutoScrollerOptions]),focusMarshal=function useFocusMarshal(contextId){const entriesRef=(0,react.useRef)({}),recordRef=(0,react.useRef)(null),restoreFocusFrameRef=(0,react.useRef)(null),isMountedRef=(0,react.useRef)(!1),register=useCallback((function register(id,focus){const entry={id,focus};return entriesRef.current[id]=entry,function unregister(){const entries=entriesRef.current;entries[id]!==entry&&delete entries[id]}}),[]),tryGiveFocus=useCallback((function tryGiveFocus(tryGiveFocusTo){const handle=findDragHandle(contextId,tryGiveFocusTo);handle&&handle!==document.activeElement&&handle.focus()}),[contextId]),tryShiftRecord=useCallback((function tryShiftRecord(previous,redirectTo){recordRef.current===previous&&(recordRef.current=redirectTo)}),[]),tryRestoreFocusRecorded=useCallback((function tryRestoreFocusRecorded(){restoreFocusFrameRef.current||isMountedRef.current&&(restoreFocusFrameRef.current=requestAnimationFrame((()=>{restoreFocusFrameRef.current=null;const record=recordRef.current;record&&tryGiveFocus(record)})))}),[tryGiveFocus]),tryRecordFocus=useCallback((function tryRecordFocus(id){recordRef.current=null;const focused=document.activeElement;focused&&focused.getAttribute(dragHandle.draggableId)===id&&(recordRef.current=id)}),[]);return useLayoutEffect((()=>(isMountedRef.current=!0,function clearFrameOnUnmount(){isMountedRef.current=!1;const frameId=restoreFocusFrameRef.current;frameId&&cancelAnimationFrame(frameId)})),[]),useMemo((()=>({register,tryRecordFocus,tryRestoreFocusRecorded,tryShiftRecord})),[register,tryRecordFocus,tryRestoreFocusRecorded,tryShiftRecord])}(contextId),store=useMemo((()=>createStore({announce,autoScroller,dimensionMarshal,focusMarshal,getResponders,styleMarshal})),[announce,autoScroller,dimensionMarshal,focusMarshal,getResponders,styleMarshal]);lazyStoreRef.current=store;const tryResetStore=useCallback((()=>{const current=getStore(lazyStoreRef);"IDLE"!==current.getState().phase&&current.dispatch(flush())}),[]),isDragging=useCallback((()=>{const state=getStore(lazyStoreRef).getState();return"DROP_ANIMATING"===state.phase||"IDLE"!==state.phase&&state.isDragging}),[]);setCallbacks(useMemo((()=>({isDragging,tryAbort:tryResetStore})),[isDragging,tryResetStore]));const getCanLift=useCallback((id=>canStartDrag(getStore(lazyStoreRef).getState(),id)),[]),getIsMovementAllowed=useCallback((()=>isMovementAllowed(getStore(lazyStoreRef).getState())),[]),appContext=useMemo((()=>({marshal:dimensionMarshal,focus:focusMarshal,contextId,canLift:getCanLift,isMovementAllowed:getIsMovementAllowed,dragHandleUsageInstructionsId,registry})),[contextId,dimensionMarshal,dragHandleUsageInstructionsId,focusMarshal,getCanLift,getIsMovementAllowed,registry]);return useSensorMarshal({contextId,store,registry,customSensors:sensors||null,enableDefaultSensors:!1!==props.enableDefaultSensors}),(0,react.useEffect)((()=>tryResetStore),[tryResetStore]),react.createElement(AppContext.Provider,{value:appContext},react.createElement(es.Kq,{context:StoreContext,store},props.children))}var useUniqueContextId$1=function useUniqueContextId(){return react.useId()};function DragDropContext(props){const contextId=useUniqueContextId$1(),dragHandleUsageInstructions=props.dragHandleUsageInstructions||preset$1.dragHandleUsageInstructions;return react.createElement(ErrorBoundary,null,(setCallbacks=>react.createElement(App,{nonce:props.nonce,contextId,setCallbacks,dragHandleUsageInstructions,enableDefaultSensors:props.enableDefaultSensors,sensors:props.sensors,onBeforeCapture:props.onBeforeCapture,onBeforeDragStart:props.onBeforeDragStart,onDragStart:props.onDragStart,onDragUpdate:props.onDragUpdate,onDragEnd:props.onDragEnd,autoScrollerOptions:props.autoScrollerOptions},props.children)))}const zIndexOptions_dragging=5e3,zIndexOptions_dropAnimating=4500,getDraggingTransition=(shouldAnimateDragMovement,dropping)=>dropping?transitions.drop(dropping.duration):shouldAnimateDragMovement?transitions.snap:transitions.fluid,getDraggingOpacity=(isCombining,isDropAnimating)=>{if(isCombining)return isDropAnimating?combine_opacity.drop:combine_opacity.combining};function getStyle$1(mapped){return"DRAGGING"===mapped.type?function getDraggingStyle(dragging){const box=dragging.dimension.client,{offset,combineWith,dropping}=dragging,isCombining=Boolean(combineWith),shouldAnimate=(dragging=>null!=dragging.forceShouldAnimate?dragging.forceShouldAnimate:"SNAP"===dragging.mode)(dragging),isDropAnimating=Boolean(dropping),transform=isDropAnimating?transforms_drop(offset,isCombining):transforms_moveTo(offset);return{position:"fixed",top:box.marginBox.top,left:box.marginBox.left,boxSizing:"border-box",width:box.borderBox.width,height:box.borderBox.height,transition:getDraggingTransition(shouldAnimate,dropping),transform,opacity:getDraggingOpacity(isCombining,isDropAnimating),zIndex:isDropAnimating?zIndexOptions_dropAnimating:zIndexOptions_dragging,pointerEvents:"none"}}(mapped):function getSecondaryStyle(secondary){return{transform:transforms_moveTo(secondary.offset),transition:secondary.shouldAnimateDisplacement?void 0:"none"}}(mapped)}function useDraggablePublisher(args){const uniqueId=useUniqueId$1("draggable"),{descriptor,registry,getDraggableRef,canDragInteractiveElements,shouldRespectForcePress,isEnabled}=args,options=useMemo((()=>({canDragInteractiveElements,shouldRespectForcePress,isEnabled})),[canDragInteractiveElements,isEnabled,shouldRespectForcePress]),getDimension=useCallback((windowScroll=>{const el=getDraggableRef();return el||invariant(!1),function getDimension$1(descriptor,el,windowScroll=origin){const computedStyles=window.getComputedStyle(el),borderBox=el.getBoundingClientRect(),client=calculateBox(borderBox,computedStyles),page=withScroll(client,windowScroll);return{descriptor,placeholder:{client,tagName:el.tagName.toLowerCase(),display:computedStyles.display},displaceBy:{x:client.marginBox.width,y:client.marginBox.height},client,page}}(descriptor,el,windowScroll)}),[descriptor,getDraggableRef]),entry=useMemo((()=>({uniqueId,descriptor,options,getDimension})),[descriptor,getDimension,options,uniqueId]),publishedRef=(0,react.useRef)(entry),isFirstPublishRef=(0,react.useRef)(!0);useLayoutEffect((()=>(registry.draggable.register(publishedRef.current),()=>registry.draggable.unregister(publishedRef.current))),[registry.draggable]),useLayoutEffect((()=>{if(isFirstPublishRef.current)return void(isFirstPublishRef.current=!1);const last=publishedRef.current;publishedRef.current=entry,registry.draggable.update(entry,last)}),[entry,registry.draggable])}var DroppableContext=react.createContext(null);function useRequiredContext(Context){const result=(0,react.useContext)(Context);return result||invariant(!1),result}function preventHtml5Dnd(event){event.preventDefault()}var Draggable$1=props=>{const ref=(0,react.useRef)(null),setRef=useCallback(((el=null)=>{ref.current=el}),[]),getRef=useCallback((()=>ref.current),[]),{contextId,dragHandleUsageInstructionsId,registry}=useRequiredContext(AppContext),{type,droppableId}=useRequiredContext(DroppableContext),descriptor=useMemo((()=>({id:props.draggableId,index:props.index,type,droppableId})),[props.draggableId,props.index,type,droppableId]),{children,draggableId,isEnabled,shouldRespectForcePress,canDragInteractiveElements,isClone,mapped,dropAnimationFinished:dropAnimationFinishedAction}=props;if(function useValidation$1(props,contextId,getRef){useDevSetupWarning()}(),function useClonePropValidation(isClone){useDev()}(),!isClone){useDraggablePublisher(useMemo((()=>({descriptor,registry,getDraggableRef:getRef,canDragInteractiveElements,shouldRespectForcePress,isEnabled})),[descriptor,registry,getRef,canDragInteractiveElements,shouldRespectForcePress,isEnabled]))}const dragHandleProps=useMemo((()=>isEnabled?{tabIndex:0,role:"button","aria-describedby":dragHandleUsageInstructionsId,"data-rfd-drag-handle-draggable-id":draggableId,"data-rfd-drag-handle-context-id":contextId,draggable:!1,onDragStart:preventHtml5Dnd}:null),[contextId,dragHandleUsageInstructionsId,draggableId,isEnabled]),onMoveEnd=useCallback((event=>{"DRAGGING"===mapped.type&&mapped.dropping&&"transform"===event.propertyName&&(react.version.startsWith("16")||react.version.startsWith("17")?dropAnimationFinishedAction():(0,react_dom.flushSync)(dropAnimationFinishedAction))}),[dropAnimationFinishedAction,mapped]),provided=useMemo((()=>{const style=getStyle$1(mapped),onTransitionEnd="DRAGGING"===mapped.type&&mapped.dropping?onMoveEnd:void 0;return{innerRef:setRef,draggableProps:{"data-rfd-draggable-context-id":contextId,"data-rfd-draggable-id":draggableId,style,onTransitionEnd},dragHandleProps}}),[contextId,dragHandleProps,draggableId,mapped,onMoveEnd,setRef]),rubric=useMemo((()=>({draggableId:descriptor.id,type:descriptor.type,source:{index:descriptor.index,droppableId:descriptor.droppableId}})),[descriptor.droppableId,descriptor.id,descriptor.index,descriptor.type]);return react.createElement(react.Fragment,null,children(provided,mapped.snapshot,rubric))},isStrictEqual=(a,b)=>a===b,whatIsDraggedOverFromResult=result=>{const{combine,destination}=result;return destination?destination.droppableId:combine?combine.droppableId:null};function getSecondarySnapshot(combineTargetFor=null){return{isDragging:!1,isDropAnimating:!1,isClone:!1,dropAnimation:null,mode:null,draggingOver:null,combineTargetFor,combineWith:null}}const atRest={mapped:{type:"SECONDARY",offset:origin,combineTargetFor:null,shouldAnimateDisplacement:!0,snapshot:getSecondarySnapshot(null)}};const mapDispatchToProps$1={dropAnimationFinished},ConnectedDraggable=(0,es.Ng)((()=>{const draggingSelector=function getDraggableSelector(){const memoizedOffset=(0,memoize_one_esm.A)(((x,y)=>({x,y}))),getMemoizedSnapshot=(0,memoize_one_esm.A)(((mode,isClone,draggingOver=null,combineWith=null,dropping=null)=>({isDragging:!0,isClone,isDropAnimating:Boolean(dropping),dropAnimation:dropping,mode,draggingOver,combineWith,combineTargetFor:null}))),getMemoizedProps=(0,memoize_one_esm.A)(((offset,mode,dimension,isClone,draggingOver=null,combineWith=null,forceShouldAnimate=null)=>({mapped:{type:"DRAGGING",dropping:null,draggingOver,combineWith,mode,offset,dimension,forceShouldAnimate,snapshot:getMemoizedSnapshot(mode,isClone,draggingOver,combineWith,null)}})));return(state,ownProps)=>{if(isDragging(state)){if(state.critical.draggable.id!==ownProps.draggableId)return null;const offset=state.current.client.offset,dimension=state.dimensions.draggables[ownProps.draggableId],draggingOver=whatIsDraggedOver(state.impact),combineWith=(impact=state.impact).at&&"COMBINE"===impact.at.type?impact.at.combine.draggableId:null,forceShouldAnimate=state.forceShouldAnimate;return getMemoizedProps(memoizedOffset(offset.x,offset.y),state.movementMode,dimension,ownProps.isClone,draggingOver,combineWith,forceShouldAnimate)}var impact;if("DROP_ANIMATING"===state.phase){const completed=state.completed;if(completed.result.draggableId!==ownProps.draggableId)return null;const isClone=ownProps.isClone,dimension=state.dimensions.draggables[ownProps.draggableId],result=completed.result,mode=result.mode,draggingOver=whatIsDraggedOverFromResult(result),combineWith=(result=>result.combine?result.combine.draggableId:null)(result),dropping={duration:state.dropDuration,curve:curves_drop,moveTo:state.newHomeClientOffset,opacity:combineWith?combine_opacity.drop:null,scale:combineWith?combine_scale.drop:null};return{mapped:{type:"DRAGGING",offset:state.newHomeClientOffset,dimension,dropping,draggingOver,combineWith,mode,forceShouldAnimate:null,snapshot:getMemoizedSnapshot(mode,isClone,draggingOver,combineWith,dropping)}}}return null}}(),secondarySelector=function getSecondarySelector(){const memoizedOffset=(0,memoize_one_esm.A)(((x,y)=>({x,y}))),getMemoizedSnapshot=(0,memoize_one_esm.A)(getSecondarySnapshot),getMemoizedProps=(0,memoize_one_esm.A)(((offset,combineTargetFor=null,shouldAnimateDisplacement)=>({mapped:{type:"SECONDARY",offset,combineTargetFor,shouldAnimateDisplacement,snapshot:getMemoizedSnapshot(combineTargetFor)}}))),getFallback=combineTargetFor=>combineTargetFor?getMemoizedProps(origin,combineTargetFor,!0):null,getProps=(ownId,draggingId,impact,afterCritical)=>{const visualDisplacement=impact.displaced.visible[ownId],isAfterCriticalInVirtualList=Boolean(afterCritical.inVirtualList&&afterCritical.effected[ownId]),combine=tryGetCombine(impact),combineTargetFor=combine&&combine.draggableId===ownId?draggingId:null;if(!visualDisplacement){if(!isAfterCriticalInVirtualList)return getFallback(combineTargetFor);if(impact.displaced.invisible[ownId])return null;const change=negate(afterCritical.displacedBy.point),offset=memoizedOffset(change.x,change.y);return getMemoizedProps(offset,combineTargetFor,!0)}if(isAfterCriticalInVirtualList)return getFallback(combineTargetFor);const displaceBy=impact.displacedBy.point,offset=memoizedOffset(displaceBy.x,displaceBy.y);return getMemoizedProps(offset,combineTargetFor,visualDisplacement.shouldAnimate)};return(state,ownProps)=>{if(isDragging(state))return state.critical.draggable.id===ownProps.draggableId?null:getProps(ownProps.draggableId,state.critical.draggable.id,state.impact,state.afterCritical);if("DROP_ANIMATING"===state.phase){const completed=state.completed;return completed.result.draggableId===ownProps.draggableId?null:getProps(ownProps.draggableId,completed.result.draggableId,completed.impact,completed.afterCritical)}return null}}();return(state,ownProps)=>draggingSelector(state,ownProps)||secondarySelector(state,ownProps)||atRest}),mapDispatchToProps$1,null,{context:StoreContext,areStatePropsEqual:isStrictEqual})(Draggable$1);var ConnectedDraggable$1=ConnectedDraggable;function PrivateDraggable(props){return useRequiredContext(DroppableContext).isUsingCloneFor!==props.draggableId||props.isClone?react.createElement(ConnectedDraggable$1,props):null}function PublicDraggable(props){const isEnabled="boolean"!=typeof props.isDragDisabled||!props.isDragDisabled,canDragInteractiveElements=Boolean(props.disableInteractiveElementBlocking),shouldRespectForcePress=Boolean(props.shouldRespectForcePress);return react.createElement(PrivateDraggable,(0,esm_extends.A)({},props,{isClone:!1,isEnabled,canDragInteractiveElements,shouldRespectForcePress}))}const isEqual=base=>value=>base===value,isScroll=isEqual("scroll"),isAuto=isEqual("auto"),isEither=(isEqual("visible"),(overflow,fn)=>fn(overflow.overflowX)||fn(overflow.overflowY)),isElementScrollable=el=>{const style=window.getComputedStyle(el),overflow={overflowX:style.overflowX,overflowY:style.overflowY};return isEither(overflow,isScroll)||isEither(overflow,isAuto)},getClosestScrollable=el=>null==el||el===document.body||el===document.documentElement?null:isElementScrollable(el)?el:getClosestScrollable(el.parentElement);var getScroll=el=>({x:el.scrollLeft,y:el.scrollTop});const getIsFixed=el=>{if(!el)return!1;return"fixed"===window.getComputedStyle(el).position||getIsFixed(el.parentElement)};var getDimension=({ref,descriptor,env,windowScroll,direction,isDropDisabled,isCombineEnabled,shouldClipSubject})=>{const closestScrollable=env.closestScrollable,client=((targetRef,closestScrollable)=>{const base=getBox(targetRef);if(!closestScrollable)return base;if(targetRef!==closestScrollable)return base;const top=base.paddingBox.top-closestScrollable.scrollTop,left=base.paddingBox.left-closestScrollable.scrollLeft,bottom=top+closestScrollable.scrollHeight,right=left+closestScrollable.scrollWidth,borderBox=expand({top,right,bottom,left},base.border);return createBox({borderBox,margin:base.margin,border:base.border,padding:base.padding})})(ref,closestScrollable),page=withScroll(client,windowScroll),closest=(()=>{if(!closestScrollable)return null;const frameClient=getBox(closestScrollable),scrollSize={scrollHeight:closestScrollable.scrollHeight,scrollWidth:closestScrollable.scrollWidth};return{client:frameClient,page:withScroll(frameClient,windowScroll),scroll:getScroll(closestScrollable),scrollSize,shouldClipSubject}})(),dimension=(({descriptor,isEnabled,isCombineEnabled,isFixedOnPage,direction,client,page,closest})=>{const frame=(()=>{if(!closest)return null;const{scrollSize,client:frameClient}=closest,maxScroll=getMaxScroll({scrollHeight:scrollSize.scrollHeight,scrollWidth:scrollSize.scrollWidth,height:frameClient.paddingBox.height,width:frameClient.paddingBox.width});return{pageMarginBox:closest.page.marginBox,frameClient,scrollSize,shouldClipSubject:closest.shouldClipSubject,scroll:{initial:closest.scroll,current:closest.scroll,max:maxScroll,diff:{value:origin,displacement:origin}}}})(),axis="vertical"===direction?vertical:horizontal;return{descriptor,isCombineEnabled,isFixedOnPage,axis,isEnabled,client,page,frame,subject:getSubject({page,withPlaceholder:null,axis,frame})}})({descriptor,isEnabled:!isDropDisabled,isCombineEnabled,isFixedOnPage:env.isFixedOnPage,direction,client,page,closest});return dimension};const immediate={passive:!1},delayed={passive:!0};var getListenerOptions=options=>options.shouldPublishImmediately?immediate:delayed;const getClosestScrollableFromDrag=dragging=>dragging&&dragging.env.closestScrollable||null;function useDroppablePublisher(args){const whileDraggingRef=(0,react.useRef)(null),appContext=useRequiredContext(AppContext),uniqueId=useUniqueId$1("droppable"),{registry,marshal}=appContext,previousRef=usePrevious(args),descriptor=useMemo((()=>({id:args.droppableId,type:args.type,mode:args.mode})),[args.droppableId,args.mode,args.type]),publishedDescriptorRef=(0,react.useRef)(descriptor),memoizedUpdateScroll=useMemo((()=>(0,memoize_one_esm.A)(((x,y)=>{whileDraggingRef.current||invariant(!1);const scroll={x,y};marshal.updateDroppableScroll(descriptor.id,scroll)}))),[descriptor.id,marshal]),getClosestScroll=useCallback((()=>{const dragging=whileDraggingRef.current;return dragging&&dragging.env.closestScrollable?getScroll(dragging.env.closestScrollable):origin}),[]),updateScroll=useCallback((()=>{const scroll=getClosestScroll();memoizedUpdateScroll(scroll.x,scroll.y)}),[getClosestScroll,memoizedUpdateScroll]),scheduleScrollUpdate=useMemo((()=>raf_schd_esm(updateScroll)),[updateScroll]),onClosestScroll=useCallback((()=>{const dragging=whileDraggingRef.current,closest=getClosestScrollableFromDrag(dragging);dragging&&closest||invariant(!1);dragging.scrollOptions.shouldPublishImmediately?updateScroll():scheduleScrollUpdate()}),[scheduleScrollUpdate,updateScroll]),getDimensionAndWatchScroll=useCallback(((windowScroll,options)=>{whileDraggingRef.current&&invariant(!1);const previous=previousRef.current,ref=previous.getDroppableRef();ref||invariant(!1);const env=(start=>({closestScrollable:getClosestScrollable(start),isFixedOnPage:getIsFixed(start)}))(ref),dragging={ref,descriptor,env,scrollOptions:options};whileDraggingRef.current=dragging;const dimension=getDimension({ref,descriptor,env,windowScroll,direction:previous.direction,isDropDisabled:previous.isDropDisabled,isCombineEnabled:previous.isCombineEnabled,shouldClipSubject:!previous.ignoreContainerClipping}),scrollable=env.closestScrollable;return scrollable&&(scrollable.setAttribute(scrollContainer.contextId,appContext.contextId),scrollable.addEventListener("scroll",onClosestScroll,getListenerOptions(dragging.scrollOptions))),dimension}),[appContext.contextId,descriptor,onClosestScroll,previousRef]),getScrollWhileDragging=useCallback((()=>{const dragging=whileDraggingRef.current,closest=getClosestScrollableFromDrag(dragging);return dragging&&closest||invariant(!1),getScroll(closest)}),[]),dragStopped=useCallback((()=>{const dragging=whileDraggingRef.current;dragging||invariant(!1);const closest=getClosestScrollableFromDrag(dragging);whileDraggingRef.current=null,closest&&(scheduleScrollUpdate.cancel(),closest.removeAttribute(scrollContainer.contextId),closest.removeEventListener("scroll",onClosestScroll,getListenerOptions(dragging.scrollOptions)))}),[onClosestScroll,scheduleScrollUpdate]),scroll=useCallback((change=>{const dragging=whileDraggingRef.current;dragging||invariant(!1);const closest=getClosestScrollableFromDrag(dragging);closest||invariant(!1),closest.scrollTop+=change.y,closest.scrollLeft+=change.x}),[]),callbacks=useMemo((()=>({getDimensionAndWatchScroll,getScrollWhileDragging,dragStopped,scroll})),[dragStopped,getDimensionAndWatchScroll,getScrollWhileDragging,scroll]),entry=useMemo((()=>({uniqueId,descriptor,callbacks})),[callbacks,descriptor,uniqueId]);useLayoutEffect((()=>(publishedDescriptorRef.current=entry.descriptor,registry.droppable.register(entry),()=>{whileDraggingRef.current&&dragStopped(),registry.droppable.unregister(entry)})),[callbacks,descriptor,dragStopped,entry,marshal,registry.droppable]),useLayoutEffect((()=>{whileDraggingRef.current&&marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id,!args.isDropDisabled)}),[args.isDropDisabled,marshal]),useLayoutEffect((()=>{whileDraggingRef.current&&marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id,args.isCombineEnabled)}),[args.isCombineEnabled,marshal])}function noop(){}const empty={width:0,height:0,margin:{top:0,right:0,bottom:0,left:0}},getStyle=({isAnimatingOpenOnMount,placeholder,animate})=>{const size=(({isAnimatingOpenOnMount,placeholder,animate})=>isAnimatingOpenOnMount||"close"===animate?empty:{height:placeholder.client.borderBox.height,width:placeholder.client.borderBox.width,margin:placeholder.client.margin})({isAnimatingOpenOnMount,placeholder,animate});return{display:placeholder.display,boxSizing:"border-box",width:size.width,height:size.height,marginTop:size.margin.top,marginRight:size.margin.right,marginBottom:size.margin.bottom,marginLeft:size.margin.left,flexShrink:"0",flexGrow:"0",pointerEvents:"none",transition:"none"!==animate?transitions.placeholder:null}};var Placeholder$1=react.memo((props=>{const animateOpenTimerRef=(0,react.useRef)(null),tryClearAnimateOpenTimer=useCallback((()=>{animateOpenTimerRef.current&&(clearTimeout(animateOpenTimerRef.current),animateOpenTimerRef.current=null)}),[]),{animate,onTransitionEnd,onClose,contextId}=props,[isAnimatingOpenOnMount,setIsAnimatingOpenOnMount]=(0,react.useState)("open"===props.animate);(0,react.useEffect)((()=>isAnimatingOpenOnMount?"open"!==animate?(tryClearAnimateOpenTimer(),setIsAnimatingOpenOnMount(!1),noop):animateOpenTimerRef.current?noop:(animateOpenTimerRef.current=setTimeout((()=>{animateOpenTimerRef.current=null,setIsAnimatingOpenOnMount(!1)})),tryClearAnimateOpenTimer):noop),[animate,isAnimatingOpenOnMount,tryClearAnimateOpenTimer]);const onSizeChangeEnd=useCallback((event=>{"height"===event.propertyName&&(onTransitionEnd(),"close"===animate&&onClose())}),[animate,onClose,onTransitionEnd]),style=getStyle({isAnimatingOpenOnMount,animate:props.animate,placeholder:props.placeholder});return react.createElement(props.placeholder.tagName,{style,"data-rfd-placeholder-context-id":contextId,onTransitionEnd:onSizeChangeEnd,ref:props.innerRef})}));class AnimateInOut extends react.PureComponent{constructor(...args){super(...args),this.state={isVisible:Boolean(this.props.on),data:this.props.on,animate:this.props.shouldAnimate&&this.props.on?"open":"none"},this.onClose=()=>{"close"===this.state.animate&&this.setState({isVisible:!1})}}static getDerivedStateFromProps(props,state){return props.shouldAnimate?props.on?{isVisible:!0,data:props.on,animate:"open"}:state.isVisible?{isVisible:!0,data:state.data,animate:"close"}:{isVisible:!1,animate:"close",data:null}:{isVisible:Boolean(props.on),data:props.on,animate:"none"}}render(){if(!this.state.isVisible)return null;const provided={onClose:this.onClose,data:this.state.data,animate:this.state.animate};return this.props.children(provided)}}var Droppable$1=props=>{const appContext=(0,react.useContext)(AppContext);appContext||invariant(!1);const{contextId,isMovementAllowed}=appContext,droppableRef=(0,react.useRef)(null),placeholderRef=(0,react.useRef)(null),{children,droppableId,type,mode,direction,ignoreContainerClipping,isDropDisabled,isCombineEnabled,snapshot,useClone,updateViewportMaxScroll,getContainerForClone}=props,getDroppableRef=useCallback((()=>droppableRef.current),[]),setDroppableRef=useCallback(((value=null)=>{droppableRef.current=value}),[]),setPlaceholderRef=(useCallback((()=>placeholderRef.current),[]),useCallback(((value=null)=>{placeholderRef.current=value}),[]));!function useValidation(args){useDevSetupWarning()}();const onPlaceholderTransitionEnd=useCallback((()=>{isMovementAllowed()&&updateViewportMaxScroll({maxScroll:getMaxWindowScroll()})}),[isMovementAllowed,updateViewportMaxScroll]);useDroppablePublisher({droppableId,type,mode,direction,isDropDisabled,isCombineEnabled,ignoreContainerClipping,getDroppableRef});const placeholder=useMemo((()=>react.createElement(AnimateInOut,{on:props.placeholder,shouldAnimate:props.shouldAnimatePlaceholder},(({onClose,data,animate})=>react.createElement(Placeholder$1,{placeholder:data,onClose,innerRef:setPlaceholderRef,animate,contextId,onTransitionEnd:onPlaceholderTransitionEnd})))),[contextId,onPlaceholderTransitionEnd,props.placeholder,props.shouldAnimatePlaceholder,setPlaceholderRef]),provided=useMemo((()=>({innerRef:setDroppableRef,placeholder,droppableProps:{"data-rfd-droppable-id":droppableId,"data-rfd-droppable-context-id":contextId}})),[contextId,droppableId,placeholder,setDroppableRef]),isUsingCloneFor=useClone?useClone.dragging.draggableId:null,droppableContext=useMemo((()=>({droppableId,type,isUsingCloneFor})),[droppableId,isUsingCloneFor,type]);return react.createElement(DroppableContext.Provider,{value:droppableContext},children(provided,snapshot),function getClone(){if(!useClone)return null;const{dragging,render}=useClone,node=react.createElement(PrivateDraggable,{draggableId:dragging.draggableId,index:dragging.source.index,isClone:!0,isEnabled:!0,shouldRespectForcePress:!1,canDragInteractiveElements:!0},((draggableProvided,draggableSnapshot)=>render(draggableProvided,draggableSnapshot,dragging)));return react_dom.createPortal(node,getContainerForClone())}())};const defaultProps={mode:"standard",type:"DEFAULT",direction:"vertical",isDropDisabled:!1,isCombineEnabled:!1,ignoreContainerClipping:!1,renderClone:null,getContainerForClone:function getBody(){return document.body||invariant(!1),document.body}},attachDefaultPropsToOwnProps=ownProps=>{let defaultPropKey,mergedProps={...ownProps};for(defaultPropKey in defaultProps)void 0===ownProps[defaultPropKey]&&(mergedProps={...mergedProps,[defaultPropKey]:defaultProps[defaultPropKey]});return mergedProps},isMatchingType=(type,critical)=>type===critical.droppable.type,getDraggable=(critical,dimensions)=>dimensions.draggables[critical.draggable.id],mapDispatchToProps={updateViewportMaxScroll:args=>({type:"UPDATE_VIEWPORT_MAX_SCROLL",payload:args})};var ConnectedDroppable$1=(0,es.Ng)((()=>{const idleWithAnimation={placeholder:null,shouldAnimatePlaceholder:!0,snapshot:{isDraggingOver:!1,draggingOverWith:null,draggingFromThisWith:null,isUsingPlaceholder:!1},useClone:null},idleWithoutAnimation={...idleWithAnimation,shouldAnimatePlaceholder:!1},getDraggableRubric=(0,memoize_one_esm.A)((descriptor=>({draggableId:descriptor.id,type:descriptor.type,source:{index:descriptor.index,droppableId:descriptor.droppableId}}))),getMapProps=(0,memoize_one_esm.A)(((id,isEnabled,isDraggingOverForConsumer,isDraggingOverForImpact,dragging,renderClone)=>{const draggableId=dragging.descriptor.id;if(dragging.descriptor.droppableId===id){const useClone=renderClone?{render:renderClone,dragging:getDraggableRubric(dragging.descriptor)}:null,snapshot={isDraggingOver:isDraggingOverForConsumer,draggingOverWith:isDraggingOverForConsumer?draggableId:null,draggingFromThisWith:draggableId,isUsingPlaceholder:!0};return{placeholder:dragging.placeholder,shouldAnimatePlaceholder:!1,snapshot,useClone}}if(!isEnabled)return idleWithoutAnimation;if(!isDraggingOverForImpact)return idleWithAnimation;const snapshot={isDraggingOver:isDraggingOverForConsumer,draggingOverWith:draggableId,draggingFromThisWith:null,isUsingPlaceholder:!0};return{placeholder:dragging.placeholder,shouldAnimatePlaceholder:!0,snapshot,useClone:null}}));return(state,ownProps)=>{const ownPropsWithDefaultProps=attachDefaultPropsToOwnProps(ownProps),id=ownPropsWithDefaultProps.droppableId,type=ownPropsWithDefaultProps.type,isEnabled=!ownPropsWithDefaultProps.isDropDisabled,renderClone=ownPropsWithDefaultProps.renderClone;if(isDragging(state)){const critical=state.critical;if(!isMatchingType(type,critical))return idleWithoutAnimation;const dragging=getDraggable(critical,state.dimensions),isDraggingOver=whatIsDraggedOver(state.impact)===id;return getMapProps(id,isEnabled,isDraggingOver,isDraggingOver,dragging,renderClone)}if("DROP_ANIMATING"===state.phase){const completed=state.completed;if(!isMatchingType(type,completed.critical))return idleWithoutAnimation;const dragging=getDraggable(completed.critical,state.dimensions);return getMapProps(id,isEnabled,whatIsDraggedOverFromResult(completed.result)===id,whatIsDraggedOver(completed.impact)===id,dragging,renderClone)}if("IDLE"===state.phase&&state.completed&&!state.shouldFlush){const completed=state.completed;if(!isMatchingType(type,completed.critical))return idleWithoutAnimation;const wasOver=whatIsDraggedOver(completed.impact)===id,wasCombining=Boolean(completed.impact.at&&"COMBINE"===completed.impact.at.type),isHome=completed.critical.droppable.id===id;return wasOver?wasCombining?idleWithAnimation:idleWithoutAnimation:isHome?idleWithAnimation:idleWithoutAnimation}return idleWithoutAnimation}}),mapDispatchToProps,((stateProps,dispatchProps,ownProps)=>({...attachDefaultPropsToOwnProps(ownProps),...stateProps,...dispatchProps})),{context:StoreContext,areStatePropsEqual:isStrictEqual})(Droppable$1)},"./node_modules/@radix-ui/number/dist/index.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";function clamp(value,[min,max]){return Math.min(max,Math.max(min,value))}__webpack_require__.d(__webpack_exports__,{q:()=>clamp})},"./node_modules/@radix-ui/react-toggle-group/dist/index.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{bL:()=>Root2,q7:()=>Item2});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/next/dist/compiled/react/index.js"),_radix_ui_react_context__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@radix-ui/react-context/dist/index.mjs"),_radix_ui_react_primitive__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__("./node_modules/@radix-ui/react-primitive/dist/index.mjs"),_radix_ui_react_roving_focus__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/@radix-ui/react-roving-focus/dist/index.mjs"),_radix_ui_react_toggle__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__("./node_modules/@radix-ui/react-toggle/dist/index.mjs"),_radix_ui_react_use_controllable_state__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__("./node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs"),_radix_ui_react_direction__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__("./node_modules/@radix-ui/react-direction/dist/index.mjs"),react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/next/dist/compiled/react/jsx-runtime.js"),[createToggleGroupContext,createToggleGroupScope]=(0,_radix_ui_react_context__WEBPACK_IMPORTED_MODULE_2__.A)("ToggleGroup",[_radix_ui_react_roving_focus__WEBPACK_IMPORTED_MODULE_3__.RG]),useRovingFocusGroupScope=(0,_radix_ui_react_roving_focus__WEBPACK_IMPORTED_MODULE_3__.RG)(),ToggleGroup=react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(((props,forwardedRef)=>{const{type,...toggleGroupProps}=props;if("single"===type){const singleProps=toggleGroupProps;return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ToggleGroupImplSingle,{...singleProps,ref:forwardedRef})}if("multiple"===type){const multipleProps=toggleGroupProps;return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ToggleGroupImplMultiple,{...multipleProps,ref:forwardedRef})}throw new Error("Missing prop `type` expected on `ToggleGroup`")}));ToggleGroup.displayName="ToggleGroup";var[ToggleGroupValueProvider,useToggleGroupValueContext]=createToggleGroupContext("ToggleGroup"),ToggleGroupImplSingle=react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(((props,forwardedRef)=>{const{value:valueProp,defaultValue,onValueChange=()=>{},...toggleGroupSingleProps}=props,[value,setValue]=(0,_radix_ui_react_use_controllable_state__WEBPACK_IMPORTED_MODULE_4__.i)({prop:valueProp,defaultProp:defaultValue,onChange:onValueChange});return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ToggleGroupValueProvider,{scope:props.__scopeToggleGroup,type:"single",value:value?[value]:[],onItemActivate:setValue,onItemDeactivate:react__WEBPACK_IMPORTED_MODULE_0__.useCallback((()=>setValue("")),[setValue]),children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ToggleGroupImpl,{...toggleGroupSingleProps,ref:forwardedRef})})})),ToggleGroupImplMultiple=react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(((props,forwardedRef)=>{const{value:valueProp,defaultValue,onValueChange=()=>{},...toggleGroupMultipleProps}=props,[value=[],setValue]=(0,_radix_ui_react_use_controllable_state__WEBPACK_IMPORTED_MODULE_4__.i)({prop:valueProp,defaultProp:defaultValue,onChange:onValueChange}),handleButtonActivate=react__WEBPACK_IMPORTED_MODULE_0__.useCallback((itemValue=>setValue(((prevValue=[])=>[...prevValue,itemValue]))),[setValue]),handleButtonDeactivate=react__WEBPACK_IMPORTED_MODULE_0__.useCallback((itemValue=>setValue(((prevValue=[])=>prevValue.filter((value2=>value2!==itemValue))))),[setValue]);return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ToggleGroupValueProvider,{scope:props.__scopeToggleGroup,type:"multiple",value,onItemActivate:handleButtonActivate,onItemDeactivate:handleButtonDeactivate,children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ToggleGroupImpl,{...toggleGroupMultipleProps,ref:forwardedRef})})}));ToggleGroup.displayName="ToggleGroup";var[ToggleGroupContext,useToggleGroupContext]=createToggleGroupContext("ToggleGroup"),ToggleGroupImpl=react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(((props,forwardedRef)=>{const{__scopeToggleGroup,disabled=!1,rovingFocus=!0,orientation,dir,loop=!0,...toggleGroupProps}=props,rovingFocusGroupScope=useRovingFocusGroupScope(__scopeToggleGroup),direction=(0,_radix_ui_react_direction__WEBPACK_IMPORTED_MODULE_5__.jH)(dir),commonProps={role:"group",dir:direction,...toggleGroupProps};return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ToggleGroupContext,{scope:__scopeToggleGroup,rovingFocus,disabled,children:rovingFocus?(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_roving_focus__WEBPACK_IMPORTED_MODULE_3__.bL,{asChild:!0,...rovingFocusGroupScope,orientation,dir:direction,loop,children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_primitive__WEBPACK_IMPORTED_MODULE_6__.sG.div,{...commonProps,ref:forwardedRef})}):(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_primitive__WEBPACK_IMPORTED_MODULE_6__.sG.div,{...commonProps,ref:forwardedRef})})})),ITEM_NAME="ToggleGroupItem",ToggleGroupItem=react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(((props,forwardedRef)=>{const valueContext=useToggleGroupValueContext(ITEM_NAME,props.__scopeToggleGroup),context=useToggleGroupContext(ITEM_NAME,props.__scopeToggleGroup),rovingFocusGroupScope=useRovingFocusGroupScope(props.__scopeToggleGroup),pressed=valueContext.value.includes(props.value),disabled=context.disabled||props.disabled,commonProps={...props,pressed,disabled},ref=react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);return context.rovingFocus?(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_roving_focus__WEBPACK_IMPORTED_MODULE_3__.q7,{asChild:!0,...rovingFocusGroupScope,focusable:!disabled,active:pressed,ref,children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ToggleGroupItemImpl,{...commonProps,ref:forwardedRef})}):(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ToggleGroupItemImpl,{...commonProps,ref:forwardedRef})}));ToggleGroupItem.displayName=ITEM_NAME;var ToggleGroupItemImpl=react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(((props,forwardedRef)=>{const{__scopeToggleGroup,value,...itemProps}=props,valueContext=useToggleGroupValueContext(ITEM_NAME,__scopeToggleGroup),singleProps={role:"radio","aria-checked":props.pressed,"aria-pressed":void 0},typeProps="single"===valueContext.type?singleProps:void 0;return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_radix_ui_react_toggle__WEBPACK_IMPORTED_MODULE_7__.l,{...typeProps,...itemProps,ref:forwardedRef,onPressedChange:pressed=>{pressed?valueContext.onItemActivate(value):valueContext.onItemDeactivate(value)}})})),Root2=ToggleGroup,Item2=ToggleGroupItem},"./node_modules/@radix-ui/react-use-previous/dist/index.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{Z:()=>usePrevious});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/next/dist/compiled/react/index.js");function usePrevious(value){const ref=react__WEBPACK_IMPORTED_MODULE_0__.useRef({value,previous:value});return react__WEBPACK_IMPORTED_MODULE_0__.useMemo((()=>(ref.current.value!==value&&(ref.current.previous=ref.current.value,ref.current.value=value),ref.current.previous)),[value])}},"./node_modules/fabric/dist/index.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{D2:()=>FabricObject,Ec:()=>Control,Hl:()=>Canvas,N1:()=>Line,Pp:()=>Ellipse,Rj:()=>Textbox,UZ:()=>index,VZ:()=>ActiveSelection,Vo:()=>Shadow,YJ:()=>Group,ZS:()=>index$1,_V:()=>FabricImage,bR:()=>Point,dZ:()=>StaticCanvas,ii:()=>BaseBrush,oV:()=>classRegistry,rw:()=>Rect,wA:()=>Path});var console=__webpack_require__("./node_modules/console-browserify/index.js");function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach((function(key){_defineProperty(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}function _defineProperty(obj,key,value){return(key=_toPropertyKey(key))in obj?Object.defineProperty(obj,key,{value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function _objectWithoutProperties(source,excluded){if(null==source)return{};var key,i,target=function _objectWithoutPropertiesLoose(source,excluded){if(null==source)return{};var key,i,target={},sourceKeys=Object.keys(source);for(i=0;i<sourceKeys.length;i++)key=sourceKeys[i],excluded.indexOf(key)>=0||(target[key]=source[key]);return target}(source,excluded);if(Object.getOwnPropertySymbols){var sourceSymbolKeys=Object.getOwnPropertySymbols(source);for(i=0;i<sourceSymbolKeys.length;i++)key=sourceSymbolKeys[i],excluded.indexOf(key)>=0||Object.prototype.propertyIsEnumerable.call(source,key)&&(target[key]=source[key])}return target}function _taggedTemplateLiteral(strings,raw){return raw||(raw=strings.slice(0)),Object.freeze(Object.defineProperties(strings,{raw:{value:Object.freeze(raw)}}))}function _toPropertyKey(arg){var key=function _toPrimitive(input,hint){if("object"!=typeof input||null===input)return input;var prim=input[Symbol.toPrimitive];if(void 0!==prim){var res=prim.call(input,hint||"default");if("object"!=typeof res)return res;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===hint?String:Number)(input)}(arg,"string");return"symbol"==typeof key?key:String(key)}class BaseConfiguration{constructor(){_defineProperty(this,"browserShadowBlurConstant",1),_defineProperty(this,"DPI",96),_defineProperty(this,"devicePixelRatio","undefined"!=typeof window?window.devicePixelRatio:1),_defineProperty(this,"perfLimitSizeTotal",2097152),_defineProperty(this,"maxCacheSideLimit",4096),_defineProperty(this,"minCacheSideLimit",256),_defineProperty(this,"disableStyleCopyPaste",!1),_defineProperty(this,"enableGLFiltering",!0),_defineProperty(this,"textureSize",4096),_defineProperty(this,"forceGLPutImageData",!1),_defineProperty(this,"cachesBoundsOfCurve",!0),_defineProperty(this,"fontPaths",{}),_defineProperty(this,"NUM_FRACTION_DIGITS",4)}}const config=new class Configuration extends BaseConfiguration{constructor(config){super(),this.configure(config)}configure(){let config=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Object.assign(this,config)}addFonts(){let paths=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.fontPaths=_objectSpread2(_objectSpread2({},this.fontPaths),paths)}removeFonts(){(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[]).forEach((fontFamily=>{delete this.fontPaths[fontFamily]}))}clearFonts(){this.fontPaths={}}restoreDefaults(keys){const defaults=new BaseConfiguration,config=(null==keys?void 0:keys.reduce(((acc,key)=>(acc[key]=defaults[key],acc)),{}))||defaults;this.configure(config)}},log=function(severity){for(var _len=arguments.length,optionalParams=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)optionalParams[_key-1]=arguments[_key];return console[severity]("fabric",...optionalParams)};class FabricError extends Error{constructor(message,options){super("fabric: ".concat(message),options)}}class SignalAbortedError extends FabricError{constructor(context){super("".concat(context," 'options.signal' is in 'aborted' state"))}}class GLProbe{}class WebGLProbe extends GLProbe{testPrecision(gl,precision){const fragmentSource="precision ".concat(precision," float;\nvoid main(){}"),fragmentShader=gl.createShader(gl.FRAGMENT_SHADER);return!!fragmentShader&&(gl.shaderSource(fragmentShader,fragmentSource),gl.compileShader(fragmentShader),!!gl.getShaderParameter(fragmentShader,gl.COMPILE_STATUS))}queryWebGL(canvas){const gl=canvas.getContext("webgl");gl&&(this.maxTextureSize=gl.getParameter(gl.MAX_TEXTURE_SIZE),this.GLPrecision=["highp","mediump","lowp"].find((precision=>this.testPrecision(gl,precision))),gl.getExtension("WEBGL_lose_context").loseContext(),log("log","WebGL: max texture size ".concat(this.maxTextureSize)))}isSupported(textureSize){return!!this.maxTextureSize&&this.maxTextureSize>=textureSize}}const copyPasteData={};let env;const getEnv=()=>env||(env={document,window,isTouchSupported:"ontouchstart"in window||"ontouchstart"in document||window&&window.navigator&&window.navigator.maxTouchPoints>0,WebGLProbe:new WebGLProbe,dispose(){},copyPasteData}),getFabricDocument=()=>getEnv().document,getFabricWindow=()=>getEnv().window,getDevicePixelRatio=()=>{var _config$devicePixelRa;return Math.max(null!==(_config$devicePixelRa=config.devicePixelRatio)&&void 0!==_config$devicePixelRa?_config$devicePixelRa:getFabricWindow().devicePixelRatio,1)};const cache=new class Cache{constructor(){_defineProperty(this,"charWidthsCache",{}),_defineProperty(this,"boundsOfCurveCache",{})}getFontCache(_ref){let{fontFamily,fontStyle,fontWeight}=_ref;fontFamily=fontFamily.toLowerCase(),this.charWidthsCache[fontFamily]||(this.charWidthsCache[fontFamily]={});const fontCache=this.charWidthsCache[fontFamily],cacheKey="".concat(fontStyle.toLowerCase(),"_").concat((fontWeight+"").toLowerCase());return fontCache[cacheKey]||(fontCache[cacheKey]={}),fontCache[cacheKey]}clearFontCache(fontFamily){(fontFamily=(fontFamily||"").toLowerCase())?this.charWidthsCache[fontFamily]&&delete this.charWidthsCache[fontFamily]:this.charWidthsCache={}}limitDimsByArea(ar){const{perfLimitSizeTotal}=config,roughWidth=Math.sqrt(perfLimitSizeTotal*ar);return[Math.floor(roughWidth),Math.floor(perfLimitSizeTotal/roughWidth)]}};function noop(){}const halfPI=Math.PI/2,twoMathPi=2*Math.PI,PiBy180=Math.PI/180,iMatrix=Object.freeze([1,0,0,1,0,0]),DEFAULT_SVG_FONT_SIZE=16,kRect=.4477152502,CENTER="center",LEFT="left",TOP="top",RIGHT="right",NONE="none",reNewline=/\r?\n/;const classRegistry=new class ClassRegistry{constructor(){this.json=new Map,this.svg=new Map}getClass(classType){const constructor=this.json.get(classType);if(!constructor)throw new FabricError("No class registered for ".concat(classType));return constructor}setClass(classConstructor,classType){classType?this.json.set(classType,classConstructor):(this.json.set(classConstructor.type,classConstructor),this.json.set(classConstructor.type.toLowerCase(),classConstructor))}getSVGClass(SVGTagName){return this.svg.get(SVGTagName)}setSVGClass(classConstructor,SVGTagName){this.svg.set(null!=SVGTagName?SVGTagName:classConstructor.type.toLowerCase(),classConstructor)}};const runningAnimations=new class AnimationRegistry extends Array{remove(context){const index=this.indexOf(context);index>-1&&this.splice(index,1)}cancelAll(){const animations=this.splice(0);return animations.forEach((animation=>animation.abort())),animations}cancelByCanvas(canvas){if(!canvas)return[];const animations=this.filter((animation=>{var _animation$target;return animation.target===canvas||"object"==typeof animation.target&&(null===(_animation$target=animation.target)||void 0===_animation$target?void 0:_animation$target.canvas)===canvas}));return animations.forEach((animation=>animation.abort())),animations}cancelByTarget(target){if(!target)return[];const animations=this.filter((animation=>animation.target===target));return animations.forEach((animation=>animation.abort())),animations}};class Observable{constructor(){_defineProperty(this,"__eventListeners",{})}on(arg0,handler){if(this.__eventListeners||(this.__eventListeners={}),"object"==typeof arg0)return Object.entries(arg0).forEach((_ref=>{let[eventName,handler]=_ref;this.on(eventName,handler)})),()=>this.off(arg0);if(handler){const eventName=arg0;return this.__eventListeners[eventName]||(this.__eventListeners[eventName]=[]),this.__eventListeners[eventName].push(handler),()=>this.off(eventName,handler)}return()=>!1}once(arg0,handler){if("object"==typeof arg0){const disposers=[];return Object.entries(arg0).forEach((_ref2=>{let[eventName,handler]=_ref2;disposers.push(this.once(eventName,handler))})),()=>disposers.forEach((d=>d()))}if(handler){const disposer=this.on(arg0,(function onceHandler(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];handler.call(this,...args),disposer()}));return disposer}return()=>!1}_removeEventListener(eventName,handler){if(this.__eventListeners[eventName])if(handler){const eventListener=this.__eventListeners[eventName],index=eventListener.indexOf(handler);index>-1&&eventListener.splice(index,1)}else this.__eventListeners[eventName]=[]}off(arg0,handler){if(this.__eventListeners)if(void 0===arg0)for(const eventName in this.__eventListeners)this._removeEventListener(eventName);else"object"==typeof arg0?Object.entries(arg0).forEach((_ref3=>{let[eventName,handler]=_ref3;this._removeEventListener(eventName,handler)})):this._removeEventListener(arg0,handler)}fire(eventName,options){var _this$__eventListener;if(!this.__eventListeners)return;const listenersForEvent=null===(_this$__eventListener=this.__eventListeners[eventName])||void 0===_this$__eventListener?void 0:_this$__eventListener.concat();if(listenersForEvent)for(let i=0;i<listenersForEvent.length;i++)listenersForEvent[i].call(this,options||{})}}const getRandomInt=(min,max)=>Math.floor(Math.random()*(max-min+1))+min,ifNaN=(value,valueIfNaN)=>isNaN(value)&&"number"==typeof valueIfNaN?valueIfNaN:value,removeFromArray=(array,value)=>{const idx=array.indexOf(value);return-1!==idx&&array.splice(idx,1),array},cos=angle=>{if(0===angle)return 1;switch(Math.abs(angle)/halfPI){case 1:case 3:return 0;case 2:return-1}return Math.cos(angle)},sin=angle=>{if(0===angle)return 0;const angleSlice=angle/halfPI,value=Math.sign(angle);switch(angleSlice){case 1:return value;case 2:return 0;case 3:return-value}return Math.sin(angle)};class Point{constructor(){let arg0=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;"object"==typeof arg0?(this.x=arg0.x,this.y=arg0.y):(this.x=arg0,this.y=y)}add(that){return new Point(this.x+that.x,this.y+that.y)}addEquals(that){return this.x+=that.x,this.y+=that.y,this}scalarAdd(scalar){return new Point(this.x+scalar,this.y+scalar)}scalarAddEquals(scalar){return this.x+=scalar,this.y+=scalar,this}subtract(that){return new Point(this.x-that.x,this.y-that.y)}subtractEquals(that){return this.x-=that.x,this.y-=that.y,this}scalarSubtract(scalar){return new Point(this.x-scalar,this.y-scalar)}scalarSubtractEquals(scalar){return this.x-=scalar,this.y-=scalar,this}multiply(that){return new Point(this.x*that.x,this.y*that.y)}scalarMultiply(scalar){return new Point(this.x*scalar,this.y*scalar)}scalarMultiplyEquals(scalar){return this.x*=scalar,this.y*=scalar,this}divide(that){return new Point(this.x/that.x,this.y/that.y)}scalarDivide(scalar){return new Point(this.x/scalar,this.y/scalar)}scalarDivideEquals(scalar){return this.x/=scalar,this.y/=scalar,this}eq(that){return this.x===that.x&&this.y===that.y}lt(that){return this.x<that.x&&this.y<that.y}lte(that){return this.x<=that.x&&this.y<=that.y}gt(that){return this.x>that.x&&this.y>that.y}gte(that){return this.x>=that.x&&this.y>=that.y}lerp(that){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.5;return t=Math.max(Math.min(1,t),0),new Point(this.x+(that.x-this.x)*t,this.y+(that.y-this.y)*t)}distanceFrom(that){const dx=this.x-that.x,dy=this.y-that.y;return Math.sqrt(dx*dx+dy*dy)}midPointFrom(that){return this.lerp(that)}min(that){return new Point(Math.min(this.x,that.x),Math.min(this.y,that.y))}max(that){return new Point(Math.max(this.x,that.x),Math.max(this.y,that.y))}toString(){return"".concat(this.x,",").concat(this.y)}setXY(x,y){return this.x=x,this.y=y,this}setX(x){return this.x=x,this}setY(y){return this.y=y,this}setFromPoint(that){return this.x=that.x,this.y=that.y,this}swap(that){const x=this.x,y=this.y;this.x=that.x,this.y=that.y,that.x=x,that.y=y}clone(){return new Point(this.x,this.y)}rotate(radians){let origin=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ZERO;const sinus=sin(radians),cosinus=cos(radians),p=this.subtract(origin);return new Point(p.x*cosinus-p.y*sinus,p.x*sinus+p.y*cosinus).add(origin)}transform(t){let ignoreOffset=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return new Point(t[0]*this.x+t[2]*this.y+(ignoreOffset?0:t[4]),t[1]*this.x+t[3]*this.y+(ignoreOffset?0:t[5]))}}const ZERO=new Point(0,0),isCollection=fabricObject=>!!fabricObject&&Array.isArray(fabricObject._objects);function createCollectionMixin(Base){class Collection extends Base{constructor(){super(...arguments),_defineProperty(this,"_objects",[])}_onObjectAdded(object){}_onObjectRemoved(object){}_onStackOrderChanged(object){}add(){for(var _len=arguments.length,objects=new Array(_len),_key=0;_key<_len;_key++)objects[_key]=arguments[_key];const size=this._objects.push(...objects);return objects.forEach((object=>this._onObjectAdded(object))),size}insertAt(index){for(var _len2=arguments.length,objects=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++)objects[_key2-1]=arguments[_key2];return this._objects.splice(index,0,...objects),objects.forEach((object=>this._onObjectAdded(object))),this._objects.length}remove(){const array=this._objects,removed=[];for(var _len3=arguments.length,objects=new Array(_len3),_key3=0;_key3<_len3;_key3++)objects[_key3]=arguments[_key3];return objects.forEach((object=>{const index=array.indexOf(object);-1!==index&&(array.splice(index,1),removed.push(object),this._onObjectRemoved(object))})),removed}forEachObject(callback){this.getObjects().forEach(((object,index,objects)=>callback(object,index,objects)))}getObjects(){for(var _len4=arguments.length,types=new Array(_len4),_key4=0;_key4<_len4;_key4++)types[_key4]=arguments[_key4];return 0===types.length?[...this._objects]:this._objects.filter((o=>o.isType(...types)))}item(index){return this._objects[index]}isEmpty(){return 0===this._objects.length}size(){return this._objects.length}contains(object,deep){return!!this._objects.includes(object)||!!deep&&this._objects.some((obj=>obj instanceof Collection&&obj.contains(object,!0)))}complexity(){return this._objects.reduce(((memo,current)=>memo+=current.complexity?current.complexity():0),0)}sendObjectToBack(object){return!(!object||object===this._objects[0])&&(removeFromArray(this._objects,object),this._objects.unshift(object),this._onStackOrderChanged(object),!0)}bringObjectToFront(object){return!(!object||object===this._objects[this._objects.length-1])&&(removeFromArray(this._objects,object),this._objects.push(object),this._onStackOrderChanged(object),!0)}sendObjectBackwards(object,intersecting){if(!object)return!1;const idx=this._objects.indexOf(object);if(0!==idx){const newIdx=this.findNewLowerIndex(object,idx,intersecting);return removeFromArray(this._objects,object),this._objects.splice(newIdx,0,object),this._onStackOrderChanged(object),!0}return!1}bringObjectForward(object,intersecting){if(!object)return!1;const idx=this._objects.indexOf(object);if(idx!==this._objects.length-1){const newIdx=this.findNewUpperIndex(object,idx,intersecting);return removeFromArray(this._objects,object),this._objects.splice(newIdx,0,object),this._onStackOrderChanged(object),!0}return!1}moveObjectTo(object,index){return object!==this._objects[index]&&(removeFromArray(this._objects,object),this._objects.splice(index,0,object),this._onStackOrderChanged(object),!0)}findNewLowerIndex(object,idx,intersecting){let newIdx;if(intersecting){newIdx=idx;for(let i=idx-1;i>=0;--i)if(object.isOverlapping(this._objects[i])){newIdx=i;break}}else newIdx=idx-1;return newIdx}findNewUpperIndex(object,idx,intersecting){let newIdx;if(intersecting){newIdx=idx;for(let i=idx+1;i<this._objects.length;++i)if(object.isOverlapping(this._objects[i])){newIdx=i;break}}else newIdx=idx+1;return newIdx}collectObjects(_ref){let{left,top,width,height}=_ref,{includeIntersecting=!0}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const objects=[],tl=new Point(left,top),br=tl.add(new Point(width,height));for(let i=this._objects.length-1;i>=0;i--){const object=this._objects[i];object.selectable&&object.visible&&(includeIntersecting&&object.intersectsWithRect(tl,br)||object.isContainedWithinRect(tl,br)||includeIntersecting&&object.containsPoint(tl)||includeIntersecting&&object.containsPoint(br))&&objects.push(object)}return objects}}return Collection}class CommonMethods extends Observable{_setOptions(){let options=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};for(const prop in options)this.set(prop,options[prop])}_setObject(obj){for(const prop in obj)this._set(prop,obj[prop])}set(key,value){return"object"==typeof key?this._setObject(key):this._set(key,value),this}_set(key,value){this[key]=value}toggle(property){const value=this.get(property);return"boolean"==typeof value&&this.set(property,!value),this}get(property){return this[property]}}function requestAnimFrame(callback){return getFabricWindow().requestAnimationFrame(callback)}function cancelAnimFrame(handle){return getFabricWindow().cancelAnimationFrame(handle)}let id=0;const uid=()=>id++,createCanvasElement=()=>{const element=getFabricDocument().createElement("canvas");if(!element||void 0===element.getContext)throw new FabricError("Failed to create `canvas` element");return element},createImage=()=>getFabricDocument().createElement("img"),toDataURL=(canvasEl,format,quality)=>canvasEl.toDataURL("image/".concat(format),quality),degreesToRadians=degrees=>degrees*PiBy180,radiansToDegrees=radians=>radians/PiBy180,_excluded$m=["translateX","translateY","angle"],transformPoint=(p,t,ignoreOffset)=>new Point(p).transform(t,ignoreOffset),invertTransform=t=>{const a=1/(t[0]*t[3]-t[1]*t[2]),r=[a*t[3],-a*t[1],-a*t[2],a*t[0],0,0],{x,y}=new Point(t[4],t[5]).transform(r,!0);return r[4]=-x,r[5]=-y,r},multiplyTransformMatrices=(a,b,is2x2)=>[a[0]*b[0]+a[2]*b[1],a[1]*b[0]+a[3]*b[1],a[0]*b[2]+a[2]*b[3],a[1]*b[2]+a[3]*b[3],is2x2?0:a[0]*b[4]+a[2]*b[5]+a[4],is2x2?0:a[1]*b[4]+a[3]*b[5]+a[5]],multiplyTransformMatrixArray=(matrices,is2x2)=>matrices.reduceRight(((product,curr)=>curr?multiplyTransformMatrices(curr,product,is2x2):product),iMatrix),calcPlaneRotation=_ref=>{let[a,b]=_ref;return Math.atan2(b,a)},qrDecompose=a=>{const angle=calcPlaneRotation(a),denom=Math.pow(a[0],2)+Math.pow(a[1],2),scaleX=Math.sqrt(denom),scaleY=(a[0]*a[3]-a[2]*a[1])/scaleX,skewX=Math.atan2(a[0]*a[2]+a[1]*a[3],denom);return{angle:radiansToDegrees(angle),scaleX,scaleY,skewX:radiansToDegrees(skewX),skewY:0,translateX:a[4]||0,translateY:a[5]||0}},createTranslateMatrix=function(x){return[1,0,0,1,x,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0]};function createRotateMatrix(){let{angle=0}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{x=0,y=0}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const angleRadiant=degreesToRadians(angle),cosValue=cos(angleRadiant),sinValue=sin(angleRadiant);return[cosValue,sinValue,-sinValue,cosValue,x?x-(cosValue*x-sinValue*y):0,y?y-(sinValue*x+cosValue*y):0]}const createScaleMatrix=function(x){return[x,0,0,arguments.length>1&&void 0!==arguments[1]?arguments[1]:x,0,0]},angleToSkew=angle=>Math.tan(degreesToRadians(angle)),createSkewXMatrix=skewValue=>[1,0,angleToSkew(skewValue),1,0,0],createSkewYMatrix=skewValue=>[1,angleToSkew(skewValue),0,1,0,0],calcDimensionsMatrix=_ref2=>{let{scaleX=1,scaleY=1,flipX=!1,flipY=!1,skewX=0,skewY=0}=_ref2;return multiplyTransformMatrixArray([createScaleMatrix(flipX?-scaleX:scaleX,flipY?-scaleY:scaleY),skewX&&createSkewXMatrix(skewX),skewY&&createSkewYMatrix(skewY)],!0)},composeMatrix=_ref3=>{let{translateX=0,translateY=0,angle=0}=_ref3,otherOptions=_objectWithoutProperties(_ref3,_excluded$m);return multiplyTransformMatrixArray([createTranslateMatrix(translateX,translateY),angle&&createRotateMatrix({angle}),calcDimensionsMatrix(otherOptions)])},loadImage=function(url){let{signal,crossOrigin=null}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return new Promise((function(resolve,reject){if(signal&&signal.aborted)return reject(new SignalAbortedError("loadImage"));const img=createImage();let abort;signal&&(abort=function(err){img.src="",reject(err)},signal.addEventListener("abort",abort,{once:!0}));const done=function(){img.onload=img.onerror=null,abort&&(null==signal||signal.removeEventListener("abort",abort)),resolve(img)};url?(img.onload=done,img.onerror=function(){abort&&(null==signal||signal.removeEventListener("abort",abort)),reject(new FabricError("Error loading ".concat(img.src)))},crossOrigin&&(img.crossOrigin=crossOrigin),img.src=url):done()}))},enlivenObjects=function(objects){let{signal,reviver=noop}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return new Promise(((resolve,reject)=>{const instances=[];signal&&signal.addEventListener("abort",reject,{once:!0}),Promise.all(objects.map((obj=>classRegistry.getClass(obj.type).fromObject(obj,{signal}).then((fabricInstance=>(reviver(obj,fabricInstance),instances.push(fabricInstance),fabricInstance)))))).then(resolve).catch((error=>{instances.forEach((instance=>{instance.dispose&&instance.dispose()})),reject(error)})).finally((()=>{signal&&signal.removeEventListener("abort",reject)}))}))},enlivenObjectEnlivables=function(serializedObject){let{signal}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return new Promise(((resolve,reject)=>{const instances=[];signal&&signal.addEventListener("abort",reject,{once:!0});const promises=Object.values(serializedObject).map((value=>value?value.colorStops?new(classRegistry.getClass("gradient"))(value):value.type?enlivenObjects([value],{signal}).then((_ref=>{let[enlived]=_ref;return instances.push(enlived),enlived})):value.source?classRegistry.getClass("pattern").fromObject(value,{signal}).then((pattern=>(instances.push(pattern),pattern))):value:value)),keys=Object.keys(serializedObject);Promise.all(promises).then((enlived=>enlived.reduce(((acc,instance,index)=>(acc[keys[index]]=instance,acc)),{}))).then(resolve).catch((error=>{instances.forEach((instance=>{instance.dispose&&instance.dispose()})),reject(error)})).finally((()=>{signal&&signal.removeEventListener("abort",reject)}))}))},pick=function(source){return(arguments.length>1&&void 0!==arguments[1]?arguments[1]:[]).reduce(((o,key)=>(key in source&&(o[key]=source[key]),o)),{})},pickBy=(source,predicate)=>Object.keys(source).reduce(((o,key)=>(predicate(source[key],key,source)&&(o[key]=source[key]),o)),{}),ColorNameMap={aliceblue:"#F0F8FF",antiquewhite:"#FAEBD7",aqua:"#0FF",aquamarine:"#7FFFD4",azure:"#F0FFFF",beige:"#F5F5DC",bisque:"#FFE4C4",black:"#000",blanchedalmond:"#FFEBCD",blue:"#00F",blueviolet:"#8A2BE2",brown:"#A52A2A",burlywood:"#DEB887",cadetblue:"#5F9EA0",chartreuse:"#7FFF00",chocolate:"#D2691E",coral:"#FF7F50",cornflowerblue:"#6495ED",cornsilk:"#FFF8DC",crimson:"#DC143C",cyan:"#0FF",darkblue:"#00008B",darkcyan:"#008B8B",darkgoldenrod:"#B8860B",darkgray:"#A9A9A9",darkgrey:"#A9A9A9",darkgreen:"#006400",darkkhaki:"#BDB76B",darkmagenta:"#8B008B",darkolivegreen:"#556B2F",darkorange:"#FF8C00",darkorchid:"#9932CC",darkred:"#8B0000",darksalmon:"#E9967A",darkseagreen:"#8FBC8F",darkslateblue:"#483D8B",darkslategray:"#2F4F4F",darkslategrey:"#2F4F4F",darkturquoise:"#00CED1",darkviolet:"#9400D3",deeppink:"#FF1493",deepskyblue:"#00BFFF",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1E90FF",firebrick:"#B22222",floralwhite:"#FFFAF0",forestgreen:"#228B22",fuchsia:"#F0F",gainsboro:"#DCDCDC",ghostwhite:"#F8F8FF",gold:"#FFD700",goldenrod:"#DAA520",gray:"#808080",grey:"#808080",green:"#008000",greenyellow:"#ADFF2F",honeydew:"#F0FFF0",hotpink:"#FF69B4",indianred:"#CD5C5C",indigo:"#4B0082",ivory:"#FFFFF0",khaki:"#F0E68C",lavender:"#E6E6FA",lavenderblush:"#FFF0F5",lawngreen:"#7CFC00",lemonchiffon:"#FFFACD",lightblue:"#ADD8E6",lightcoral:"#F08080",lightcyan:"#E0FFFF",lightgoldenrodyellow:"#FAFAD2",lightgray:"#D3D3D3",lightgrey:"#D3D3D3",lightgreen:"#90EE90",lightpink:"#FFB6C1",lightsalmon:"#FFA07A",lightseagreen:"#20B2AA",lightskyblue:"#87CEFA",lightslategray:"#789",lightslategrey:"#789",lightsteelblue:"#B0C4DE",lightyellow:"#FFFFE0",lime:"#0F0",limegreen:"#32CD32",linen:"#FAF0E6",magenta:"#F0F",maroon:"#800000",mediumaquamarine:"#66CDAA",mediumblue:"#0000CD",mediumorchid:"#BA55D3",mediumpurple:"#9370DB",mediumseagreen:"#3CB371",mediumslateblue:"#7B68EE",mediumspringgreen:"#00FA9A",mediumturquoise:"#48D1CC",mediumvioletred:"#C71585",midnightblue:"#191970",mintcream:"#F5FFFA",mistyrose:"#FFE4E1",moccasin:"#FFE4B5",navajowhite:"#FFDEAD",navy:"#000080",oldlace:"#FDF5E6",olive:"#808000",olivedrab:"#6B8E23",orange:"#FFA500",orangered:"#FF4500",orchid:"#DA70D6",palegoldenrod:"#EEE8AA",palegreen:"#98FB98",paleturquoise:"#AFEEEE",palevioletred:"#DB7093",papayawhip:"#FFEFD5",peachpuff:"#FFDAB9",peru:"#CD853F",pink:"#FFC0CB",plum:"#DDA0DD",powderblue:"#B0E0E6",purple:"#800080",rebeccapurple:"#639",red:"#F00",rosybrown:"#BC8F8F",royalblue:"#4169E1",saddlebrown:"#8B4513",salmon:"#FA8072",sandybrown:"#F4A460",seagreen:"#2E8B57",seashell:"#FFF5EE",sienna:"#A0522D",silver:"#C0C0C0",skyblue:"#87CEEB",slateblue:"#6A5ACD",slategray:"#708090",slategrey:"#708090",snow:"#FFFAFA",springgreen:"#00FF7F",steelblue:"#4682B4",tan:"#D2B48C",teal:"#008080",thistle:"#D8BFD8",tomato:"#FF6347",turquoise:"#40E0D0",violet:"#EE82EE",wheat:"#F5DEB3",white:"#FFF",whitesmoke:"#F5F5F5",yellow:"#FF0",yellowgreen:"#9ACD32"},hue2rgb=(p,q,t)=>(t<0&&(t+=1),t>1&&(t-=1),t<1/6?p+6*(q-p)*t:t<.5?q:t<2/3?p+(q-p)*(2/3-t)*6:p),rgb2Hsl=(r,g,b,a)=>{r/=255,g/=255,b/=255;const maxValue=Math.max(r,g,b),minValue=Math.min(r,g,b);let h,s;const l=(maxValue+minValue)/2;if(maxValue===minValue)h=s=0;else{const d=maxValue-minValue;switch(s=l>.5?d/(2-maxValue-minValue):d/(maxValue+minValue),maxValue){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4}h/=6}return[Math.round(360*h),Math.round(100*s),Math.round(100*l),a]},fromAlphaToFloat=function(){let value=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"1";return parseFloat(value)/(value.endsWith("%")?100:1)},hexify=value=>Math.min(Math.round(value),255).toString(16).toUpperCase().padStart(2,"0"),greyAverage=_ref=>{let[r,g,b,a=1]=_ref;const avg=Math.round(.3*r+.59*g+.11*b);return[avg,avg,avg,a]};class Color{constructor(color){if(color)if(color instanceof Color)this.setSource([...color._source]);else if(Array.isArray(color)){const[r,g,b,a=1]=color;this.setSource([r,g,b,a])}else this.setSource(this._tryParsingColor(color));else this.setSource([0,0,0,1])}_tryParsingColor(color){return color in ColorNameMap&&(color=ColorNameMap[color]),"transparent"===color?[255,255,255,0]:Color.sourceFromHex(color)||Color.sourceFromRgb(color)||Color.sourceFromHsl(color)||[0,0,0,1]}getSource(){return this._source}setSource(source){this._source=source}toRgb(){const[r,g,b]=this.getSource();return"rgb(".concat(r,",").concat(g,",").concat(b,")")}toRgba(){return"rgba(".concat(this.getSource().join(","),")")}toHsl(){const[h,s,l]=rgb2Hsl(...this.getSource());return"hsl(".concat(h,",").concat(s,"%,").concat(l,"%)")}toHsla(){const[h,s,l,a]=rgb2Hsl(...this.getSource());return"hsla(".concat(h,",").concat(s,"%,").concat(l,"%,").concat(a,")")}toHex(){return this.toHexa().slice(0,6)}toHexa(){const[r,g,b,a]=this.getSource();return"".concat(hexify(r)).concat(hexify(g)).concat(hexify(b)).concat(hexify(Math.round(255*a)))}getAlpha(){return this.getSource()[3]}setAlpha(alpha){return this._source[3]=alpha,this}toGrayscale(){return this.setSource(greyAverage(this.getSource())),this}toBlackWhite(threshold){const[average,,,a]=greyAverage(this.getSource()),bOrW=average<(threshold||127)?0:255;return this.setSource([bOrW,bOrW,bOrW,a]),this}overlayWith(otherColor){otherColor instanceof Color||(otherColor=new Color(otherColor));const source=this.getSource(),otherSource=otherColor.getSource(),[R,G,B]=source.map(((value,index)=>Math.round(.5*value+.5*otherSource[index])));return this.setSource([R,G,B,source[3]]),this}static fromRgb(color){return Color.fromRgba(color)}static fromRgba(color){return new Color(Color.sourceFromRgb(color))}static sourceFromRgb(color){const match=color.match(/^rgba?\(\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*[\s|,]\s*(\d{0,3}(?:\.\d+)?%?)\s*(?:\s*[,/]\s*(\d{0,3}(?:\.\d+)?%?)\s*)?\)$/i);if(match){const[r,g,b]=match.slice(1,4).map((value=>{const parsedValue=parseFloat(value);return value.endsWith("%")?Math.round(2.55*parsedValue):parsedValue}));return[r,g,b,fromAlphaToFloat(match[4])]}}static fromHsl(color){return Color.fromHsla(color)}static fromHsla(color){return new Color(Color.sourceFromHsl(color))}static sourceFromHsl(color){const match=color.match(/^hsla?\(\s*([+-]?\d{1,3})\s*[\s|,]\s*(\d{1,3}%)\s*[\s|,]\s*(\d{1,3}%)\s*(?:\s*[,/]\s*(\d*(?:\.\d+)?%?)\s*)?\)$/i);if(!match)return;const h=(parseFloat(match[1])%360+360)%360/360,s=parseFloat(match[2])/100,l=parseFloat(match[3])/100;let r,g,b;if(0===s)r=g=b=l;else{const q=l<=.5?l*(s+1):l+s-l*s,p=2*l-q;r=hue2rgb(p,q,h+1/3),g=hue2rgb(p,q,h),b=hue2rgb(p,q,h-1/3)}return[Math.round(255*r),Math.round(255*g),Math.round(255*b),fromAlphaToFloat(match[4])]}static fromHex(color){return new Color(Color.sourceFromHex(color))}static sourceFromHex(color){if(color.match(/^#?(([0-9a-f]){3,4}|([0-9a-f]{2}){3,4})$/i)){const value=color.slice(color.indexOf("#")+1);let expandedValue;expandedValue=value.length<=4?value.split("").map((hex=>hex+hex)):value.match(/.{2}/g);const[r,g,b,a=255]=expandedValue.map((hexCouple=>parseInt(hexCouple,16)));return[r,g,b,a/255]}}}const toFixed=(number,fractionDigits)=>parseFloat(Number(number).toFixed(fractionDigits)),parseUnit=function(value){let fontSize=arguments.length>1&&void 0!==arguments[1]?arguments[1]:DEFAULT_SVG_FONT_SIZE;const unit=/\D{0,2}$/.exec(value),number=parseFloat(value),dpi=config.DPI;switch(null==unit?void 0:unit[0]){case"mm":return number*dpi/25.4;case"cm":return number*dpi/2.54;case"in":return number*dpi;case"pt":return number*dpi/72;case"pc":return number*dpi/72*12;case"em":return number*fontSize;default:return number}},parsePreserveAspectRatioAttribute=attribute=>{const[firstPart,secondPart]=attribute.trim().split(" "),[alignX,alignY]=(align=firstPart)&&align!==NONE?[align.slice(1,4),align.slice(5,8)]:align===NONE?[align,align]:["Mid","Mid"];var align;return{meetOrSlice:secondPart||"meet",alignX,alignY}},matrixToSVG=transform=>"matrix("+transform.map((value=>toFixed(value,config.NUM_FRACTION_DIGITS))).join(" ")+")",colorPropToSVG=function(prop,value){let colorValue,opacityValue,inlineStyle=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(value)if(value.toLive)colorValue="url(#SVGID_".concat(value.id,")");else{const color=new Color(value),opacity=color.getAlpha();colorValue=color.toRgb(),1!==opacity&&(opacityValue=opacity.toString())}else colorValue="none";return inlineStyle?"".concat(prop,": ").concat(colorValue,"; ").concat(opacityValue?"".concat(prop,"-opacity: ").concat(opacityValue,"; "):""):"".concat(prop,'="').concat(colorValue,'" ').concat(opacityValue?"".concat(prop,'-opacity="').concat(opacityValue,'" '):"")},isFiller=filler=>!!filler&&void 0!==filler.toLive,isSerializableFiller=filler=>!!filler&&"function"==typeof filler.toObject,isPattern=filler=>!!filler&&void 0!==filler.offsetX&&Object.hasOwn(filler,"source"),isTextObject=fabricObject=>!!fabricObject&&"function"==typeof fabricObject._renderText,isActiveSelection=fabricObject=>!!fabricObject&&Object.hasOwn(fabricObject,"multiSelectionStacking");function getScrollLeftTop(element){const doc=element&&getDocumentFromElement(element);let left=0,top=0;if(!element||!doc)return{left,top};const docElement=doc.documentElement,body=doc.body||{scrollLeft:0,scrollTop:0};for(;element&&(element.parentNode||element.host)&&((element=element.parentNode||element.host)===doc?(left=body.scrollLeft||docElement.scrollLeft||0,top=body.scrollTop||docElement.scrollTop||0):(left+=element.scrollLeft||0,top+=element.scrollTop||0),1!==element.nodeType||"fixed"!==element.style.position););return{left,top}}const getDocumentFromElement=el=>el.ownerDocument||null,getWindowFromElement=el=>{var _el$ownerDocument;return(null===(_el$ownerDocument=el.ownerDocument)||void 0===_el$ownerDocument?void 0:_el$ownerDocument.defaultView)||null};function setStyle(element,styles){const elementStyle=element.style;elementStyle&&("string"==typeof styles?element.style.cssText+=";"+styles:Object.entries(styles).forEach((_ref=>{let[property,value]=_ref;return elementStyle.setProperty(property,value)})))}const setCanvasDimensions=function(el,ctx,_ref){let{width,height}=_ref,retinaScaling=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;el.width=width,el.height=height,retinaScaling>1&&(el.setAttribute("width",(width*retinaScaling).toString()),el.setAttribute("height",(height*retinaScaling).toString()),ctx.scale(retinaScaling,retinaScaling))};const setCSSDimensions=(el,_ref2)=>{let{width,height}=_ref2;width&&(el.style.width="number"==typeof width?"".concat(width,"px"):width),height&&(el.style.height="number"==typeof height?"".concat(height,"px"):height)};function makeElementUnselectable(element){return void 0!==element.onselectstart&&(element.onselectstart=()=>!1),element.style.userSelect=NONE,element}class StaticCanvasDOMManager{constructor(arg0){_defineProperty(this,"_originalCanvasStyle",void 0),_defineProperty(this,"lower",void 0);const el=this.createLowerCanvas(arg0);this.lower={el,ctx:el.getContext("2d")}}createLowerCanvas(arg0){const el=(canvas=arg0)&&void 0!==canvas.getContext?arg0:arg0&&getFabricDocument().getElementById(arg0)||createCanvasElement();var canvas;if(el.hasAttribute("data-fabric"))throw new FabricError("Trying to initialize a canvas that has already been initialized. Did you forget to dispose the canvas?");return this._originalCanvasStyle=el.style.cssText,el.setAttribute("data-fabric","main"),el.classList.add("lower-canvas"),el}cleanupDOM(_ref){let{width,height}=_ref;const{el}=this.lower;el.classList.remove("lower-canvas"),el.removeAttribute("data-fabric"),el.setAttribute("width","".concat(width)),el.setAttribute("height","".concat(height)),el.style.cssText=this._originalCanvasStyle||"",this._originalCanvasStyle=void 0}setDimensions(size,retinaScaling){const{el,ctx}=this.lower;setCanvasDimensions(el,ctx,size,retinaScaling)}setCSSDimensions(size){setCSSDimensions(this.lower.el,size)}calcOffset(){return function getElementOffset(element){var _getWindowFromElement;let box={left:0,top:0};const doc=element&&getDocumentFromElement(element),offset={left:0,top:0},offsetAttributes={borderLeftWidth:LEFT,borderTopWidth:TOP,paddingLeft:LEFT,paddingTop:TOP};if(!doc)return offset;const elemStyle=(null===(_getWindowFromElement=getWindowFromElement(element))||void 0===_getWindowFromElement?void 0:_getWindowFromElement.getComputedStyle(element,null))||{};for(const attr in offsetAttributes)offset[offsetAttributes[attr]]+=parseInt(elemStyle[attr],10)||0;const docElem=doc.documentElement;void 0!==element.getBoundingClientRect&&(box=element.getBoundingClientRect());const scrollLeftTop=getScrollLeftTop(element);return{left:box.left+scrollLeftTop.left-(docElem.clientLeft||0)+offset.left,top:box.top+scrollLeftTop.top-(docElem.clientTop||0)+offset.top}}(this.lower.el)}dispose(){getEnv().dispose(this.lower.el),delete this.lower}}const staticCanvasDefaults={backgroundVpt:!0,backgroundColor:"",overlayVpt:!0,overlayColor:"",includeDefaultValues:!0,svgViewportTransformation:!0,renderOnAddRemove:!0,skipOffscreen:!0,enableRetinaScaling:!0,imageSmoothingEnabled:!0,controlsAboveOverlay:!1,allowTouchScrolling:!1,viewportTransform:[...iMatrix]};class StaticCanvas extends(createCollectionMixin(CommonMethods)){get lowerCanvasEl(){var _this$elements$lower;return null===(_this$elements$lower=this.elements.lower)||void 0===_this$elements$lower?void 0:_this$elements$lower.el}get contextContainer(){var _this$elements$lower2;return null===(_this$elements$lower2=this.elements.lower)||void 0===_this$elements$lower2?void 0:_this$elements$lower2.ctx}static getDefaults(){return StaticCanvas.ownDefaults}constructor(el){let options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),Object.assign(this,this.constructor.getDefaults()),this.set(options),this.initElements(el),this._setDimensionsImpl({width:this.width||this.elements.lower.el.width||0,height:this.height||this.elements.lower.el.height||0}),this.viewportTransform=[...this.viewportTransform],this.calcViewportBoundaries()}initElements(el){this.elements=new StaticCanvasDOMManager(el)}add(){const size=super.add(...arguments);return arguments.length>0&&this.renderOnAddRemove&&this.requestRenderAll(),size}insertAt(index){for(var _len=arguments.length,objects=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)objects[_key-1]=arguments[_key];const size=super.insertAt(index,...objects);return objects.length>0&&this.renderOnAddRemove&&this.requestRenderAll(),size}remove(){const removed=super.remove(...arguments);return removed.length>0&&this.renderOnAddRemove&&this.requestRenderAll(),removed}_onObjectAdded(obj){obj.canvas&&obj.canvas!==this&&(log("warn","Canvas is trying to add an object that belongs to a different canvas.\nResulting to default behavior: removing object from previous canvas and adding to new canvas"),obj.canvas.remove(obj)),obj._set("canvas",this),obj.setCoords(),this.fire("object:added",{target:obj}),obj.fire("added",{target:this})}_onObjectRemoved(obj){obj._set("canvas",void 0),this.fire("object:removed",{target:obj}),obj.fire("removed",{target:this})}_onStackOrderChanged(){this.renderOnAddRemove&&this.requestRenderAll()}getRetinaScaling(){return this.enableRetinaScaling?getDevicePixelRatio():1}calcOffset(){return this._offset=this.elements.calcOffset()}getWidth(){return this.width}getHeight(){return this.height}setWidth(value){let options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.setDimensions({width:value},options)}setHeight(value){let options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.setDimensions({height:value},options)}_setDimensionsImpl(dimensions){let{cssOnly=!1,backstoreOnly=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!cssOnly){const size=_objectSpread2({width:this.width,height:this.height},dimensions);this.elements.setDimensions(size,this.getRetinaScaling()),this.hasLostContext=!0,this.width=size.width,this.height=size.height}backstoreOnly||this.elements.setCSSDimensions(dimensions),this.calcOffset()}setDimensions(dimensions){let{cssOnly=!1,backstoreOnly=!1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this._setDimensionsImpl(dimensions,{cssOnly,backstoreOnly}),cssOnly||this.requestRenderAll()}getZoom(){return this.viewportTransform[0]}setViewportTransform(vpt){const backgroundObject=this.backgroundImage,overlayObject=this.overlayImage,len=this._objects.length;this.viewportTransform=vpt;for(let i=0;i<len;i++){const object=this._objects[i];object.group||object.setCoords()}backgroundObject&&backgroundObject.setCoords(),overlayObject&&overlayObject.setCoords(),this.calcViewportBoundaries(),this.renderOnAddRemove&&this.requestRenderAll()}zoomToPoint(point,value){const before=point,vpt=[...this.viewportTransform],newPoint=transformPoint(point,invertTransform(vpt));vpt[0]=value,vpt[3]=value;const after=transformPoint(newPoint,vpt);vpt[4]+=before.x-after.x,vpt[5]+=before.y-after.y,this.setViewportTransform(vpt)}setZoom(value){this.zoomToPoint(new Point(0,0),value)}absolutePan(point){const vpt=[...this.viewportTransform];return vpt[4]=-point.x,vpt[5]=-point.y,this.setViewportTransform(vpt)}relativePan(point){return this.absolutePan(new Point(-point.x-this.viewportTransform[4],-point.y-this.viewportTransform[5]))}getElement(){return this.elements.lower.el}clearContext(ctx){ctx.clearRect(0,0,this.width,this.height)}getContext(){return this.elements.lower.ctx}clear(){this.remove(...this.getObjects()),this.backgroundImage=void 0,this.overlayImage=void 0,this.backgroundColor="",this.overlayColor="",this.clearContext(this.getContext()),this.fire("canvas:cleared"),this.renderOnAddRemove&&this.requestRenderAll()}renderAll(){this.cancelRequestedRender(),this.destroyed||this.renderCanvas(this.getContext(),this._objects)}renderAndReset(){this.nextRenderHandle=0,this.renderAll()}requestRenderAll(){this.nextRenderHandle||this.disposed||this.destroyed||(this.nextRenderHandle=requestAnimFrame((()=>this.renderAndReset())))}calcViewportBoundaries(){const width=this.width,height=this.height,iVpt=invertTransform(this.viewportTransform),a=transformPoint({x:0,y:0},iVpt),b=transformPoint({x:width,y:height},iVpt),min=a.min(b),max=a.max(b);return this.vptCoords={tl:min,tr:new Point(max.x,min.y),bl:new Point(min.x,max.y),br:max}}cancelRequestedRender(){this.nextRenderHandle&&(cancelAnimFrame(this.nextRenderHandle),this.nextRenderHandle=0)}drawControls(ctx){}renderCanvas(ctx,objects){if(this.destroyed)return;const v=this.viewportTransform,path=this.clipPath;this.calcViewportBoundaries(),this.clearContext(ctx),ctx.imageSmoothingEnabled=this.imageSmoothingEnabled,ctx.patternQuality="best",this.fire("before:render",{ctx}),this._renderBackground(ctx),ctx.save(),ctx.transform(v[0],v[1],v[2],v[3],v[4],v[5]),this._renderObjects(ctx,objects),ctx.restore(),this.controlsAboveOverlay||this.drawControls(ctx),path&&(path._set("canvas",this),path.shouldCache(),path._transformDone=!0,path.renderCache({forClipping:!0}),this.drawClipPathOnCanvas(ctx,path)),this._renderOverlay(ctx),this.controlsAboveOverlay&&this.drawControls(ctx),this.fire("after:render",{ctx}),this.__cleanupTask&&(this.__cleanupTask(),this.__cleanupTask=void 0)}drawClipPathOnCanvas(ctx,clipPath){const v=this.viewportTransform;ctx.save(),ctx.transform(...v),ctx.globalCompositeOperation="destination-in",clipPath.transform(ctx),ctx.scale(1/clipPath.zoomX,1/clipPath.zoomY),ctx.drawImage(clipPath._cacheCanvas,-clipPath.cacheTranslationX,-clipPath.cacheTranslationY),ctx.restore()}_renderObjects(ctx,objects){for(let i=0,len=objects.length;i<len;++i)objects[i]&&objects[i].render(ctx)}_renderBackgroundOrOverlay(ctx,property){const fill=this["".concat(property,"Color")],object=this["".concat(property,"Image")],v=this.viewportTransform,needsVpt=this["".concat(property,"Vpt")];if(!fill&&!object)return;const isAFiller=isFiller(fill);if(fill){if(ctx.save(),ctx.beginPath(),ctx.moveTo(0,0),ctx.lineTo(this.width,0),ctx.lineTo(this.width,this.height),ctx.lineTo(0,this.height),ctx.closePath(),ctx.fillStyle=isAFiller?fill.toLive(ctx):fill,needsVpt&&ctx.transform(...v),isAFiller){ctx.transform(1,0,0,1,fill.offsetX||0,fill.offsetY||0);const m=fill.gradientTransform||fill.patternTransform;m&&ctx.transform(...m)}ctx.fill(),ctx.restore()}if(object){ctx.save();const{skipOffscreen}=this;this.skipOffscreen=needsVpt,needsVpt&&ctx.transform(...v),object.render(ctx),this.skipOffscreen=skipOffscreen,ctx.restore()}}_renderBackground(ctx){this._renderBackgroundOrOverlay(ctx,"background")}_renderOverlay(ctx){this._renderBackgroundOrOverlay(ctx,"overlay")}getCenter(){return{top:this.height/2,left:this.width/2}}getCenterPoint(){return new Point(this.width/2,this.height/2)}centerObjectH(object){return this._centerObject(object,new Point(this.getCenterPoint().x,object.getCenterPoint().y))}centerObjectV(object){return this._centerObject(object,new Point(object.getCenterPoint().x,this.getCenterPoint().y))}centerObject(object){return this._centerObject(object,this.getCenterPoint())}viewportCenterObject(object){return this._centerObject(object,this.getVpCenter())}viewportCenterObjectH(object){return this._centerObject(object,new Point(this.getVpCenter().x,object.getCenterPoint().y))}viewportCenterObjectV(object){return this._centerObject(object,new Point(object.getCenterPoint().x,this.getVpCenter().y))}getVpCenter(){return transformPoint(this.getCenterPoint(),invertTransform(this.viewportTransform))}_centerObject(object,center){object.setXY(center,CENTER,CENTER),object.setCoords(),this.renderOnAddRemove&&this.requestRenderAll()}toDatalessJSON(propertiesToInclude){return this.toDatalessObject(propertiesToInclude)}toObject(propertiesToInclude){return this._toObjectMethod("toObject",propertiesToInclude)}toJSON(){return this.toObject()}toDatalessObject(propertiesToInclude){return this._toObjectMethod("toDatalessObject",propertiesToInclude)}_toObjectMethod(methodName,propertiesToInclude){const clipPath=this.clipPath,clipPathData=clipPath&&!clipPath.excludeFromExport?this._toObject(clipPath,methodName,propertiesToInclude):null;return _objectSpread2(_objectSpread2(_objectSpread2({version:"6.0.0-beta18"},pick(this,propertiesToInclude)),{},{objects:this._objects.filter((object=>!object.excludeFromExport)).map((instance=>this._toObject(instance,methodName,propertiesToInclude)))},this.__serializeBgOverlay(methodName,propertiesToInclude)),clipPathData?{clipPath:clipPathData}:null)}_toObject(instance,methodName,propertiesToInclude){let originalValue;this.includeDefaultValues||(originalValue=instance.includeDefaultValues,instance.includeDefaultValues=!1);const object=instance[methodName](propertiesToInclude);return this.includeDefaultValues||(instance.includeDefaultValues=!!originalValue),object}__serializeBgOverlay(methodName,propertiesToInclude){const data={},bgImage=this.backgroundImage,overlayImage=this.overlayImage,bgColor=this.backgroundColor,overlayColor=this.overlayColor;return isFiller(bgColor)?bgColor.excludeFromExport||(data.background=bgColor.toObject(propertiesToInclude)):bgColor&&(data.background=bgColor),isFiller(overlayColor)?overlayColor.excludeFromExport||(data.overlay=overlayColor.toObject(propertiesToInclude)):overlayColor&&(data.overlay=overlayColor),bgImage&&!bgImage.excludeFromExport&&(data.backgroundImage=this._toObject(bgImage,methodName,propertiesToInclude)),overlayImage&&!overlayImage.excludeFromExport&&(data.overlayImage=this._toObject(overlayImage,methodName,propertiesToInclude)),data}toSVG(){let options=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},reviver=arguments.length>1?arguments[1]:void 0;options.reviver=reviver;const markup=[];return this._setSVGPreamble(markup,options),this._setSVGHeader(markup,options),this.clipPath&&markup.push('<g clip-path="url(#'.concat(this.clipPath.clipPathId,')" >\n')),this._setSVGBgOverlayColor(markup,"background"),this._setSVGBgOverlayImage(markup,"backgroundImage",reviver),this._setSVGObjects(markup,reviver),this.clipPath&&markup.push("</g>\n"),this._setSVGBgOverlayColor(markup,"overlay"),this._setSVGBgOverlayImage(markup,"overlayImage",reviver),markup.push("</svg>"),markup.join("")}_setSVGPreamble(markup,options){options.suppressPreamble||markup.push('<?xml version="1.0" encoding="',options.encoding||"UTF-8",'" standalone="no" ?>\n','<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ','"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n')}_setSVGHeader(markup,options){const width=options.width||"".concat(this.width),height=options.height||"".concat(this.height),NUM_FRACTION_DIGITS=config.NUM_FRACTION_DIGITS,optViewBox=options.viewBox;let viewBox;if(optViewBox)viewBox='viewBox="'.concat(optViewBox.x," ").concat(optViewBox.y," ").concat(optViewBox.width," ").concat(optViewBox.height,'" ');else if(this.svgViewportTransformation){const vpt=this.viewportTransform;viewBox='viewBox="'.concat(toFixed(-vpt[4]/vpt[0],NUM_FRACTION_DIGITS)," ").concat(toFixed(-vpt[5]/vpt[3],NUM_FRACTION_DIGITS)," ").concat(toFixed(this.width/vpt[0],NUM_FRACTION_DIGITS)," ").concat(toFixed(this.height/vpt[3],NUM_FRACTION_DIGITS),'" ')}else viewBox='viewBox="0 0 '.concat(this.width," ").concat(this.height,'" ');markup.push("<svg ",'xmlns="http://www.w3.org/2000/svg" ','xmlns:xlink="http://www.w3.org/1999/xlink" ','version="1.1" ','width="',width,'" ','height="',height,'" ',viewBox,'xml:space="preserve">\n',"<desc>Created with Fabric.js ","6.0.0-beta18","</desc>\n","<defs>\n",this.createSVGFontFacesMarkup(),this.createSVGRefElementsMarkup(),this.createSVGClipPathMarkup(options),"</defs>\n")}createSVGClipPathMarkup(options){const clipPath=this.clipPath;return clipPath?(clipPath.clipPathId="CLIPPATH_".concat(uid()),'<clipPath id="'.concat(clipPath.clipPathId,'" >\n').concat(clipPath.toClipPathSVG(options.reviver),"</clipPath>\n")):""}createSVGRefElementsMarkup(){return["background","overlay"].map((prop=>{const fill=this["".concat(prop,"Color")];if(isFiller(fill)){const shouldTransform=this["".concat(prop,"Vpt")],vpt=this.viewportTransform,object={isType:()=>!1,width:this.width/(shouldTransform?vpt[0]:1),height:this.height/(shouldTransform?vpt[3]:1)};return fill.toSVG(object,{additionalTransform:shouldTransform?matrixToSVG(vpt):""})}})).join("")}createSVGFontFacesMarkup(){const objects=[],fontList={},fontPaths=config.fontPaths;this._objects.forEach((function add(object){objects.push(object),isCollection(object)&&object._objects.forEach(add)})),objects.forEach((obj=>{if(!isTextObject(obj))return;const{styles,fontFamily}=obj;!fontList[fontFamily]&&fontPaths[fontFamily]&&(fontList[fontFamily]=!0,styles&&Object.values(styles).forEach((styleRow=>{Object.values(styleRow).forEach((_ref=>{let{fontFamily=""}=_ref;!fontList[fontFamily]&&fontPaths[fontFamily]&&(fontList[fontFamily]=!0)}))})))}));const fontListMarkup=Object.keys(fontList).map((fontFamily=>"\t\t@font-face {\n\t\t\tfont-family: '".concat(fontFamily,"';\n\t\t\tsrc: url('").concat(fontPaths[fontFamily],"');\n\t\t}\n"))).join("");return fontListMarkup?'\t<style type="text/css"><![CDATA[\n'.concat(fontListMarkup,"]]></style>\n"):""}_setSVGObjects(markup,reviver){this.forEachObject((fabricObject=>{fabricObject.excludeFromExport||this._setSVGObject(markup,fabricObject,reviver)}))}_setSVGObject(markup,instance,reviver){markup.push(instance.toSVG(reviver))}_setSVGBgOverlayImage(markup,property,reviver){const bgOrOverlay=this[property];bgOrOverlay&&!bgOrOverlay.excludeFromExport&&bgOrOverlay.toSVG&&markup.push(bgOrOverlay.toSVG(reviver))}_setSVGBgOverlayColor(markup,property){const filler=this["".concat(property,"Color")];if(filler)if(isFiller(filler)){const repeat=filler.repeat||"",finalWidth=this.width,finalHeight=this.height,additionalTransform=this["".concat(property,"Vpt")]?matrixToSVG(invertTransform(this.viewportTransform)):"";markup.push('<rect transform="'.concat(additionalTransform," translate(").concat(finalWidth/2,",").concat(finalHeight/2,')" x="').concat(filler.offsetX-finalWidth/2,'" y="').concat(filler.offsetY-finalHeight/2,'" width="').concat("repeat-y"!==repeat&&"no-repeat"!==repeat||!isPattern(filler)?finalWidth:filler.source.width,'" height="').concat("repeat-x"!==repeat&&"no-repeat"!==repeat||!isPattern(filler)?finalHeight:filler.source.height,'" fill="url(#SVGID_').concat(filler.id,')"></rect>\n'))}else markup.push('<rect x="0" y="0" width="100%" height="100%" ','fill="',filler,'"',"></rect>\n")}loadFromJSON(json,reviver){let{signal}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!json)return Promise.reject(new FabricError("`json` is undefined"));const serialized="string"==typeof json?JSON.parse(json):json,{objects=[],backgroundImage,background,overlayImage,overlay,clipPath}=serialized,renderOnAddRemove=this.renderOnAddRemove;return this.renderOnAddRemove=!1,Promise.all([enlivenObjects(objects,{reviver,signal}),enlivenObjectEnlivables({backgroundImage,backgroundColor:background,overlayImage,overlayColor:overlay,clipPath},{signal})]).then((_ref2=>{let[enlived,enlivedMap]=_ref2;return this.clear(),this.add(...enlived),this.set(serialized),this.set(enlivedMap),this.renderOnAddRemove=renderOnAddRemove,this}))}clone(properties){const data=this.toObject(properties);return this.cloneWithoutData().loadFromJSON(data)}cloneWithoutData(){const el=createCanvasElement();return el.width=this.width,el.height=this.height,new this.constructor(el)}toDataURL(){let options=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{format="png",quality=1,multiplier=1,enableRetinaScaling=!1}=options,finalMultiplier=multiplier*(enableRetinaScaling?this.getRetinaScaling():1);return toDataURL(this.toCanvasElement(finalMultiplier,options),format,quality)}toCanvasElement(){let multiplier=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,{width,height,left,top,filter}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const scaledWidth=(width||this.width)*multiplier,scaledHeight=(height||this.height)*multiplier,zoom=this.getZoom(),originalWidth=this.width,originalHeight=this.height,newZoom=zoom*multiplier,vp=this.viewportTransform,newVp=[newZoom,0,0,newZoom,(vp[4]-(left||0))*multiplier,(vp[5]-(top||0))*multiplier],originalRetina=this.enableRetinaScaling,canvasEl=createCanvasElement(),objectsToRender=filter?this._objects.filter((obj=>filter(obj))):this._objects;return canvasEl.width=scaledWidth,canvasEl.height=scaledHeight,this.enableRetinaScaling=!1,this.viewportTransform=newVp,this.width=scaledWidth,this.height=scaledHeight,this.calcViewportBoundaries(),this.renderCanvas(canvasEl.getContext("2d"),objectsToRender),this.viewportTransform=vp,this.width=originalWidth,this.height=originalHeight,this.calcViewportBoundaries(),this.enableRetinaScaling=originalRetina,canvasEl}dispose(){return!this.disposed&&this.elements.cleanupDOM({width:this.width,height:this.height}),runningAnimations.cancelByCanvas(this),this.disposed=!0,new Promise(((resolve,reject)=>{const task=()=>{this.destroy(),resolve(!0)};task.kill=reject,this.__cleanupTask&&this.__cleanupTask.kill("aborted"),this.destroyed?resolve(!1):this.nextRenderHandle?this.__cleanupTask=task:task()}))}destroy(){this.destroyed=!0,this.cancelRequestedRender(),this.forEachObject((object=>object.dispose())),this._objects=[],this.backgroundImage&&this.backgroundImage.dispose(),this.backgroundImage=void 0,this.overlayImage&&this.overlayImage.dispose(),this.overlayImage=void 0,this.elements.dispose()}toString(){return"#<Canvas (".concat(this.complexity(),"): { objects: ").concat(this._objects.length," }>")}}_defineProperty(StaticCanvas,"ownDefaults",staticCanvasDefaults);const touchEvents=["touchstart","touchmove","touchend"];const getPointer=event=>{const scroll=getScrollLeftTop(event.target),_evt=function getTouchInfo(event){const touchProp=event.changedTouches;return touchProp&&touchProp[0]?touchProp[0]:event}(event);return new Point(_evt.clientX+scroll.left,_evt.clientY+scroll.top)},isTouchEvent=event=>touchEvents.includes(event.type)||"touch"===event.pointerType,stopEvent=e=>{e.preventDefault(),e.stopPropagation()},makeBoundingBoxFromPoints=points=>{if(0===points.length)return{left:0,top:0,width:0,height:0};const{min,max}=points.reduce(((_ref,curr)=>{let{min,max}=_ref;return{min:min.min(curr),max:max.max(curr)}}),{min:new Point(points[0]),max:new Point(points[0])}),size=max.subtract(min);return{left:min.x,top:min.y,width:size.x,height:size.y}},_excluded$l=["translateX","translateY","scaleX","scaleY"],addTransformToObject=(object,transform)=>applyTransformToObject(object,multiplyTransformMatrices(transform,object.calcOwnMatrix())),applyTransformToObject=(object,transform)=>{const _qrDecompose=qrDecompose(transform),{translateX,translateY,scaleX,scaleY}=_qrDecompose,otherOptions=_objectWithoutProperties(_qrDecompose,_excluded$l),center=new Point(translateX,translateY);object.flipX=!1,object.flipY=!1,Object.assign(object,otherOptions),object.set({scaleX,scaleY}),object.setPositionByOrigin(center,CENTER,CENTER)},resetObjectTransform=target=>{target.scaleX=1,target.scaleY=1,target.skewX=0,target.skewY=0,target.flipX=!1,target.flipY=!1,target.rotate(0)},saveObjectTransform=target=>({scaleX:target.scaleX,scaleY:target.scaleY,skewX:target.skewX,skewY:target.skewY,angle:target.angle,left:target.left,flipX:target.flipX,flipY:target.flipY,top:target.top}),sizeAfterTransform=(width,height,t)=>{const dimX=width/2,dimY=height/2,points=[new Point(-dimX,-dimY),new Point(dimX,-dimY),new Point(-dimX,dimY),new Point(dimX,dimY)].map((p=>p.transform(t))),bbox=makeBoundingBoxFromPoints(points);return new Point(bbox.width,bbox.height)},calcPlaneChangeMatrix=function(){let from=arguments.length>0&&void 0!==arguments[0]?arguments[0]:iMatrix;return multiplyTransformMatrices(invertTransform(arguments.length>1&&void 0!==arguments[1]?arguments[1]:iMatrix),from)},sendPointToPlane=function(point){let from=arguments.length>1&&void 0!==arguments[1]?arguments[1]:iMatrix,to=arguments.length>2&&void 0!==arguments[2]?arguments[2]:iMatrix;return point.transform(calcPlaneChangeMatrix(from,to))},sendVectorToPlane=function(point){let from=arguments.length>1&&void 0!==arguments[1]?arguments[1]:iMatrix,to=arguments.length>2&&void 0!==arguments[2]?arguments[2]:iMatrix;return point.transform(calcPlaneChangeMatrix(from,to),!0)},sendObjectToPlane=(object,from,to)=>{const t=calcPlaneChangeMatrix(from,to);return applyTransformToObject(object,multiplyTransformMatrices(t,object.calcOwnMatrix())),t},fireEvent=(eventName,options)=>{var _target$canvas;const{transform:{target}}=options;null===(_target$canvas=target.canvas)||void 0===_target$canvas||_target$canvas.fire("object:".concat(eventName),_objectSpread2(_objectSpread2({},options),{},{target})),target.fire(eventName,options)},originOffset={left:-.5,top:-.5,center:0,bottom:.5,right:.5},resolveOrigin=originValue=>"string"==typeof originValue?originOffset[originValue]:originValue-.5;function isTransformCentered(transform){return transform.originX===CENTER&&transform.originY===CENTER}function invertOrigin(origin){return.5-resolveOrigin(origin)}const isLocked=(target,lockingKey)=>target[lockingKey],commonEventInfo=(eventData,transform,x,y)=>({e:eventData,transform,pointer:new Point(x,y)});function findCornerQuadrant(fabricObject,control){const cornerAngle=fabricObject.getTotalAngle()+radiansToDegrees(Math.atan2(control.y,control.x))+360;return Math.round(cornerAngle%360/45)}function getLocalPoint(_ref,originX,originY,x,y){var _target$canvas;let{target,corner}=_ref;const control=target.controls[corner],zoom=(null===(_target$canvas=target.canvas)||void 0===_target$canvas?void 0:_target$canvas.getZoom())||1,padding=target.padding/zoom,localPoint=function normalizePoint(target,point,originX,originY){const center=target.getRelativeCenterPoint(),p=void 0!==originX&&void 0!==originY?target.translateToGivenOrigin(center,CENTER,CENTER,originX,originY):new Point(target.left,target.top);return(target.angle?point.rotate(-degreesToRadians(target.angle),center):point).subtract(p)}(target,new Point(x,y),originX,originY);return localPoint.x>=padding&&(localPoint.x-=padding),localPoint.x<=-padding&&(localPoint.x+=padding),localPoint.y>=padding&&(localPoint.y-=padding),localPoint.y<=padding&&(localPoint.y+=padding),localPoint.x-=control.offsetX,localPoint.y-=control.offsetY,localPoint}const dragHandler=(eventData,transform,x,y)=>{const{target,offsetX,offsetY}=transform,newLeft=x-offsetX,newTop=y-offsetY,moveX=!isLocked(target,"lockMovementX")&&target.left!==newLeft,moveY=!isLocked(target,"lockMovementY")&&target.top!==newTop;return moveX&&target.set(LEFT,newLeft),moveY&&target.set(TOP,newTop),(moveX||moveY)&&fireEvent("moving",commonEventInfo(eventData,transform,x,y)),moveX||moveY};class FabricObjectSVGExportMixin{getSvgStyles(skipShadow){const fillRule=this.fillRule?this.fillRule:"nonzero",strokeWidth=this.strokeWidth?this.strokeWidth:"0",strokeDashArray=this.strokeDashArray?this.strokeDashArray.join(" "):NONE,strokeDashOffset=this.strokeDashOffset?this.strokeDashOffset:"0",strokeLineCap=this.strokeLineCap?this.strokeLineCap:"butt",strokeLineJoin=this.strokeLineJoin?this.strokeLineJoin:"miter",strokeMiterLimit=this.strokeMiterLimit?this.strokeMiterLimit:"4",opacity=void 0!==this.opacity?this.opacity:"1",visibility=this.visible?"":" visibility: hidden;",filter=skipShadow?"":this.getSvgFilter(),fill=colorPropToSVG("fill",this.fill);return[colorPropToSVG("stroke",this.stroke),"stroke-width: ",strokeWidth,"; ","stroke-dasharray: ",strokeDashArray,"; ","stroke-linecap: ",strokeLineCap,"; ","stroke-dashoffset: ",strokeDashOffset,"; ","stroke-linejoin: ",strokeLineJoin,"; ","stroke-miterlimit: ",strokeMiterLimit,"; ",fill,"fill-rule: ",fillRule,"; ","opacity: ",opacity,";",filter,visibility].join("")}getSvgFilter(){return this.shadow?"filter: url(#SVGID_".concat(this.shadow.id,");"):""}getSvgCommons(){return[this.id?'id="'.concat(this.id,'" '):"",this.clipPath?'clip-path="url(#'.concat(this.clipPath.clipPathId,')" '):""].join("")}getSvgTransform(full){let additionalTransform=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";const transform=full?this.calcTransformMatrix():this.calcOwnMatrix(),svgTransform='transform="'.concat(matrixToSVG(transform));return"".concat(svgTransform).concat(additionalTransform,'" ')}_toSVG(reviver){return[""]}toSVG(reviver){return this._createBaseSVGMarkup(this._toSVG(reviver),{reviver})}toClipPathSVG(reviver){return"\t"+this._createBaseClipPathSVGMarkup(this._toSVG(reviver),{reviver})}_createBaseClipPathSVGMarkup(objectMarkup){let{reviver,additionalTransform=""}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const commonPieces=[this.getSvgTransform(!0,additionalTransform),this.getSvgCommons()].join(""),index=objectMarkup.indexOf("COMMON_PARTS");return objectMarkup[index]=commonPieces,reviver?reviver(objectMarkup.join("")):objectMarkup.join("")}_createBaseSVGMarkup(objectMarkup){let{noStyle,reviver,withShadow,additionalTransform}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const styleInfo=noStyle?"":'style="'.concat(this.getSvgStyles(),'" '),shadowInfo=withShadow?'style="'.concat(this.getSvgFilter(),'" '):"",clipPath=this.clipPath,vectorEffect=this.strokeUniform?'vector-effect="non-scaling-stroke" ':"",absoluteClipPath=clipPath&&clipPath.absolutePositioned,stroke=this.stroke,fill=this.fill,shadow=this.shadow,markup=[],index=objectMarkup.indexOf("COMMON_PARTS");let clipPathMarkup;clipPath&&(clipPath.clipPathId="CLIPPATH_".concat(uid()),clipPathMarkup='<clipPath id="'.concat(clipPath.clipPathId,'" >\n').concat(clipPath.toClipPathSVG(reviver),"</clipPath>\n")),absoluteClipPath&&markup.push("<g ",shadowInfo,this.getSvgCommons()," >\n"),markup.push("<g ",this.getSvgTransform(!1),absoluteClipPath?"":shadowInfo+this.getSvgCommons()," >\n");const commonPieces=[styleInfo,vectorEffect,noStyle?"":this.addPaintOrder()," ",additionalTransform?'transform="'.concat(additionalTransform,'" '):""].join("");return objectMarkup[index]=commonPieces,isFiller(fill)&&markup.push(fill.toSVG(this)),isFiller(stroke)&&markup.push(stroke.toSVG(this)),shadow&&markup.push(shadow.toSVG(this)),clipPath&&markup.push(clipPathMarkup),markup.push(objectMarkup.join("")),markup.push("</g>\n"),absoluteClipPath&&markup.push("</g>\n"),reviver?reviver(markup.join("")):markup.join("")}addPaintOrder(){return"fill"!==this.paintFirst?' paint-order="'.concat(this.paintFirst,'" '):""}}const normalize=(a,c,p,s)=>(a<Math.abs(c)?(a=c,s=p/4):s=0===c&&0===a?p/twoMathPi*Math.asin(1):p/twoMathPi*Math.asin(c/a),{a,c,p,s}),elastic=(a,s,p,t,d)=>a*Math.pow(2,10*(t-=1))*Math.sin((t*d-s)*twoMathPi/p),defaultEasing=(t,b,c,d)=>-c*Math.cos(t/d*halfPI)+c+b,easeOutBounce=(t,b,c,d)=>(t/=d)<1/2.75?c*(7.5625*t*t)+b:t<2/2.75?c*(7.5625*(t-=1.5/2.75)*t+.75)+b:t<2.5/2.75?c*(7.5625*(t-=2.25/2.75)*t+.9375)+b:c*(7.5625*(t-=2.625/2.75)*t+.984375)+b,easeInBounce=(t,b,c,d)=>c-easeOutBounce(d-t,0,c,d)+b;var easing=Object.freeze({__proto__:null,defaultEasing,easeInBack:function(t,b,c,d){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1.70158;return c*(t/=d)*t*((s+1)*t-s)+b},easeInBounce,easeInCirc:(t,b,c,d)=>-c*(Math.sqrt(1-(t/=d)*t)-1)+b,easeInCubic:(t,b,c,d)=>c*(t/d)**3+b,easeInElastic:(t,b,c,d)=>{const a=c;let p=0;if(0===t)return b;if(1===(t/=d))return b+c;p||(p=.3*d);const{a:normA,s:normS,p:normP}=normalize(a,c,p,1.70158);return-elastic(normA,normS,normP,t,d)+b},easeInExpo:(t,b,c,d)=>0===t?b:c*2**(10*(t/d-1))+b,easeInOutBack:function(t,b,c,d){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1.70158;return(t/=d/2)<1?c/2*(t*t*((1+(s*=1.525))*t-s))+b:c/2*((t-=2)*t*((1+(s*=1.525))*t+s)+2)+b},easeInOutBounce:(t,b,c,d)=>t<d/2?.5*easeInBounce(2*t,0,c,d)+b:.5*easeOutBounce(2*t-d,0,c,d)+.5*c+b,easeInOutCirc:(t,b,c,d)=>(t/=d/2)<1?-c/2*(Math.sqrt(1-t**2)-1)+b:c/2*(Math.sqrt(1-(t-=2)*t)+1)+b,easeInOutCubic:(t,b,c,d)=>(t/=d/2)<1?c/2*t**3+b:c/2*((t-2)**3+2)+b,easeInOutElastic:(t,b,c,d)=>{const a=c;let p=0;if(0===t)return b;if(2===(t/=d/2))return b+c;p||(p=d*(.3*1.5));const{a:normA,s:normS,p:normP,c:normC}=normalize(a,c,p,1.70158);return t<1?-.5*elastic(normA,normS,normP,t,d)+b:normA*Math.pow(2,-10*(t-=1))*Math.sin((t*d-normS)*twoMathPi/normP)*.5+normC+b},easeInOutExpo:(t,b,c,d)=>0===t?b:t===d?b+c:(t/=d/2)<1?c/2*2**(10*(t-1))+b:c/2*-(2**(-10*--t)+2)+b,easeInOutQuad:(t,b,c,d)=>(t/=d/2)<1?c/2*t**2+b:-c/2*(--t*(t-2)-1)+b,easeInOutQuart:(t,b,c,d)=>(t/=d/2)<1?c/2*t**4+b:-c/2*((t-=2)*t**3-2)+b,easeInOutQuint:(t,b,c,d)=>(t/=d/2)<1?c/2*t**5+b:c/2*((t-2)**5+2)+b,easeInOutSine:(t,b,c,d)=>-c/2*(Math.cos(Math.PI*t/d)-1)+b,easeInQuad:(t,b,c,d)=>c*(t/=d)*t+b,easeInQuart:(t,b,c,d)=>c*(t/=d)*t**3+b,easeInQuint:(t,b,c,d)=>c*(t/d)**5+b,easeInSine:(t,b,c,d)=>-c*Math.cos(t/d*halfPI)+c+b,easeOutBack:function(t,b,c,d){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1.70158;return c*((t=t/d-1)*t*((s+1)*t+s)+1)+b},easeOutBounce,easeOutCirc:(t,b,c,d)=>c*Math.sqrt(1-(t=t/d-1)*t)+b,easeOutCubic:(t,b,c,d)=>c*((t/d-1)**3+1)+b,easeOutElastic:(t,b,c,d)=>{const a=c;let p=0;if(0===t)return b;if(1===(t/=d))return b+c;p||(p=.3*d);const{a:normA,s:normS,p:normP,c:normC}=normalize(a,c,p,1.70158);return normA*2**(-10*t)*Math.sin((t*d-normS)*twoMathPi/normP)+normC+b},easeOutExpo:(t,b,c,d)=>t===d?b+c:c*-(2**(-10*t/d)+1)+b,easeOutQuad:(t,b,c,d)=>-c*(t/=d)*(t-2)+b,easeOutQuart:(t,b,c,d)=>-c*((t=t/d-1)*t**3-1)+b,easeOutQuint:(t,b,c,d)=>c*((t/d-1)**5+1)+b,easeOutSine:(t,b,c,d)=>c*Math.sin(t/d*halfPI)+b});const defaultAbort=()=>!1;class AnimationBase{constructor(_ref){let{startValue,byValue,duration=500,delay=0,easing=defaultEasing,onStart=noop,onChange=noop,onComplete=noop,abort=defaultAbort,target}=_ref;_defineProperty(this,"_state","pending"),_defineProperty(this,"durationProgress",0),_defineProperty(this,"valueProgress",0),this.tick=this.tick.bind(this),this.duration=duration,this.delay=delay,this.easing=easing,this._onStart=onStart,this._onChange=onChange,this._onComplete=onComplete,this._abort=abort,this.target=target,this.startValue=startValue,this.byValue=byValue,this.value=this.startValue,this.endValue=Object.freeze(this.calculate(this.duration).value)}get state(){return this._state}isDone(){return"aborted"===this._state||"completed"===this._state}start(){const firstTick=timestamp=>{"pending"===this._state&&(this.startTime=timestamp||+new Date,this._state="running",this._onStart(),this.tick(this.startTime))};this.register(),this.delay>0?setTimeout((()=>requestAnimFrame(firstTick)),this.delay):requestAnimFrame(firstTick)}tick(t){const durationMs=(t||+new Date)-this.startTime,boundDurationMs=Math.min(durationMs,this.duration);this.durationProgress=boundDurationMs/this.duration;const{value,valueProgress}=this.calculate(boundDurationMs);this.value=Object.freeze(value),this.valueProgress=valueProgress,"aborted"!==this._state&&(this._abort(this.value,this.valueProgress,this.durationProgress)?(this._state="aborted",this.unregister()):durationMs>=this.duration?(this.durationProgress=this.valueProgress=1,this._onChange(this.endValue,this.valueProgress,this.durationProgress),this._state="completed",this._onComplete(this.endValue,this.valueProgress,this.durationProgress),this.unregister()):(this._onChange(this.value,this.valueProgress,this.durationProgress),requestAnimFrame(this.tick)))}register(){runningAnimations.push(this)}unregister(){runningAnimations.remove(this)}abort(){this._state="aborted",this.unregister()}}const _excluded$k=["startValue","endValue"];class ValueAnimation extends AnimationBase{constructor(_ref){let{startValue=0,endValue=100}=_ref;super(_objectSpread2(_objectSpread2({},_objectWithoutProperties(_ref,_excluded$k)),{},{startValue,byValue:endValue-startValue}))}calculate(timeElapsed){const value=this.easing(timeElapsed,this.startValue,this.byValue,this.duration);return{value,valueProgress:Math.abs((value-this.startValue)/this.byValue)}}}const _excluded$j=["startValue","endValue"];class ArrayAnimation extends AnimationBase{constructor(_ref){let{startValue=[0],endValue=[100]}=_ref;super(_objectSpread2(_objectSpread2({},_objectWithoutProperties(_ref,_excluded$j)),{},{startValue,byValue:endValue.map(((value,i)=>value-startValue[i]))}))}calculate(timeElapsed){const values=this.startValue.map(((value,i)=>this.easing(timeElapsed,value,this.byValue[i],this.duration,i)));return{value:values,valueProgress:Math.abs((values[0]-this.startValue[0])/this.byValue[0])}}}const capValue=(min,value,max)=>Math.max(min,Math.min(value,max)),_excluded$i=["startValue","endValue","easing","onChange","onComplete","abort"],defaultColorEasing=(timeElapsed,startValue,byValue,duration)=>startValue+byValue*(1-Math.cos(timeElapsed/duration*halfPI)),wrapColorCallback=callback=>callback&&((rgba,valueProgress,durationProgress)=>callback(new Color(rgba).toRgba(),valueProgress,durationProgress));class ColorAnimation extends AnimationBase{constructor(_ref){let{startValue,endValue,easing=defaultColorEasing,onChange,onComplete,abort}=_ref,options=_objectWithoutProperties(_ref,_excluded$i);const startColor=new Color(startValue).getSource(),endColor=new Color(endValue).getSource();super(_objectSpread2(_objectSpread2({},options),{},{startValue:startColor,byValue:endColor.map(((value,i)=>value-startColor[i])),easing,onChange:wrapColorCallback(onChange),onComplete:wrapColorCallback(onComplete),abort:wrapColorCallback(abort)}))}calculate(timeElapsed){const[r,g,b,a]=this.startValue.map(((value,i)=>this.easing(timeElapsed,value,this.byValue[i],this.duration,i))),value=[...[r,g,b].map(Math.round),capValue(0,a,1)];return{value,valueProgress:value.map(((p,i)=>0!==this.byValue[i]?Math.abs((p-this.startValue[i])/this.byValue[i]):0)).find((p=>0!==p))||0}}}function animate(options){const animation=(options=>Array.isArray(options.startValue)||Array.isArray(options.endValue))(options)?new ArrayAnimation(options):new ValueAnimation(options);return animation.start(),animation}function animateColor(options){const animation=new ColorAnimation(options);return animation.start(),animation}const unitVectorX=new Point(1,0),zero=new Point,rotateVector=(vector,radians)=>vector.rotate(radians),createVector=(from,to)=>new Point(to).subtract(from),magnitude=point=>point.distanceFrom(zero),calcAngleBetweenVectors=(a,b)=>Math.atan2(crossProduct(a,b),dotProduct(a,b)),calcVectorRotation=v=>calcAngleBetweenVectors(unitVectorX,v),getUnitVector=v=>v.eq(zero)?v:v.scalarDivide(magnitude(v)),getOrthonormalVector=function(v){let counterClockwise=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return getUnitVector(new Point(-v.y,v.x).scalarMultiply(counterClockwise?1:-1))},crossProduct=(a,b)=>a.x*b.y-a.y*b.x,dotProduct=(a,b)=>a.x*b.x+a.y*b.y,isBetweenVectors=(t,a,b)=>{if(t.eq(a)||t.eq(b))return!0;const AxB=crossProduct(a,b),AxT=crossProduct(a,t),BxT=crossProduct(b,t);return AxB>=0?AxT>=0&&BxT<=0:!(AxT<=0&&BxT>=0)};class Intersection{constructor(status){this.status=status,this.points=[]}includes(point){return this.points.some((p=>p.eq(point)))}append(){for(var _len=arguments.length,points=new Array(_len),_key=0;_key<_len;_key++)points[_key]=arguments[_key];return this.points=this.points.concat(points.filter((point=>!this.includes(point)))),this}static isPointContained(T,A,B){let infinite=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(A.eq(B))return T.eq(A);if(A.x===B.x)return T.x===A.x&&(infinite||T.y>=Math.min(A.y,B.y)&&T.y<=Math.max(A.y,B.y));if(A.y===B.y)return T.y===A.y&&(infinite||T.x>=Math.min(A.x,B.x)&&T.x<=Math.max(A.x,B.x));{const AB=createVector(A,B),s=createVector(A,T).divide(AB);return infinite?Math.abs(s.x)===Math.abs(s.y):s.x===s.y&&s.x>=0&&s.x<=1}}static isPointInPolygon(point,points){const other=new Point(point).setX(Math.min(point.x-1,...points.map((p=>p.x))));let hits=0;for(let index=0;index<points.length;index++){const inter=this.intersectSegmentSegment(points[index],points[(index+1)%points.length],point,other);if(inter.includes(point))return!0;hits+=Number("Intersection"===inter.status)}return hits%2==1}static intersectLineLine(a1,a2,b1,b2){let aInfinite=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],bInfinite=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const a2xa1x=a2.x-a1.x,a2ya1y=a2.y-a1.y,b2xb1x=b2.x-b1.x,b2yb1y=b2.y-b1.y,a1xb1x=a1.x-b1.x,a1yb1y=a1.y-b1.y,uaT=b2xb1x*a1yb1y-b2yb1y*a1xb1x,ubT=a2xa1x*a1yb1y-a2ya1y*a1xb1x,uB=b2yb1y*a2xa1x-b2xb1x*a2ya1y;if(0!==uB){const ua=uaT/uB,ub=ubT/uB;return(aInfinite||0<=ua&&ua<=1)&&(bInfinite||0<=ub&&ub<=1)?new Intersection("Intersection").append(new Point(a1.x+ua*a2xa1x,a1.y+ua*a2ya1y)):new Intersection}if(0===uaT||0===ubT){const segmentsCoincide=aInfinite||bInfinite||Intersection.isPointContained(a1,b1,b2)||Intersection.isPointContained(a2,b1,b2)||Intersection.isPointContained(b1,a1,a2)||Intersection.isPointContained(b2,a1,a2);return new Intersection(segmentsCoincide?"Coincident":void 0)}return new Intersection("Parallel")}static intersectSegmentLine(s1,s2,l1,l2){return Intersection.intersectLineLine(s1,s2,l1,l2,!1,!0)}static intersectSegmentSegment(a1,a2,b1,b2){return Intersection.intersectLineLine(a1,a2,b1,b2,!1,!1)}static intersectLinePolygon(a1,a2,points){let infinite=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const result=new Intersection,length=points.length;for(let b1,b2,inter,i=0;i<length;i++){if(b1=points[i],b2=points[(i+1)%length],inter=Intersection.intersectLineLine(a1,a2,b1,b2,infinite,!1),"Coincident"===inter.status)return inter;result.append(...inter.points)}return result.points.length>0&&(result.status="Intersection"),result}static intersectSegmentPolygon(a1,a2,points){return Intersection.intersectLinePolygon(a1,a2,points,!1)}static intersectPolygonPolygon(points1,points2){const result=new Intersection,length=points1.length,coincidences=[];for(let i=0;i<length;i++){const a1=points1[i],a2=points1[(i+1)%length],inter=Intersection.intersectSegmentPolygon(a1,a2,points2);"Coincident"===inter.status?(coincidences.push(inter),result.append(a1,a2)):result.append(...inter.points)}return coincidences.length>0&&coincidences.length===points1.length?new Intersection("Coincident"):(result.points.length>0&&(result.status="Intersection"),result)}static intersectPolygonRectangle(points,r1,r2){const min=r1.min(r2),max=r1.max(r2),topRight=new Point(max.x,min.y),bottomLeft=new Point(min.x,max.y);return Intersection.intersectPolygonPolygon(points,[min,topRight,max,bottomLeft])}}class ObjectOrigin extends CommonMethods{_getTransformedDimensions(){let options=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const dimOptions=_objectSpread2({scaleX:this.scaleX,scaleY:this.scaleY,skewX:this.skewX,skewY:this.skewY,width:this.width,height:this.height,strokeWidth:this.strokeWidth},options),strokeWidth=dimOptions.strokeWidth;let preScalingStrokeValue=strokeWidth,postScalingStrokeValue=0;this.strokeUniform&&(preScalingStrokeValue=0,postScalingStrokeValue=strokeWidth);const dimX=dimOptions.width+preScalingStrokeValue,dimY=dimOptions.height+preScalingStrokeValue;let finalDimensions;return finalDimensions=0===dimOptions.skewX&&0===dimOptions.skewY?new Point(dimX*dimOptions.scaleX,dimY*dimOptions.scaleY):sizeAfterTransform(dimX,dimY,calcDimensionsMatrix(dimOptions)),finalDimensions.scalarAdd(postScalingStrokeValue)}translateToGivenOrigin(point,fromOriginX,fromOriginY,toOriginX,toOriginY){let x=point.x,y=point.y;const offsetX=resolveOrigin(toOriginX)-resolveOrigin(fromOriginX),offsetY=resolveOrigin(toOriginY)-resolveOrigin(fromOriginY);if(offsetX||offsetY){const dim=this._getTransformedDimensions();x+=offsetX*dim.x,y+=offsetY*dim.y}return new Point(x,y)}translateToCenterPoint(point,originX,originY){const p=this.translateToGivenOrigin(point,originX,originY,CENTER,CENTER);return this.angle?p.rotate(degreesToRadians(this.angle),point):p}translateToOriginPoint(center,originX,originY){const p=this.translateToGivenOrigin(center,CENTER,CENTER,originX,originY);return this.angle?p.rotate(degreesToRadians(this.angle),center):p}getCenterPoint(){const relCenter=this.getRelativeCenterPoint();return this.group?transformPoint(relCenter,this.group.calcTransformMatrix()):relCenter}getRelativeCenterPoint(){return this.translateToCenterPoint(new Point(this.left,this.top),this.originX,this.originY)}getPointByOrigin(originX,originY){return this.translateToOriginPoint(this.getRelativeCenterPoint(),originX,originY)}setPositionByOrigin(pos,originX,originY){const center=this.translateToCenterPoint(pos,originX,originY),position=this.translateToOriginPoint(center,this.originX,this.originY);this.set({left:position.x,top:position.y})}_getLeftTopCoords(){return this.translateToOriginPoint(this.getRelativeCenterPoint(),LEFT,TOP)}}class ObjectGeometry extends ObjectOrigin{getX(){return this.getXY().x}setX(value){this.setXY(this.getXY().setX(value))}getY(){return this.getXY().y}setY(value){this.setXY(this.getXY().setY(value))}getRelativeX(){return this.left}setRelativeX(value){this.left=value}getRelativeY(){return this.top}setRelativeY(value){this.top=value}getXY(){const relativePosition=this.getRelativeXY();return this.group?transformPoint(relativePosition,this.group.calcTransformMatrix()):relativePosition}setXY(point,originX,originY){this.group&&(point=transformPoint(point,invertTransform(this.group.calcTransformMatrix()))),this.setRelativeXY(point,originX,originY)}getRelativeXY(){return new Point(this.left,this.top)}setRelativeXY(point){let originX=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.originX,originY=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.originY;this.setPositionByOrigin(point,originX,originY)}isStrokeAccountedForInDimensions(){return!1}getCoords(){const{tl,tr,br,bl}=this.aCoords||(this.aCoords=this.calcACoords()),coords=[tl,tr,br,bl];if(this.group){const t=this.group.calcTransformMatrix();return coords.map((p=>transformPoint(p,t)))}return coords}intersectsWithRect(tl,br){return"Intersection"===Intersection.intersectPolygonRectangle(this.getCoords(),tl,br).status}intersectsWithObject(other){const intersection=Intersection.intersectPolygonPolygon(this.getCoords(),other.getCoords());return"Intersection"===intersection.status||"Coincident"===intersection.status||other.isContainedWithinObject(this)||this.isContainedWithinObject(other)}isContainedWithinObject(other){return this.getCoords().every((point=>other.containsPoint(point)))}isContainedWithinRect(tl,br){const{left,top,width,height}=this.getBoundingRect();return left>=tl.x&&left+width<=br.x&&top>=tl.y&&top+height<=br.y}isOverlapping(other){return this.intersectsWithObject(other)||this.isContainedWithinObject(other)||other.isContainedWithinObject(this)}containsPoint(point){return Intersection.isPointInPolygon(point,this.getCoords())}isOnScreen(){if(!this.canvas)return!1;const{tl,br}=this.canvas.vptCoords;return!!this.getCoords().some((point=>point.x<=br.x&&point.x>=tl.x&&point.y<=br.y&&point.y>=tl.y))||(!!this.intersectsWithRect(tl,br)||this.containsPoint(tl.midPointFrom(br)))}isPartiallyOnScreen(){if(!this.canvas)return!1;const{tl,br}=this.canvas.vptCoords;if(this.intersectsWithRect(tl,br))return!0;return this.getCoords().every((point=>(point.x>=br.x||point.x<=tl.x)&&(point.y>=br.y||point.y<=tl.y)))&&this.containsPoint(tl.midPointFrom(br))}getBoundingRect(){return makeBoundingBoxFromPoints(this.getCoords())}getScaledWidth(){return this._getTransformedDimensions().x}getScaledHeight(){return this._getTransformedDimensions().y}scale(value){this._set("scaleX",value),this._set("scaleY",value),this.setCoords()}scaleToWidth(value){const boundingRectFactor=this.getBoundingRect().width/this.getScaledWidth();return this.scale(value/this.width/boundingRectFactor)}scaleToHeight(value){const boundingRectFactor=this.getBoundingRect().height/this.getScaledHeight();return this.scale(value/this.height/boundingRectFactor)}getCanvasRetinaScaling(){var _this$canvas;return(null===(_this$canvas=this.canvas)||void 0===_this$canvas?void 0:_this$canvas.getRetinaScaling())||1}getTotalAngle(){return this.group?radiansToDegrees(calcPlaneRotation(this.calcTransformMatrix())):this.angle}getViewportTransform(){var _this$canvas2;return(null===(_this$canvas2=this.canvas)||void 0===_this$canvas2?void 0:_this$canvas2.viewportTransform)||iMatrix.concat()}calcACoords(){const rotateMatrix=createRotateMatrix({angle:this.angle}),{x,y}=this.getRelativeCenterPoint(),tMatrix=createTranslateMatrix(x,y),finalMatrix=multiplyTransformMatrices(tMatrix,rotateMatrix),dim=this._getTransformedDimensions(),w=dim.x/2,h=dim.y/2;return{tl:transformPoint({x:-w,y:-h},finalMatrix),tr:transformPoint({x:w,y:-h},finalMatrix),bl:transformPoint({x:-w,y:h},finalMatrix),br:transformPoint({x:w,y:h},finalMatrix)}}setCoords(){this.aCoords=this.calcACoords()}transformMatrixKey(){let skipGroup=arguments.length>0&&void 0!==arguments[0]&&arguments[0];let prefix="";return!skipGroup&&this.group&&(prefix=this.group.transformMatrixKey(skipGroup)+"_"),prefix+this.top+"_"+this.left+"_"+this.scaleX+"_"+this.scaleY+"_"+this.skewX+"_"+this.skewY+"_"+this.angle+"_"+this.originX+"_"+this.originY+"_"+this.width+"_"+this.height+"_"+this.strokeWidth+this.flipX+this.flipY}calcTransformMatrix(){let skipGroup=arguments.length>0&&void 0!==arguments[0]&&arguments[0],matrix=this.calcOwnMatrix();if(skipGroup||!this.group)return matrix;const key=this.transformMatrixKey(skipGroup),cache=this.matrixCache;return cache&&cache.key===key?cache.value:(this.group&&(matrix=multiplyTransformMatrices(this.group.calcTransformMatrix(!1),matrix)),this.matrixCache={key,value:matrix},matrix)}calcOwnMatrix(){const key=this.transformMatrixKey(!0),cache=this.ownMatrixCache;if(cache&&cache.key===key)return cache.value;const center=this.getRelativeCenterPoint(),options={angle:this.angle,translateX:center.x,translateY:center.y,scaleX:this.scaleX,scaleY:this.scaleY,skewX:this.skewX,skewY:this.skewY,flipX:this.flipX,flipY:this.flipY},value=composeMatrix(options);return this.ownMatrixCache={key,value},value}_getNonTransformedDimensions(){return new Point(this.width,this.height).scalarAdd(this.strokeWidth)}_calculateCurrentDimensions(options){return this._getTransformedDimensions(options).transform(this.getViewportTransform(),!0).scalarAdd(2*this.padding)}}class StackedObject extends ObjectGeometry{isDescendantOf(target){const{parent,group}=this;return parent===target||group===target||this.canvas===target||!!parent&&parent.isDescendantOf(target)||!!group&&group!==parent&&group.isDescendantOf(target)}getAncestors(strict){const ancestors=[];let parent=this;do{var _parent$parent;parent=parent instanceof StackedObject?null!==(_parent$parent=parent.parent)&&void 0!==_parent$parent?_parent$parent:strict?void 0:parent.canvas:void 0,parent&&ancestors.push(parent)}while(parent);return ancestors}findCommonAncestors(other,strict){if(this===other)return{fork:[],otherFork:[],common:[this,...this.getAncestors(strict)]};const ancestors=this.getAncestors(strict),otherAncestors=other.getAncestors(strict);if(0===ancestors.length&&otherAncestors.length>0&&this===otherAncestors[otherAncestors.length-1])return{fork:[],otherFork:[other,...otherAncestors.slice(0,otherAncestors.length-1)],common:[this]};for(let ancestor,i=0;i<ancestors.length;i++){if(ancestor=ancestors[i],ancestor===other)return{fork:[this,...ancestors.slice(0,i)],otherFork:[],common:ancestors.slice(i)};for(let j=0;j<otherAncestors.length;j++){if(this===otherAncestors[j])return{fork:[],otherFork:[other,...otherAncestors.slice(0,j)],common:[this,...ancestors]};if(ancestor===otherAncestors[j])return{fork:[this,...ancestors.slice(0,i)],otherFork:[other,...otherAncestors.slice(0,j)],common:ancestors.slice(i)}}}return{fork:[this,...ancestors],otherFork:[other,...otherAncestors],common:[]}}hasCommonAncestors(other,strict){const commonAncestors=this.findCommonAncestors(other,strict);return commonAncestors&&!!commonAncestors.common.length}isInFrontOf(other){if(this===other)return;const ancestorData=this.findCommonAncestors(other);if(!ancestorData)return;if(ancestorData.fork.includes(other))return!0;if(ancestorData.otherFork.includes(this))return!1;const firstCommonAncestor=ancestorData.common[0];if(!firstCommonAncestor)return;const headOfFork=ancestorData.fork.pop(),headOfOtherFork=ancestorData.otherFork.pop(),thisIndex=firstCommonAncestor._objects.indexOf(headOfFork),otherIndex=firstCommonAncestor._objects.indexOf(headOfOtherFork);return thisIndex>-1&&thisIndex>otherIndex}}class AnimatableObject extends StackedObject{animate(animatable,options){return Object.entries(animatable).reduce(((acc,_ref)=>{let[key,endValue]=_ref;return acc[key]=this._animate(key,endValue,options),acc}),{})}_animate(key,endValue){let options=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const path=key.split("."),propIsColor=this.constructor.colorProperties.includes(path[path.length-1]),{easing,duration,abort,startValue,onChange,onComplete}=options,animationOptions={target:this,startValue:null!=startValue?startValue:path.reduce(((deep,key)=>deep[key]),this),endValue,easing,duration,abort:null==abort?void 0:abort.bind(this),onChange:(value,valueProgress,durationProgress)=>{path.reduce(((deep,key,index)=>(index===path.length-1&&(deep[key]=value),deep[key])),this),onChange&&onChange(value,valueProgress,durationProgress)},onComplete:(value,valueProgress,durationProgress)=>{this.setCoords(),onComplete&&onComplete(value,valueProgress,durationProgress)}};return propIsColor?animateColor(animationOptions):animate(animationOptions)}}_defineProperty(AnimatableObject,"colorProperties",["fill","stroke","backgroundColor"]);class Shadow{constructor(arg0){const options="string"==typeof arg0?Shadow.parseShadow(arg0):arg0;Object.assign(this,this.constructor.ownDefaults);for(const prop in options)this[prop]=options[prop];this.id=uid()}static parseShadow(value){const shadowStr=value.trim(),[__,offsetX=0,offsetY=0,blur=0]=(Shadow.reOffsetsAndBlur.exec(shadowStr)||[]).map((value=>parseFloat(value)||0));return{color:(shadowStr.replace(Shadow.reOffsetsAndBlur,"")||"rgb(0,0,0)").trim(),offsetX,offsetY,blur}}toString(){return[this.offsetX,this.offsetY,this.blur,this.color].join("px ")}toSVG(object){const offset=rotateVector(new Point(this.offsetX,this.offsetY),degreesToRadians(-object.angle)),color=new Color(this.color);let fBoxX=40,fBoxY=40;return object.width&&object.height&&(fBoxX=100*toFixed((Math.abs(offset.x)+this.blur)/object.width,config.NUM_FRACTION_DIGITS)+20,fBoxY=100*toFixed((Math.abs(offset.y)+this.blur)/object.height,config.NUM_FRACTION_DIGITS)+20),object.flipX&&(offset.x*=-1),object.flipY&&(offset.y*=-1),'<filter id="SVGID_'.concat(this.id,'" y="-').concat(fBoxY,'%" height="').concat(100+2*fBoxY,'%" x="-').concat(fBoxX,'%" width="').concat(100+2*fBoxX,'%" >\n\t<feGaussianBlur in="SourceAlpha" stdDeviation="').concat(toFixed(this.blur?this.blur/2:0,config.NUM_FRACTION_DIGITS),'"></feGaussianBlur>\n\t<feOffset dx="').concat(toFixed(offset.x,config.NUM_FRACTION_DIGITS),'" dy="').concat(toFixed(offset.y,config.NUM_FRACTION_DIGITS),'" result="oBlur" ></feOffset>\n\t<feFlood flood-color="').concat(color.toRgb(),'" flood-opacity="').concat(color.getAlpha(),'"/>\n\t<feComposite in2="oBlur" operator="in" />\n\t<feMerge>\n\t\t<feMergeNode></feMergeNode>\n\t\t<feMergeNode in="SourceGraphic"></feMergeNode>\n\t</feMerge>\n</filter>\n')}toObject(){const data={color:this.color,blur:this.blur,offsetX:this.offsetX,offsetY:this.offsetY,affectStroke:this.affectStroke,nonScaling:this.nonScaling},defaults=Shadow.ownDefaults;return this.includeDefaultValues?data:pickBy(data,((value,key)=>value!==defaults[key]))}}_defineProperty(Shadow,"ownDefaults",{color:"rgb(0,0,0)",blur:0,offsetX:0,offsetY:0,affectStroke:!1,includeDefaultValues:!0,nonScaling:!1}),_defineProperty(Shadow,"reOffsetsAndBlur",/(?:\s|^)(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(\d+(?:\.\d*)?(?:px)?)?(?:\s?|$)(?:$|\s)/);const cloneDeep=object=>JSON.parse(JSON.stringify(object)),stateProperties=[TOP,LEFT,"scaleX","scaleY","flipX","flipY","originX","originY","angle","opacity","globalCompositeOperation","shadow","visible","skewX","skewY"],cacheProperties=["fill","stroke","strokeWidth","strokeDashArray","width","height","paintFirst","strokeUniform","strokeLineCap","strokeDashOffset","strokeLineJoin","strokeMiterLimit","backgroundColor","clipPath"],fabricObjectDefaultValues={top:0,left:0,width:0,height:0,angle:0,flipX:!1,flipY:!1,scaleX:1,scaleY:1,minScaleLimit:0,skewX:0,skewY:0,originX:LEFT,originY:TOP,strokeWidth:1,strokeUniform:!1,padding:0,opacity:1,paintFirst:"fill",fill:"rgb(0,0,0)",fillRule:"nonzero",stroke:null,strokeDashArray:null,strokeDashOffset:0,strokeLineCap:"butt",strokeLineJoin:"miter",strokeMiterLimit:4,globalCompositeOperation:"source-over",backgroundColor:"",shadow:null,visible:!0,includeDefaultValues:!0,excludeFromExport:!1,objectCaching:!0,clipPath:void 0,inverted:!1,absolutePositioned:!1,centeredRotation:!0,centeredScaling:!1,dirty:!0},_excluded$h=["type"],_excluded2$4=["extraParam"];let FabricObject$1=class FabricObject extends AnimatableObject{static getDefaults(){return _objectSpread2({},FabricObject.ownDefaults)}get type(){const name=this.constructor.type;return"FabricObject"===name?"object":name.toLowerCase()}set type(value){log("warn","Setting type has no effect",value)}constructor(){let options=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),_defineProperty(this,"_cacheContext",null),Object.assign(this,this.constructor.getDefaults()),this.setOptions(options)}_createCacheCanvas(){this._cacheCanvas=createCanvasElement(),this._cacheContext=this._cacheCanvas.getContext("2d"),this._updateCacheCanvas(),this.dirty=!0}_limitCacheSize(dims){const width=dims.width,height=dims.height,max=config.maxCacheSideLimit,min=config.minCacheSideLimit;if(width<=max&&height<=max&&width*height<=config.perfLimitSizeTotal)return width<min&&(dims.width=min),height<min&&(dims.height=min),dims;const ar=width/height,[limX,limY]=cache.limitDimsByArea(ar),x=capValue(min,limX,max),y=capValue(min,limY,max);return width>x&&(dims.zoomX/=width/x,dims.width=x,dims.capped=!0),height>y&&(dims.zoomY/=height/y,dims.height=y,dims.capped=!0),dims}_getCacheCanvasDimensions(){const objectScale=this.getTotalObjectScaling(),dim=this._getTransformedDimensions({skewX:0,skewY:0}),neededX=dim.x*objectScale.x/this.scaleX,neededY=dim.y*objectScale.y/this.scaleY;return{width:neededX+2,height:neededY+2,zoomX:objectScale.x,zoomY:objectScale.y,x:neededX,y:neededY}}_updateCacheCanvas(){const canvas=this._cacheCanvas,context=this._cacheContext,dims=this._limitCacheSize(this._getCacheCanvasDimensions()),minCacheSize=config.minCacheSideLimit,width=dims.width,height=dims.height,zoomX=dims.zoomX,zoomY=dims.zoomY,dimensionsChanged=width!==this.cacheWidth||height!==this.cacheHeight,zoomChanged=this.zoomX!==zoomX||this.zoomY!==zoomY;if(!canvas||!context)return!1;let drawingWidth,drawingHeight,shouldRedraw=dimensionsChanged||zoomChanged,additionalWidth=0,additionalHeight=0,shouldResizeCanvas=!1;if(dimensionsChanged){const canvasWidth=this._cacheCanvas.width,canvasHeight=this._cacheCanvas.height,sizeGrowing=width>canvasWidth||height>canvasHeight;shouldResizeCanvas=sizeGrowing||(width<.9*canvasWidth||height<.9*canvasHeight)&&canvasWidth>minCacheSize&&canvasHeight>minCacheSize,sizeGrowing&&!dims.capped&&(width>minCacheSize||height>minCacheSize)&&(additionalWidth=.1*width,additionalHeight=.1*height)}return isTextObject(this)&&this.path&&(shouldRedraw=!0,shouldResizeCanvas=!0,additionalWidth+=this.getHeightOfLine(0)*this.zoomX,additionalHeight+=this.getHeightOfLine(0)*this.zoomY),!!shouldRedraw&&(shouldResizeCanvas?(canvas.width=Math.ceil(width+additionalWidth),canvas.height=Math.ceil(height+additionalHeight)):(context.setTransform(1,0,0,1,0,0),context.clearRect(0,0,canvas.width,canvas.height)),drawingWidth=dims.x/2,drawingHeight=dims.y/2,this.cacheTranslationX=Math.round(canvas.width/2-drawingWidth)+drawingWidth,this.cacheTranslationY=Math.round(canvas.height/2-drawingHeight)+drawingHeight,this.cacheWidth=width,this.cacheHeight=height,context.translate(this.cacheTranslationX,this.cacheTranslationY),context.scale(zoomX,zoomY),this.zoomX=zoomX,this.zoomY=zoomY,!0)}setOptions(){let options=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this._setOptions(options)}transform(ctx){const needFullTransform=this.group&&!this.group._transformDone||this.group&&this.canvas&&ctx===this.canvas.contextTop,m=this.calcTransformMatrix(!needFullTransform);ctx.transform(m[0],m[1],m[2],m[3],m[4],m[5])}toObject(){let propertiesToInclude=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];const NUM_FRACTION_DIGITS=config.NUM_FRACTION_DIGITS,clipPathData=this.clipPath&&!this.clipPath.excludeFromExport?_objectSpread2(_objectSpread2({},this.clipPath.toObject(propertiesToInclude)),{},{inverted:this.clipPath.inverted,absolutePositioned:this.clipPath.absolutePositioned}):null,object=_objectSpread2(_objectSpread2({},pick(this,propertiesToInclude)),{},{type:this.constructor.type,version:"6.0.0-beta18",originX:this.originX,originY:this.originY,left:toFixed(this.left,NUM_FRACTION_DIGITS),top:toFixed(this.top,NUM_FRACTION_DIGITS),width:toFixed(this.width,NUM_FRACTION_DIGITS),height:toFixed(this.height,NUM_FRACTION_DIGITS),fill:isSerializableFiller(this.fill)?this.fill.toObject():this.fill,stroke:isSerializableFiller(this.stroke)?this.stroke.toObject():this.stroke,strokeWidth:toFixed(this.strokeWidth,NUM_FRACTION_DIGITS),strokeDashArray:this.strokeDashArray?this.strokeDashArray.concat():this.strokeDashArray,strokeLineCap:this.strokeLineCap,strokeDashOffset:this.strokeDashOffset,strokeLineJoin:this.strokeLineJoin,strokeUniform:this.strokeUniform,strokeMiterLimit:toFixed(this.strokeMiterLimit,NUM_FRACTION_DIGITS),scaleX:toFixed(this.scaleX,NUM_FRACTION_DIGITS),scaleY:toFixed(this.scaleY,NUM_FRACTION_DIGITS),angle:toFixed(this.angle,NUM_FRACTION_DIGITS),flipX:this.flipX,flipY:this.flipY,opacity:toFixed(this.opacity,NUM_FRACTION_DIGITS),shadow:this.shadow&&this.shadow.toObject?this.shadow.toObject():this.shadow,visible:this.visible,backgroundColor:this.backgroundColor,fillRule:this.fillRule,paintFirst:this.paintFirst,globalCompositeOperation:this.globalCompositeOperation,skewX:toFixed(this.skewX,NUM_FRACTION_DIGITS),skewY:toFixed(this.skewY,NUM_FRACTION_DIGITS)},clipPathData?{clipPath:clipPathData}:null);return this.includeDefaultValues?object:this._removeDefaultValues(object)}toDatalessObject(propertiesToInclude){return this.toObject(propertiesToInclude)}_removeDefaultValues(object){const defaults=this.constructor.getDefaults(),baseValues=Object.keys(defaults).length>0?defaults:Object.getPrototypeOf(this);return pickBy(object,((value,key)=>{if(key===LEFT||key===TOP||"type"===key)return!0;const baseValue=baseValues[key];return value!==baseValue&&!(Array.isArray(value)&&Array.isArray(baseValue)&&0===value.length&&0===baseValue.length)}))}toString(){return"#<".concat(this.constructor.type,">")}getObjectScaling(){if(!this.group)return new Point(Math.abs(this.scaleX),Math.abs(this.scaleY));const options=qrDecompose(this.calcTransformMatrix());return new Point(Math.abs(options.scaleX),Math.abs(options.scaleY))}getTotalObjectScaling(){const scale=this.getObjectScaling();if(this.canvas){const zoom=this.canvas.getZoom(),retina=this.getCanvasRetinaScaling();return scale.scalarMultiply(zoom*retina)}return scale}getObjectOpacity(){let opacity=this.opacity;return this.group&&(opacity*=this.group.getObjectOpacity()),opacity}_constrainScale(value){return Math.abs(value)<this.minScaleLimit?value<0?-this.minScaleLimit:this.minScaleLimit:0===value?1e-4:value}_set(key,value){const isChanged=this[key]!==value;if("scaleX"!==key&&"scaleY"!==key||(value=this._constrainScale(value)),"scaleX"===key&&value<0?(this.flipX=!this.flipX,value*=-1):"scaleY"===key&&value<0?(this.flipY=!this.flipY,value*=-1):"shadow"!==key||!value||value instanceof Shadow?"dirty"===key&&this.group&&value&&this.group.set("dirty",value):value=new Shadow(value),this[key]=value,isChanged){const groupNeedsUpdate=this.group&&this.group.isOnACache();this.constructor.cacheProperties.includes(key)?(this.dirty=!0,groupNeedsUpdate&&this.group.set("dirty",!0)):groupNeedsUpdate&&this.constructor.stateProperties.includes(key)&&this.group.set("dirty",!0)}return this}isNotVisible(){return 0===this.opacity||!this.width&&!this.height&&0===this.strokeWidth||!this.visible}render(ctx){this.isNotVisible()||this.canvas&&this.canvas.skipOffscreen&&!this.group&&!this.isOnScreen()||(ctx.save(),this._setupCompositeOperation(ctx),this.drawSelectionBackground(ctx),this.transform(ctx),this._setOpacity(ctx),this._setShadow(ctx),this.shouldCache()?(this.renderCache(),this.drawCacheOnCanvas(ctx)):(this._removeCacheCanvas(),this.drawObject(ctx),this.dirty=!1),ctx.restore())}drawSelectionBackground(ctx){}renderCache(options){options=options||{},this._cacheCanvas&&this._cacheContext||this._createCacheCanvas(),this.isCacheDirty()&&this._cacheContext&&(this.drawObject(this._cacheContext,options.forClipping),this.dirty=!1)}_removeCacheCanvas(){this._cacheCanvas=void 0,this._cacheContext=null,this.cacheWidth=0,this.cacheHeight=0}hasStroke(){return this.stroke&&"transparent"!==this.stroke&&0!==this.strokeWidth}hasFill(){return this.fill&&"transparent"!==this.fill}needsItsOwnCache(){return!!("stroke"===this.paintFirst&&this.hasFill()&&this.hasStroke()&&this.shadow)||!!this.clipPath}shouldCache(){return this.ownCaching=this.needsItsOwnCache()||this.objectCaching&&(!this.group||!this.group.isOnACache()),this.ownCaching}willDrawShadow(){return!!this.shadow&&(0!==this.shadow.offsetX||0!==this.shadow.offsetY)}drawClipPathOnCache(ctx,clipPath){if(ctx.save(),clipPath.inverted?ctx.globalCompositeOperation="destination-out":ctx.globalCompositeOperation="destination-in",clipPath.absolutePositioned){const m=invertTransform(this.calcTransformMatrix());ctx.transform(m[0],m[1],m[2],m[3],m[4],m[5])}clipPath.transform(ctx),ctx.scale(1/clipPath.zoomX,1/clipPath.zoomY),ctx.drawImage(clipPath._cacheCanvas,-clipPath.cacheTranslationX,-clipPath.cacheTranslationY),ctx.restore()}drawObject(ctx,forClipping){const originalFill=this.fill,originalStroke=this.stroke;forClipping?(this.fill="black",this.stroke="",this._setClippingProperties(ctx)):this._renderBackground(ctx),this._render(ctx),this._drawClipPath(ctx,this.clipPath),this.fill=originalFill,this.stroke=originalStroke}_drawClipPath(ctx,clipPath){clipPath&&(clipPath._set("canvas",this.canvas),clipPath.shouldCache(),clipPath._transformDone=!0,clipPath.renderCache({forClipping:!0}),this.drawClipPathOnCache(ctx,clipPath))}drawCacheOnCanvas(ctx){ctx.scale(1/this.zoomX,1/this.zoomY),ctx.drawImage(this._cacheCanvas,-this.cacheTranslationX,-this.cacheTranslationY)}isCacheDirty(){let skipCanvas=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.isNotVisible())return!1;if(this._cacheCanvas&&this._cacheContext&&!skipCanvas&&this._updateCacheCanvas())return!0;if(this.dirty||this.clipPath&&this.clipPath.absolutePositioned){if(this._cacheCanvas&&this._cacheContext&&!skipCanvas){const width=this.cacheWidth/this.zoomX,height=this.cacheHeight/this.zoomY;this._cacheContext.clearRect(-width/2,-height/2,width,height)}return!0}return!1}_renderBackground(ctx){if(!this.backgroundColor)return;const dim=this._getNonTransformedDimensions();ctx.fillStyle=this.backgroundColor,ctx.fillRect(-dim.x/2,-dim.y/2,dim.x,dim.y),this._removeShadow(ctx)}_setOpacity(ctx){this.group&&!this.group._transformDone?ctx.globalAlpha=this.getObjectOpacity():ctx.globalAlpha*=this.opacity}_setStrokeStyles(ctx,decl){const stroke=decl.stroke;stroke&&(ctx.lineWidth=decl.strokeWidth,ctx.lineCap=decl.strokeLineCap,ctx.lineDashOffset=decl.strokeDashOffset,ctx.lineJoin=decl.strokeLineJoin,ctx.miterLimit=decl.strokeMiterLimit,isFiller(stroke)?"percentage"===stroke.gradientUnits||stroke.gradientTransform||stroke.patternTransform?this._applyPatternForTransformedGradient(ctx,stroke):(ctx.strokeStyle=stroke.toLive(ctx),this._applyPatternGradientTransform(ctx,stroke)):ctx.strokeStyle=decl.stroke)}_setFillStyles(ctx,_ref){let{fill}=_ref;fill&&(isFiller(fill)?(ctx.fillStyle=fill.toLive(ctx),this._applyPatternGradientTransform(ctx,fill)):ctx.fillStyle=fill)}_setClippingProperties(ctx){ctx.globalAlpha=1,ctx.strokeStyle="transparent",ctx.fillStyle="#000000"}_setLineDash(ctx,dashArray){dashArray&&0!==dashArray.length&&(1&dashArray.length&&dashArray.push(...dashArray),ctx.setLineDash(dashArray))}_setShadow(ctx){if(!this.shadow)return;const shadow=this.shadow,canvas=this.canvas,retinaScaling=this.getCanvasRetinaScaling(),[sx,,,sy]=(null==canvas?void 0:canvas.viewportTransform)||iMatrix,multX=sx*retinaScaling,multY=sy*retinaScaling,scaling=shadow.nonScaling?new Point(1,1):this.getObjectScaling();ctx.shadowColor=shadow.color,ctx.shadowBlur=shadow.blur*config.browserShadowBlurConstant*(multX+multY)*(scaling.x+scaling.y)/4,ctx.shadowOffsetX=shadow.offsetX*multX*scaling.x,ctx.shadowOffsetY=shadow.offsetY*multY*scaling.y}_removeShadow(ctx){this.shadow&&(ctx.shadowColor="",ctx.shadowBlur=ctx.shadowOffsetX=ctx.shadowOffsetY=0)}_applyPatternGradientTransform(ctx,filler){if(!isFiller(filler))return{offsetX:0,offsetY:0};const t=filler.gradientTransform||filler.patternTransform,offsetX=-this.width/2+filler.offsetX||0,offsetY=-this.height/2+filler.offsetY||0;return"percentage"===filler.gradientUnits?ctx.transform(this.width,0,0,this.height,offsetX,offsetY):ctx.transform(1,0,0,1,offsetX,offsetY),t&&ctx.transform(t[0],t[1],t[2],t[3],t[4],t[5]),{offsetX,offsetY}}_renderPaintInOrder(ctx){"stroke"===this.paintFirst?(this._renderStroke(ctx),this._renderFill(ctx)):(this._renderFill(ctx),this._renderStroke(ctx))}_render(ctx){}_renderFill(ctx){this.fill&&(ctx.save(),this._setFillStyles(ctx,this),"evenodd"===this.fillRule?ctx.fill("evenodd"):ctx.fill(),ctx.restore())}_renderStroke(ctx){if(this.stroke&&0!==this.strokeWidth){if(this.shadow&&!this.shadow.affectStroke&&this._removeShadow(ctx),ctx.save(),this.strokeUniform){const scaling=this.getObjectScaling();ctx.scale(1/scaling.x,1/scaling.y)}this._setLineDash(ctx,this.strokeDashArray),this._setStrokeStyles(ctx,this),ctx.stroke(),ctx.restore()}}_applyPatternForTransformedGradient(ctx,filler){var _pCtx$createPattern;const dims=this._limitCacheSize(this._getCacheCanvasDimensions()),pCanvas=createCanvasElement(),retinaScaling=this.getCanvasRetinaScaling(),width=dims.x/this.scaleX/retinaScaling,height=dims.y/this.scaleY/retinaScaling;pCanvas.width=Math.ceil(width),pCanvas.height=Math.ceil(height);const pCtx=pCanvas.getContext("2d");pCtx&&(pCtx.beginPath(),pCtx.moveTo(0,0),pCtx.lineTo(width,0),pCtx.lineTo(width,height),pCtx.lineTo(0,height),pCtx.closePath(),pCtx.translate(width/2,height/2),pCtx.scale(dims.zoomX/this.scaleX/retinaScaling,dims.zoomY/this.scaleY/retinaScaling),this._applyPatternGradientTransform(pCtx,filler),pCtx.fillStyle=filler.toLive(ctx),pCtx.fill(),ctx.translate(-this.width/2-this.strokeWidth/2,-this.height/2-this.strokeWidth/2),ctx.scale(retinaScaling*this.scaleX/dims.zoomX,retinaScaling*this.scaleY/dims.zoomY),ctx.strokeStyle=null!==(_pCtx$createPattern=pCtx.createPattern(pCanvas,"no-repeat"))&&void 0!==_pCtx$createPattern?_pCtx$createPattern:"")}_findCenterFromElement(){return new Point(this.left+this.width/2,this.top+this.height/2)}clone(propertiesToInclude){const objectForm=this.toObject(propertiesToInclude);return this.constructor.fromObject(objectForm)}cloneAsImage(options){const canvasEl=this.toCanvasElement(options);return new(classRegistry.getClass("image"))(canvasEl)}toCanvasElement(){let options=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const origParams=saveObjectTransform(this),originalGroup=this.group,originalShadow=this.shadow,abs=Math.abs,retinaScaling=options.enableRetinaScaling?getDevicePixelRatio():1,multiplier=(options.multiplier||1)*retinaScaling;delete this.group,options.withoutTransform&&resetObjectTransform(this),options.withoutShadow&&(this.shadow=null),options.viewportTransform&&sendObjectToPlane(this,this.getViewportTransform()),this.setCoords();const el=createCanvasElement(),boundingRect=this.getBoundingRect(),shadow=this.shadow,shadowOffset=new Point;if(shadow){const shadowBlur=shadow.blur,scaling=shadow.nonScaling?new Point(1,1):this.getObjectScaling();shadowOffset.x=2*Math.round(abs(shadow.offsetX)+shadowBlur)*abs(scaling.x),shadowOffset.y=2*Math.round(abs(shadow.offsetY)+shadowBlur)*abs(scaling.y)}const width=boundingRect.width+shadowOffset.x,height=boundingRect.height+shadowOffset.y;el.width=Math.ceil(width),el.height=Math.ceil(height);const canvas=new StaticCanvas(el,{enableRetinaScaling:!1,renderOnAddRemove:!1,skipOffscreen:!1});"jpeg"===options.format&&(canvas.backgroundColor="#fff"),this.setPositionByOrigin(new Point(canvas.width/2,canvas.height/2),CENTER,CENTER);const originalCanvas=this.canvas;canvas._objects=[this],this.set("canvas",canvas),this.setCoords();const canvasEl=canvas.toCanvasElement(multiplier||1,options);return this.set("canvas",originalCanvas),this.shadow=originalShadow,originalGroup&&(this.group=originalGroup),this.set(origParams),this.setCoords(),canvas._objects=[],canvas.destroy(),canvasEl}toDataURL(){let options=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return toDataURL(this.toCanvasElement(options),options.format||"png",options.quality||1)}isType(){for(var _len=arguments.length,types=new Array(_len),_key=0;_key<_len;_key++)types[_key]=arguments[_key];return types.includes(this.constructor.type)||types.includes(this.type)}complexity(){return 1}toJSON(){return this.toObject()}rotate(angle){const{centeredRotation,originX,originY}=this;if(centeredRotation){const{x,y}=this.getRelativeCenterPoint();this.originX=CENTER,this.originY=CENTER,this.left=x,this.top=y}if(this.set("angle",angle),centeredRotation){const{x,y}=this.translateToOriginPoint(this.getRelativeCenterPoint(),originX,originY);this.left=x,this.top=y,this.originX=originX,this.originY=originY}}setOnGroup(){}_setupCompositeOperation(ctx){this.globalCompositeOperation&&(ctx.globalCompositeOperation=this.globalCompositeOperation)}dispose(){runningAnimations.cancelByTarget(this),this.off(),this._set("canvas",void 0),this._cacheCanvas&&getEnv().dispose(this._cacheCanvas),this._cacheCanvas=void 0,this._cacheContext=null}static _fromObject(_ref2){let object=_objectWithoutProperties(_ref2,_excluded$h),_ref3=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{extraParam}=_ref3,options=_objectWithoutProperties(_ref3,_excluded2$4);return enlivenObjectEnlivables(cloneDeep(object),options).then((enlivedMap=>{const allOptions=_objectSpread2(_objectSpread2({},options),enlivedMap);if(extraParam){const{[extraParam]:arg0}=allOptions;return new this(arg0,_objectWithoutProperties(allOptions,[extraParam].map(_toPropertyKey)))}return new this(allOptions)}))}static fromObject(object,options){return this._fromObject(object,options)}};_defineProperty(FabricObject$1,"stateProperties",stateProperties),_defineProperty(FabricObject$1,"cacheProperties",cacheProperties),_defineProperty(FabricObject$1,"ownDefaults",fabricObjectDefaultValues),_defineProperty(FabricObject$1,"type","FabricObject"),classRegistry.setClass(FabricObject$1),classRegistry.setClass(FabricObject$1,"object");const wrapWithFireEvent=(eventName,actionHandler)=>(eventData,transform,x,y)=>{const actionPerformed=actionHandler(eventData,transform,x,y);return actionPerformed&&fireEvent(eventName,commonEventInfo(eventData,transform,x,y)),actionPerformed};function wrapWithFixedAnchor(actionHandler){return(eventData,transform,x,y)=>{const{target,originX,originY}=transform,centerPoint=target.getRelativeCenterPoint(),constraint=target.translateToOriginPoint(centerPoint,originX,originY),actionPerformed=actionHandler(eventData,transform,x,y);return target.setPositionByOrigin(constraint,transform.originX,transform.originY),actionPerformed}}const changeWidth=wrapWithFireEvent("resizing",wrapWithFixedAnchor(((eventData,transform,x,y)=>{const localPoint=getLocalPoint(transform,transform.originX,transform.originY,x,y);if(transform.originX===CENTER||transform.originX===RIGHT&&localPoint.x<0||transform.originX===LEFT&&localPoint.x>0){const{target}=transform,strokePadding=target.strokeWidth/(target.strokeUniform?target.scaleX:1),multiplier=isTransformCentered(transform)?2:1,oldWidth=target.width,newWidth=Math.ceil(Math.abs(localPoint.x*multiplier/target.scaleX)-strokePadding);return target.set("width",Math.max(newWidth,0)),oldWidth!==target.width}return!1})));function renderCircleControl(ctx,left,top,styleOverride,fabricObject){styleOverride=styleOverride||{};const xSize=this.sizeX||styleOverride.cornerSize||fabricObject.cornerSize,ySize=this.sizeY||styleOverride.cornerSize||fabricObject.cornerSize,transparentCorners=void 0!==styleOverride.transparentCorners?styleOverride.transparentCorners:fabricObject.transparentCorners,methodName=transparentCorners?"stroke":"fill",stroke=!transparentCorners&&(styleOverride.cornerStrokeColor||fabricObject.cornerStrokeColor);let size,myLeft=left,myTop=top;ctx.save(),ctx.fillStyle=styleOverride.cornerColor||fabricObject.cornerColor||"",ctx.strokeStyle=styleOverride.cornerStrokeColor||fabricObject.cornerStrokeColor||"",xSize>ySize?(size=xSize,ctx.scale(1,ySize/xSize),myTop=top*xSize/ySize):ySize>xSize?(size=ySize,ctx.scale(xSize/ySize,1),myLeft=left*ySize/xSize):size=xSize,ctx.lineWidth=1,ctx.beginPath(),ctx.arc(myLeft,myTop,size/2,0,twoMathPi,!1),ctx[methodName](),stroke&&ctx.stroke(),ctx.restore()}function renderSquareControl(ctx,left,top,styleOverride,fabricObject){styleOverride=styleOverride||{};const xSize=this.sizeX||styleOverride.cornerSize||fabricObject.cornerSize,ySize=this.sizeY||styleOverride.cornerSize||fabricObject.cornerSize,transparentCorners=void 0!==styleOverride.transparentCorners?styleOverride.transparentCorners:fabricObject.transparentCorners,methodName=transparentCorners?"stroke":"fill",stroke=!transparentCorners&&(styleOverride.cornerStrokeColor||fabricObject.cornerStrokeColor),xSizeBy2=xSize/2,ySizeBy2=ySize/2;ctx.save(),ctx.fillStyle=styleOverride.cornerColor||fabricObject.cornerColor||"",ctx.strokeStyle=styleOverride.cornerStrokeColor||fabricObject.cornerStrokeColor||"",ctx.lineWidth=1,ctx.translate(left,top);const angle=fabricObject.getTotalAngle();ctx.rotate(degreesToRadians(angle)),ctx["".concat(methodName,"Rect")](-xSizeBy2,-ySizeBy2,xSize,ySize),stroke&&ctx.strokeRect(-xSizeBy2,-ySizeBy2,xSize,ySize),ctx.restore()}class Control{constructor(options){_defineProperty(this,"visible",!0),_defineProperty(this,"actionName","scale"),_defineProperty(this,"angle",0),_defineProperty(this,"x",0),_defineProperty(this,"y",0),_defineProperty(this,"offsetX",0),_defineProperty(this,"offsetY",0),_defineProperty(this,"sizeX",0),_defineProperty(this,"sizeY",0),_defineProperty(this,"touchSizeX",0),_defineProperty(this,"touchSizeY",0),_defineProperty(this,"cursorStyle","crosshair"),_defineProperty(this,"withConnection",!1),Object.assign(this,options)}shouldActivate(controlKey,fabricObject,pointer,_ref){var _fabricObject$canvas;let{tl,tr,br,bl}=_ref;return(null===(_fabricObject$canvas=fabricObject.canvas)||void 0===_fabricObject$canvas?void 0:_fabricObject$canvas.getActiveObject())===fabricObject&&fabricObject.isControlVisible(controlKey)&&Intersection.isPointInPolygon(pointer,[tl,tr,br,bl])}getActionHandler(eventData,fabricObject,control){return this.actionHandler}getMouseDownHandler(eventData,fabricObject,control){return this.mouseDownHandler}getMouseUpHandler(eventData,fabricObject,control){return this.mouseUpHandler}cursorStyleHandler(eventData,control,fabricObject){return control.cursorStyle}getActionName(eventData,control,fabricObject){return control.actionName}getVisibility(fabricObject,controlKey){var _fabricObject$_contro,_fabricObject$_contro2;return null!==(_fabricObject$_contro=null===(_fabricObject$_contro2=fabricObject._controlsVisibility)||void 0===_fabricObject$_contro2?void 0:_fabricObject$_contro2[controlKey])&&void 0!==_fabricObject$_contro?_fabricObject$_contro:this.visible}setVisibility(visibility,name,fabricObject){this.visible=visibility}positionHandler(dim,finalMatrix,fabricObject,currentControl){return new Point(this.x*dim.x+this.offsetX,this.y*dim.y+this.offsetY).transform(finalMatrix)}calcCornerCoords(angle,objectCornerSize,centerX,centerY,isTouch,fabricObject){const t=multiplyTransformMatrixArray([createTranslateMatrix(centerX,centerY),createRotateMatrix({angle}),createScaleMatrix((isTouch?this.touchSizeX:this.sizeX)||objectCornerSize,(isTouch?this.touchSizeY:this.sizeY)||objectCornerSize)]);return{tl:new Point(-.5,-.5).transform(t),tr:new Point(.5,-.5).transform(t),bl:new Point(-.5,.5).transform(t),br:new Point(.5,.5).transform(t)}}render(ctx,left,top,styleOverride,fabricObject){if("circle"===((styleOverride=styleOverride||{}).cornerStyle||fabricObject.cornerStyle))renderCircleControl.call(this,ctx,left,top,styleOverride,fabricObject);else renderSquareControl.call(this,ctx,left,top,styleOverride,fabricObject)}}const rotationStyleHandler=(eventData,control,fabricObject)=>fabricObject.lockRotation?"not-allowed":control.cursorStyle,rotationWithSnapping=wrapWithFireEvent("rotating",wrapWithFixedAnchor(((eventData,_ref,x,y)=>{let{target,ex,ey,theta,originX,originY}=_ref;const pivotPoint=target.translateToOriginPoint(target.getRelativeCenterPoint(),originX,originY);if(isLocked(target,"lockRotation"))return!1;const lastAngle=Math.atan2(ey-pivotPoint.y,ex-pivotPoint.x),curAngle=Math.atan2(y-pivotPoint.y,x-pivotPoint.x);let angle=radiansToDegrees(curAngle-lastAngle+theta);if(target.snapAngle&&target.snapAngle>0){const snapAngle=target.snapAngle,snapThreshold=target.snapThreshold||snapAngle,rightAngleLocked=Math.ceil(angle/snapAngle)*snapAngle,leftAngleLocked=Math.floor(angle/snapAngle)*snapAngle;Math.abs(angle-leftAngleLocked)<snapThreshold?angle=leftAngleLocked:Math.abs(angle-rightAngleLocked)<snapThreshold&&(angle=rightAngleLocked)}angle<0&&(angle=360+angle),angle%=360;const hasRotated=target.angle!==angle;return target.angle=angle,hasRotated})));function scaleIsProportional(eventData,fabricObject){const canvas=fabricObject.canvas,uniformIsToggled=eventData[canvas.uniScaleKey];return canvas.uniformScaling&&!uniformIsToggled||!canvas.uniformScaling&&uniformIsToggled}function scalingIsForbidden(fabricObject,by,scaleProportionally){const lockX=isLocked(fabricObject,"lockScalingX"),lockY=isLocked(fabricObject,"lockScalingY");if(lockX&&lockY)return!0;if(!by&&(lockX||lockY)&&scaleProportionally)return!0;if(lockX&&"x"===by)return!0;if(lockY&&"y"===by)return!0;const{width,height,strokeWidth}=fabricObject;return 0===width&&0===strokeWidth&&"y"!==by||0===height&&0===strokeWidth&&"x"!==by}const scaleMap=["e","se","s","sw","w","nw","n","ne","e"],scaleCursorStyleHandler=(eventData,control,fabricObject)=>{const scaleProportionally=scaleIsProportional(eventData,fabricObject);if(scalingIsForbidden(fabricObject,0!==control.x&&0===control.y?"x":0===control.x&&0!==control.y?"y":"",scaleProportionally))return"not-allowed";const n=findCornerQuadrant(fabricObject,control);return"".concat(scaleMap[n],"-resize")};function scaleObject(eventData,transform,x,y){let options=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};const target=transform.target,by=options.by,scaleProportionally=scaleIsProportional(eventData,target);let newPoint,scaleX,scaleY,dim,signX,signY;if(scalingIsForbidden(target,by,scaleProportionally))return!1;if(transform.gestureScale)scaleX=transform.scaleX*transform.gestureScale,scaleY=transform.scaleY*transform.gestureScale;else{if(newPoint=getLocalPoint(transform,transform.originX,transform.originY,x,y),signX="y"!==by?Math.sign(newPoint.x||transform.signX||1):1,signY="x"!==by?Math.sign(newPoint.y||transform.signY||1):1,transform.signX||(transform.signX=signX),transform.signY||(transform.signY=signY),isLocked(target,"lockScalingFlip")&&(transform.signX!==signX||transform.signY!==signY))return!1;if(dim=target._getTransformedDimensions(),scaleProportionally&&!by){const distance=Math.abs(newPoint.x)+Math.abs(newPoint.y),{original}=transform,scale=distance/(Math.abs(dim.x*original.scaleX/target.scaleX)+Math.abs(dim.y*original.scaleY/target.scaleY));scaleX=original.scaleX*scale,scaleY=original.scaleY*scale}else scaleX=Math.abs(newPoint.x*target.scaleX/dim.x),scaleY=Math.abs(newPoint.y*target.scaleY/dim.y);isTransformCentered(transform)&&(scaleX*=2,scaleY*=2),transform.signX!==signX&&"y"!==by&&(transform.originX=invertOrigin(transform.originX),scaleX*=-1,transform.signX=signX),transform.signY!==signY&&"x"!==by&&(transform.originY=invertOrigin(transform.originY),scaleY*=-1,transform.signY=signY)}const oldScaleX=target.scaleX,oldScaleY=target.scaleY;return by?("x"===by&&target.set("scaleX",scaleX),"y"===by&&target.set("scaleY",scaleY)):(!isLocked(target,"lockScalingX")&&target.set("scaleX",scaleX),!isLocked(target,"lockScalingY")&&target.set("scaleY",scaleY)),oldScaleX!==target.scaleX||oldScaleY!==target.scaleY}const scalingEqually=wrapWithFireEvent("scaling",wrapWithFixedAnchor(((eventData,transform,x,y)=>scaleObject(eventData,transform,x,y)))),scalingX=wrapWithFireEvent("scaling",wrapWithFixedAnchor(((eventData,transform,x,y)=>scaleObject(eventData,transform,x,y,{by:"x"})))),scalingY=wrapWithFireEvent("scaling",wrapWithFixedAnchor(((eventData,transform,x,y)=>scaleObject(eventData,transform,x,y,{by:"y"})))),_excluded$g=["target","ex","ey","skewingSide"],AXIS_KEYS={x:{counterAxis:"y",scale:"scaleX",skew:"skewX",lockSkewing:"lockSkewingX",origin:"originX",flip:"flipX"},y:{counterAxis:"x",scale:"scaleY",skew:"skewY",lockSkewing:"lockSkewingY",origin:"originY",flip:"flipY"}},skewMap=["ns","nesw","ew","nwse"],skewCursorStyleHandler=(eventData,control,fabricObject)=>{if(0!==control.x&&isLocked(fabricObject,"lockSkewingY"))return"not-allowed";if(0!==control.y&&isLocked(fabricObject,"lockSkewingX"))return"not-allowed";const n=findCornerQuadrant(fabricObject,control)%4;return"".concat(skewMap[n],"-resize")};function skewHandler(axis,eventData,transform,x,y){const{target}=transform,{counterAxis,origin:originKey,lockSkewing:lockSkewingKey,skew:skewKey,flip:flipKey}=AXIS_KEYS[axis];if(isLocked(target,lockSkewingKey))return!1;const{origin:counterOriginKey,flip:counterFlipKey}=AXIS_KEYS[counterAxis],counterOriginFactor=resolveOrigin(transform[counterOriginKey])*(target[counterFlipKey]?-1:1),skewingSide=-Math.sign(counterOriginFactor)*(target[flipKey]?-1:1),origin=.5*-((0===target[skewKey]&&getLocalPoint(transform,CENTER,CENTER,x,y)[axis]>0||target[skewKey]>0?1:-1)*skewingSide)+.5,finalHandler=wrapWithFireEvent("skewing",wrapWithFixedAnchor(((eventData,transform,x,y)=>function skewObject(axis,_ref,pointer){let{target,ex,ey,skewingSide}=_ref,transform=_objectWithoutProperties(_ref,_excluded$g);const{skew:skewKey}=AXIS_KEYS[axis],offset=pointer.subtract(new Point(ex,ey)).divide(new Point(target.scaleX,target.scaleY))[axis],skewingBefore=target[skewKey],skewingStart=transform[skewKey],shearingStart=Math.tan(degreesToRadians(skewingStart)),b="y"===axis?target._getTransformedDimensions({scaleX:1,scaleY:1,skewX:0}).x:target._getTransformedDimensions({scaleX:1,scaleY:1}).y,shearing=2*offset*skewingSide/Math.max(b,1)+shearingStart,skewing=radiansToDegrees(Math.atan(shearing));target.set(skewKey,skewing);const changed=skewingBefore!==target[skewKey];if(changed&&"y"===axis){const{skewX,scaleX}=target,dimBefore=target._getTransformedDimensions({skewY:skewingBefore}),dimAfter=target._getTransformedDimensions(),compensationFactor=0!==skewX?dimBefore.x/dimAfter.x:1;1!==compensationFactor&&target.set("scaleX",compensationFactor*scaleX)}return changed}(axis,transform,new Point(x,y)))));return finalHandler(eventData,_objectSpread2(_objectSpread2({},transform),{},{[originKey]:origin,skewingSide}),x,y)}const skewHandlerX=(eventData,transform,x,y)=>skewHandler("x",eventData,transform,x,y),skewHandlerY=(eventData,transform,x,y)=>skewHandler("y",eventData,transform,x,y);function isAltAction(eventData,target){return eventData[target.canvas.altActionKey]}const scaleOrSkewActionName=(eventData,control,fabricObject)=>{const isAlternative=isAltAction(eventData,fabricObject);return 0===control.x?isAlternative?"skewX":"scaleY":0===control.y?isAlternative?"skewY":"scaleX":""},scaleSkewCursorStyleHandler=(eventData,control,fabricObject)=>isAltAction(eventData,fabricObject)?skewCursorStyleHandler(0,control,fabricObject):scaleCursorStyleHandler(eventData,control,fabricObject),scalingXOrSkewingY=(eventData,transform,x,y)=>isAltAction(eventData,transform.target)?skewHandlerY(eventData,transform,x,y):scalingX(eventData,transform,x,y),scalingYOrSkewingX=(eventData,transform,x,y)=>isAltAction(eventData,transform.target)?skewHandlerX(eventData,transform,x,y):scalingY(eventData,transform,x,y),createObjectDefaultControls=()=>({ml:new Control({x:-.5,y:0,cursorStyleHandler:scaleSkewCursorStyleHandler,actionHandler:scalingXOrSkewingY,getActionName:scaleOrSkewActionName}),mr:new Control({x:.5,y:0,cursorStyleHandler:scaleSkewCursorStyleHandler,actionHandler:scalingXOrSkewingY,getActionName:scaleOrSkewActionName}),mb:new Control({x:0,y:.5,cursorStyleHandler:scaleSkewCursorStyleHandler,actionHandler:scalingYOrSkewingX,getActionName:scaleOrSkewActionName}),mt:new Control({x:0,y:-.5,cursorStyleHandler:scaleSkewCursorStyleHandler,actionHandler:scalingYOrSkewingX,getActionName:scaleOrSkewActionName}),tl:new Control({x:-.5,y:-.5,cursorStyleHandler:scaleCursorStyleHandler,actionHandler:scalingEqually}),tr:new Control({x:.5,y:-.5,cursorStyleHandler:scaleCursorStyleHandler,actionHandler:scalingEqually}),bl:new Control({x:-.5,y:.5,cursorStyleHandler:scaleCursorStyleHandler,actionHandler:scalingEqually}),br:new Control({x:.5,y:.5,cursorStyleHandler:scaleCursorStyleHandler,actionHandler:scalingEqually}),mtr:new Control({x:0,y:-.5,actionHandler:rotationWithSnapping,cursorStyleHandler:rotationStyleHandler,offsetY:-40,withConnection:!0,actionName:"rotate"})}),createResizeControls=()=>({mr:new Control({x:.5,y:0,actionHandler:changeWidth,cursorStyleHandler:scaleSkewCursorStyleHandler,actionName:"resizing"}),ml:new Control({x:-.5,y:0,actionHandler:changeWidth,cursorStyleHandler:scaleSkewCursorStyleHandler,actionName:"resizing"})}),createTextboxDefaultControls=()=>_objectSpread2(_objectSpread2({},createObjectDefaultControls()),createResizeControls());class InteractiveFabricObject extends FabricObject$1{static getDefaults(){return _objectSpread2(_objectSpread2({},super.getDefaults()),{},{controls:createObjectDefaultControls()},InteractiveFabricObject.ownDefaults)}_updateCacheCanvas(){const targetCanvas=this.canvas;if(this.noScaleCache&&targetCanvas&&targetCanvas._currentTransform){const transform=targetCanvas._currentTransform,target=transform.target,action=transform.action;if(this===target&&action&&action.startsWith("scale"))return!1}return super._updateCacheCanvas()}getActiveControl(){const key=this.__corner;return key?{key,control:this.controls[key],coord:this.oCoords[key]}:void 0}_findTargetCorner(pointer){let forTouch=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this.hasControls||!this.canvas)return"";this.__corner=void 0;const cornerEntries=Object.entries(this.oCoords);for(let i=cornerEntries.length-1;i>=0;i--){const[key,corner]=cornerEntries[i];if(this.controls[key].shouldActivate(key,this,pointer,forTouch?corner.touchCorner:corner.corner))return this.__corner=key}return""}calcOCoords(){const vpt=this.getViewportTransform(),center=this.getCenterPoint(),tMatrix=createTranslateMatrix(center.x,center.y),rMatrix=createRotateMatrix({angle:this.getTotalAngle()-(this.group&&this.flipX?180:0)}),positionMatrix=multiplyTransformMatrices(tMatrix,rMatrix),startMatrix=multiplyTransformMatrices(vpt,positionMatrix),finalMatrix=multiplyTransformMatrices(startMatrix,[1/vpt[0],0,0,1/vpt[3],0,0]),transformOptions=this.group?qrDecompose(this.calcTransformMatrix()):void 0,dim=this._calculateCurrentDimensions(transformOptions),coords={};return this.forEachControl(((control,key)=>{const position=control.positionHandler(dim,finalMatrix,this,control);coords[key]=Object.assign(position,this._calcCornerCoords(control,position))})),coords}_calcCornerCoords(control,position){const angle=this.getTotalAngle();return{corner:control.calcCornerCoords(angle,this.cornerSize,position.x,position.y,!1,this),touchCorner:control.calcCornerCoords(angle,this.touchCornerSize,position.x,position.y,!0,this)}}setCoords(){super.setCoords(),this.canvas&&(this.oCoords=this.calcOCoords())}forEachControl(fn){for(const i in this.controls)fn(this.controls[i],i,this)}drawSelectionBackground(ctx){if(!this.selectionBackgroundColor||this.canvas&&this.canvas._activeObject!==this)return;ctx.save();const center=this.getRelativeCenterPoint(),wh=this._calculateCurrentDimensions(),vpt=this.getViewportTransform();ctx.translate(center.x,center.y),ctx.scale(1/vpt[0],1/vpt[3]),ctx.rotate(degreesToRadians(this.angle)),ctx.fillStyle=this.selectionBackgroundColor,ctx.fillRect(-wh.x/2,-wh.y/2,wh.x,wh.y),ctx.restore()}strokeBorders(ctx,size){ctx.strokeRect(-size.x/2,-size.y/2,size.x,size.y)}_drawBorders(ctx,size){let styleOverride=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const options=_objectSpread2({hasControls:this.hasControls,borderColor:this.borderColor,borderDashArray:this.borderDashArray},styleOverride);ctx.save(),ctx.strokeStyle=options.borderColor,this._setLineDash(ctx,options.borderDashArray),this.strokeBorders(ctx,size),options.hasControls&&this.drawControlsConnectingLines(ctx,size),ctx.restore()}_renderControls(ctx){let styleOverride=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{hasBorders,hasControls}=this,styleOptions=_objectSpread2({hasBorders,hasControls},styleOverride),vpt=this.getViewportTransform(),shouldDrawBorders=styleOptions.hasBorders,shouldDrawControls=styleOptions.hasControls,matrix=multiplyTransformMatrices(vpt,this.calcTransformMatrix()),options=qrDecompose(matrix);ctx.save(),ctx.translate(options.translateX,options.translateY),ctx.lineWidth=1*this.borderScaleFactor,this.group||(ctx.globalAlpha=this.isMoving?this.borderOpacityWhenMoving:1),this.flipX&&(options.angle-=180),ctx.rotate(degreesToRadians(this.group?options.angle:this.angle)),shouldDrawBorders&&this.drawBorders(ctx,options,styleOverride),shouldDrawControls&&this.drawControls(ctx,styleOverride),ctx.restore()}drawBorders(ctx,options,styleOverride){let size;if(styleOverride&&styleOverride.forActiveSelection||this.group){const bbox=sizeAfterTransform(this.width,this.height,calcDimensionsMatrix(options)),stroke=this.isStrokeAccountedForInDimensions()?ZERO:(this.strokeUniform?(new Point).scalarAdd(this.canvas?this.canvas.getZoom():1):new Point(options.scaleX,options.scaleY)).scalarMultiply(this.strokeWidth);size=bbox.add(stroke).scalarAdd(this.borderScaleFactor).scalarAdd(2*this.padding)}else size=this._calculateCurrentDimensions().scalarAdd(this.borderScaleFactor);this._drawBorders(ctx,size,styleOverride)}drawControlsConnectingLines(ctx,size){let shouldStroke=!1;ctx.beginPath(),this.forEachControl(((control,key)=>{control.withConnection&&control.getVisibility(this,key)&&(shouldStroke=!0,ctx.moveTo(control.x*size.x,control.y*size.y),ctx.lineTo(control.x*size.x+control.offsetX,control.y*size.y+control.offsetY))})),shouldStroke&&ctx.stroke()}drawControls(ctx){let styleOverride=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};ctx.save();const retinaScaling=this.getCanvasRetinaScaling(),{cornerStrokeColor,cornerDashArray,cornerColor}=this,options=_objectSpread2({cornerStrokeColor,cornerDashArray,cornerColor},styleOverride);ctx.setTransform(retinaScaling,0,0,retinaScaling,0,0),ctx.strokeStyle=ctx.fillStyle=options.cornerColor,this.transparentCorners||(ctx.strokeStyle=options.cornerStrokeColor),this._setLineDash(ctx,options.cornerDashArray),this.setCoords(),this.forEachControl(((control,key)=>{if(control.getVisibility(this,key)){const p=this.oCoords[key];control.render(ctx,p.x,p.y,options,this)}})),ctx.restore()}isControlVisible(controlKey){return this.controls[controlKey]&&this.controls[controlKey].getVisibility(this,controlKey)}setControlVisible(controlKey,visible){this._controlsVisibility||(this._controlsVisibility={}),this._controlsVisibility[controlKey]=visible}setControlsVisibility(){let options=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Object.entries(options).forEach((_ref=>{let[controlKey,visibility]=_ref;return this.setControlVisible(controlKey,visibility)}))}clearContextTop(restoreManually){if(!this.canvas)return;const ctx=this.canvas.contextTop;if(!ctx)return;const v=this.canvas.viewportTransform;ctx.save(),ctx.transform(v[0],v[1],v[2],v[3],v[4],v[5]),this.transform(ctx);const width=this.width+4,height=this.height+4;return ctx.clearRect(-width/2,-height/2,width,height),restoreManually||ctx.restore(),ctx}onDeselect(options){return!1}onSelect(options){return!1}shouldStartDragging(){return!1}onDragStart(e){return!1}canDrop(e){return!1}renderDragSourceEffect(e){}renderDropTargetEffect(e){}}function applyMixins(derivedCtor,constructors){return constructors.forEach((baseCtor=>{Object.getOwnPropertyNames(baseCtor.prototype).forEach((name=>{"constructor"!==name&&Object.defineProperty(derivedCtor.prototype,name,Object.getOwnPropertyDescriptor(baseCtor.prototype,name)||Object.create(null))}))})),derivedCtor}_defineProperty(InteractiveFabricObject,"ownDefaults",{noScaleCache:!0,lockMovementX:!1,lockMovementY:!1,lockRotation:!1,lockScalingX:!1,lockScalingY:!1,lockSkewingX:!1,lockSkewingY:!1,lockScalingFlip:!1,cornerSize:13,touchCornerSize:24,transparentCorners:!0,cornerColor:"rgb(178,204,255)",cornerStrokeColor:"",cornerStyle:"rect",cornerDashArray:null,hasControls:!0,borderColor:"rgb(178,204,255)",borderDashArray:null,borderOpacityWhenMoving:.4,borderScaleFactor:1,hasBorders:!0,selectionBackgroundColor:"",selectable:!0,evented:!0,perPixelTargetFind:!1,activeOn:"down",hoverCursor:null,moveCursor:null});class FabricObject extends InteractiveFabricObject{}applyMixins(FabricObject,[FabricObjectSVGExportMixin]),classRegistry.setClass(FabricObject),classRegistry.setClass(FabricObject,"object");const isTransparent=(ctx,x,y,tolerance)=>{const size=2*(tolerance=Math.round(tolerance))+1,{data}=ctx.getImageData(x-tolerance,y-tolerance,size,size);for(let i=3;i<data.length;i+=4){if(data[i]>0)return!1}return!0};class StrokeProjectionsBase{constructor(options){this.options=options,this.strokeProjectionMagnitude=this.options.strokeWidth/2,this.scale=new Point(this.options.scaleX,this.options.scaleY),this.strokeUniformScalar=this.options.strokeUniform?new Point(1/this.options.scaleX,1/this.options.scaleY):new Point(1,1)}createSideVector(from,to){const v=createVector(from,to);return this.options.strokeUniform?v.multiply(this.scale):v}projectOrthogonally(from,to,magnitude){return this.applySkew(from.add(this.calcOrthogonalProjection(from,to,magnitude)))}isSkewed(){return 0!==this.options.skewX||0!==this.options.skewY}applySkew(point){const p=new Point(point);return p.y+=p.x*Math.tan(degreesToRadians(this.options.skewY)),p.x+=p.y*Math.tan(degreesToRadians(this.options.skewX)),p}scaleUnitVector(unitVector,scalar){return unitVector.multiply(this.strokeUniformScalar).scalarMultiply(scalar)}}const zeroVector=new Point;class StrokeLineJoinProjections extends StrokeProjectionsBase{static getOrthogonalRotationFactor(vector1,vector2){const angle=vector2?calcAngleBetweenVectors(vector1,vector2):calcVectorRotation(vector1);return Math.abs(angle)<halfPI?-1:1}constructor(A,B,C,options){super(options),_defineProperty(this,"AB",void 0),_defineProperty(this,"AC",void 0),_defineProperty(this,"alpha",void 0),_defineProperty(this,"bisector",void 0),this.A=new Point(A),this.B=new Point(B),this.C=new Point(C),this.AB=this.createSideVector(this.A,this.B),this.AC=this.createSideVector(this.A,this.C),this.alpha=calcAngleBetweenVectors(this.AB,this.AC),this.bisector=getUnitVector(rotateVector(this.AB.eq(zeroVector)?this.AC:this.AB,this.alpha/2))}calcOrthogonalProjection(from,to){let magnitude=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.strokeProjectionMagnitude;const vector=this.createSideVector(from,to),orthogonalProjection=getOrthonormalVector(vector),correctSide=StrokeLineJoinProjections.getOrthogonalRotationFactor(orthogonalProjection,this.bisector);return this.scaleUnitVector(orthogonalProjection,magnitude*correctSide)}projectBevel(){const projections=[];return(this.alpha%twoMathPi==0?[this.B]:[this.B,this.C]).forEach((to=>{projections.push(this.projectOrthogonally(this.A,to)),projections.push(this.projectOrthogonally(this.A,to,-this.strokeProjectionMagnitude))})),projections}projectMiter(){const projections=[],alpha=Math.abs(this.alpha),hypotUnitScalar=1/Math.sin(alpha/2),miterVector=this.scaleUnitVector(this.bisector,-this.strokeProjectionMagnitude*hypotUnitScalar),strokeMiterLimit=this.options.strokeUniform?magnitude(this.scaleUnitVector(this.bisector,this.options.strokeMiterLimit)):this.options.strokeMiterLimit;return magnitude(miterVector)/this.strokeProjectionMagnitude<=strokeMiterLimit&&projections.push(this.applySkew(this.A.add(miterVector))),projections.push(...this.projectBevel()),projections}projectRoundNoSkew(startCircle,endCircle){const projections=[],correctSide=new Point(StrokeLineJoinProjections.getOrthogonalRotationFactor(this.bisector),StrokeLineJoinProjections.getOrthogonalRotationFactor(new Point(this.bisector.y,this.bisector.x)));return[new Point(1,0).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(correctSide),new Point(0,1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar).multiply(correctSide)].forEach((vector=>{isBetweenVectors(vector,startCircle,endCircle)&&projections.push(this.A.add(vector))})),projections}projectRoundWithSkew(startCircle,endCircle){const projections=[],{skewX,skewY,scaleX,scaleY,strokeUniform}=this.options,shearing=new Point(Math.tan(degreesToRadians(skewX)),Math.tan(degreesToRadians(skewY))),circleRadius=this.strokeProjectionMagnitude,newY=strokeUniform?circleRadius/scaleY/Math.sqrt(1/scaleY**2+1/scaleX**2*shearing.y**2):circleRadius/Math.sqrt(1+shearing.y**2),furthestY=new Point(Math.sqrt(Math.max(circleRadius**2-newY**2,0)),newY),newX=strokeUniform?circleRadius/Math.sqrt(1+shearing.x**2*(1/scaleY)**2/(1/scaleX+1/scaleX*shearing.x*shearing.y)**2):circleRadius/Math.sqrt(1+shearing.x**2/(1+shearing.x*shearing.y)**2),furthestX=new Point(newX,Math.sqrt(Math.max(circleRadius**2-newX**2,0)));return[furthestX,furthestX.scalarMultiply(-1),furthestY,furthestY.scalarMultiply(-1)].map((vector=>this.applySkew(strokeUniform?vector.multiply(this.strokeUniformScalar):vector))).forEach((vector=>{isBetweenVectors(vector,startCircle,endCircle)&&projections.push(this.applySkew(this.A).add(vector))})),projections}projectRound(){const projections=[];projections.push(...this.projectBevel());const isStraightLine=this.alpha%twoMathPi==0,newOrigin=this.applySkew(this.A),proj0=projections[isStraightLine?0:2].subtract(newOrigin),proj1=projections[isStraightLine?1:0].subtract(newOrigin),comparisonVector=isStraightLine?this.applySkew(this.AB.scalarMultiply(-1)):this.applySkew(this.bisector.multiply(this.strokeUniformScalar).scalarMultiply(-1)),isProj0Start=crossProduct(proj0,comparisonVector)>0,startCircle=isProj0Start?proj0:proj1,endCircle=isProj0Start?proj1:proj0;return this.isSkewed()?projections.push(...this.projectRoundWithSkew(startCircle,endCircle)):projections.push(...this.projectRoundNoSkew(startCircle,endCircle)),projections}projectPoints(){switch(this.options.strokeLineJoin){case"miter":return this.projectMiter();case"round":return this.projectRound();default:return this.projectBevel()}}project(){return this.projectPoints().map((point=>({originPoint:this.A,projectedPoint:point,angle:this.alpha,bisector:this.bisector})))}}class StrokeLineCapProjections extends StrokeProjectionsBase{constructor(A,T,options){super(options),this.A=new Point(A),this.T=new Point(T)}calcOrthogonalProjection(from,to){let magnitude=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.strokeProjectionMagnitude;const vector=this.createSideVector(from,to);return this.scaleUnitVector(getOrthonormalVector(vector),magnitude)}projectButt(){return[this.projectOrthogonally(this.A,this.T,this.strokeProjectionMagnitude),this.projectOrthogonally(this.A,this.T,-this.strokeProjectionMagnitude)]}projectRound(){const projections=[];if(!this.isSkewed()&&this.A.eq(this.T)){const projection=new Point(1,1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);projections.push(this.applySkew(this.A.add(projection)),this.applySkew(this.A.subtract(projection)))}else projections.push(...new StrokeLineJoinProjections(this.A,this.T,this.T,this.options).projectRound());return projections}projectSquare(){const projections=[];if(this.A.eq(this.T)){const projection=new Point(1,1).scalarMultiply(this.strokeProjectionMagnitude).multiply(this.strokeUniformScalar);projections.push(this.A.add(projection),this.A.subtract(projection))}else{const orthogonalProjection=this.calcOrthogonalProjection(this.A,this.T,this.strokeProjectionMagnitude),strokePointingOut=this.scaleUnitVector(getUnitVector(this.createSideVector(this.A,this.T)),-this.strokeProjectionMagnitude),projectedA=this.A.add(strokePointingOut);projections.push(projectedA.add(orthogonalProjection),projectedA.subtract(orthogonalProjection))}return projections.map((p=>this.applySkew(p)))}projectPoints(){switch(this.options.strokeLineCap){case"round":return this.projectRound();case"square":return this.projectSquare();default:return this.projectButt()}}project(){return this.projectPoints().map((point=>({originPoint:this.A,projectedPoint:point})))}}const projectStrokeOnPoints=function(points,options){let openPath=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const projections=[];if(0===points.length)return projections;const reduced=points.reduce(((reduced,point)=>(reduced[reduced.length-1].eq(point)||reduced.push(new Point(point)),reduced)),[new Point(points[0])]);if(1===reduced.length)openPath=!0;else if(!openPath){const start=reduced[0],index=((array,predicate)=>{for(let index=array.length-1;index>=0;index--)if(predicate(array[index],index,array))return index;return-1})(reduced,(point=>!point.eq(start)));reduced.splice(index+1)}return reduced.forEach(((A,index,points)=>{let B,C;0===index?(C=points[1],B=openPath?A:points[points.length-1]):index===points.length-1?(B=points[index-1],C=openPath?A:points[0]):(B=points[index-1],C=points[index+1]),openPath&&1===points.length?projections.push(...new StrokeLineCapProjections(A,A,options).project()):!openPath||0!==index&&index!==points.length-1?projections.push(...new StrokeLineJoinProjections(A,B,C,options).project()):projections.push(...new StrokeLineCapProjections(A,0===index?C:B,options).project())})),projections},hasStyleChanged=function(prevStyle,thisStyle){let forTextSpans=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return prevStyle.fill!==thisStyle.fill||prevStyle.stroke!==thisStyle.stroke||prevStyle.strokeWidth!==thisStyle.strokeWidth||prevStyle.fontSize!==thisStyle.fontSize||prevStyle.fontFamily!==thisStyle.fontFamily||prevStyle.fontWeight!==thisStyle.fontWeight||prevStyle.fontStyle!==thisStyle.fontStyle||prevStyle.textBackgroundColor!==thisStyle.textBackgroundColor||prevStyle.deltaY!==thisStyle.deltaY||forTextSpans&&(prevStyle.overline!==thisStyle.overline||prevStyle.underline!==thisStyle.underline||prevStyle.linethrough!==thisStyle.linethrough)},stylesToArray=(styles,text)=>{const textLines=text.split("\n"),stylesArray=[];let charIndex=-1,prevStyle={};styles=cloneDeep(styles);for(let i=0;i<textLines.length;i++)if(styles[i])for(let c=0;c<textLines[i].length;c++){charIndex++;const thisStyle=styles[i][c];thisStyle&&Object.keys(thisStyle).length>0&&(hasStyleChanged(prevStyle,thisStyle,!0)?stylesArray.push({start:charIndex,end:charIndex+1,style:thisStyle}):stylesArray[stylesArray.length-1].end++),prevStyle=thisStyle||{}}else charIndex+=textLines[i].length,prevStyle={};return stylesArray},stylesFromArray=(styles,text)=>{if(!Array.isArray(styles))return cloneDeep(styles);const textLines=text.split(reNewline),stylesObject={};let charIndex=-1,styleIndex=0;for(let i=0;i<textLines.length;i++)for(let c=0;c<textLines[i].length;c++)charIndex++,styles[styleIndex]&&styles[styleIndex].start<=charIndex&&charIndex<styles[styleIndex].end&&(stylesObject[i]=stylesObject[i]||{},stylesObject[i][c]=_objectSpread2({},styles[styleIndex].style),charIndex===styles[styleIndex].end-1&&styleIndex++);return stylesObject},SHARED_ATTRIBUTES=["display","transform","fill","fill-opacity","fill-rule","opacity","stroke","stroke-dasharray","stroke-linecap","stroke-dashoffset","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","id","paint-order","vector-effect","instantiated_by_use","clip-path"];function getSvgRegex(arr){return new RegExp("^("+arr.join("|")+")\\b","i")}var _templateObject$2,_templateObject2$1;const reNum=String.raw(_templateObject$2||(_templateObject$2=_taggedTemplateLiteral(["(?:[-+]?(?:d*.d+|d+.?)(?:[eE][-+]?d+)?)"],["(?:[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?)"])));String.raw(_templateObject2$1||(_templateObject2$1=_taggedTemplateLiteral(["(?:s+,?s*|,s*|$)"],["(?:\\s+,?\\s*|,\\s*|$)"])));const reFontDeclaration=new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*("+reNum+"(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|"+reNum+"))?\\s+(.*)"),attributesMap={cx:LEFT,x:LEFT,r:"radius",cy:TOP,y:TOP,display:"visible",visibility:"visible",transform:"transformMatrix","fill-opacity":"fillOpacity","fill-rule":"fillRule","font-family":"fontFamily","font-size":"fontSize","font-style":"fontStyle","font-weight":"fontWeight","letter-spacing":"charSpacing","paint-order":"paintFirst","stroke-dasharray":"strokeDashArray","stroke-dashoffset":"strokeDashOffset","stroke-linecap":"strokeLineCap","stroke-linejoin":"strokeLineJoin","stroke-miterlimit":"strokeMiterLimit","stroke-opacity":"strokeOpacity","stroke-width":"strokeWidth","text-decoration":"textDecoration","text-anchor":"textAnchor",opacity:"opacity","clip-path":"clipPath","clip-rule":"clipRule","vector-effect":"strokeUniform","image-rendering":"imageSmoothing"},svgValidParentsRegEx=(getSvgRegex(["path","circle","polygon","polyline","ellipse","rect","line","image","text"]),getSvgRegex(["symbol","image","marker","pattern","view","svg"]),getSvgRegex(["symbol","g","a","svg","clipPath","defs"]));new RegExp("^\\s*("+reNum+"+)\\s*,?\\s*("+reNum+"+)\\s*,?\\s*("+reNum+"+)\\s*,?\\s*("+reNum+"+)\\s*$");function selectorMatches(element,selector){const nodeName=element.nodeName,classNames=element.getAttribute("class"),id=element.getAttribute("id");let matcher;if(matcher=new RegExp("^"+nodeName,"i"),selector=selector.replace(matcher,""),id&&selector.length&&(matcher=new RegExp("#"+id+"(?![a-zA-Z\\-]+)","i"),selector=selector.replace(matcher,"")),classNames&&selector.length){const splitClassNames=classNames.split(" ");for(let i=splitClassNames.length;i--;)matcher=new RegExp("\\."+splitClassNames[i]+"(?![a-zA-Z\\-]+)","i"),selector=selector.replace(matcher,"")}return 0===selector.length}function elementMatchesRule(element,selectors){let parentMatching=!0;const firstMatching=selectorMatches(element,selectors.pop());return firstMatching&&selectors.length&&(parentMatching=function doesSomeParentMatch(element,selectors){let selector,parentMatching=!0;for(;element.parentElement&&1===element.parentElement.nodeType&&selectors.length;)parentMatching&&(selector=selectors.pop()),parentMatching=selectorMatches(element=element.parentElement,selector);return 0===selectors.length}(element,selectors)),firstMatching&&parentMatching&&0===selectors.length}const normalizeAttr=attr=>{var _attributesMap;return null!==(_attributesMap=attributesMap[attr])&&void 0!==_attributesMap?_attributesMap:attr},cleanupSvgAttribute=attributeValue=>attributeValue.replace(new RegExp("(".concat(reNum,")"),"gi")," $1 ").replace(/,/gi," ").replace(/\s+/gi," ");var _templateObject$1,_templateObject2,_templateObject3,_templateObject4,_templateObject5,_templateObject6,_templateObject7;const p$1="(".concat(reNum,")"),skewX=String.raw(_templateObject$1||(_templateObject$1=_taggedTemplateLiteral(["(skewX)(",")"],["(skewX)\\(","\\)"])),p$1),skewY=String.raw(_templateObject2||(_templateObject2=_taggedTemplateLiteral(["(skewY)(",")"],["(skewY)\\(","\\)"])),p$1),rotate=String.raw(_templateObject3||(_templateObject3=_taggedTemplateLiteral(["(rotate)(","(?: "," ",")?)"],["(rotate)\\(","(?: "," ",")?\\)"])),p$1,p$1,p$1),scale=String.raw(_templateObject4||(_templateObject4=_taggedTemplateLiteral(["(scale)(","(?: ",")?)"],["(scale)\\(","(?: ",")?\\)"])),p$1,p$1),translate=String.raw(_templateObject5||(_templateObject5=_taggedTemplateLiteral(["(translate)(","(?: ",")?)"],["(translate)\\(","(?: ",")?\\)"])),p$1,p$1),matrix=String.raw(_templateObject6||(_templateObject6=_taggedTemplateLiteral(["(matrix)("," "," "," "," "," ",")"],["(matrix)\\("," "," "," "," "," ","\\)"])),p$1,p$1,p$1,p$1,p$1,p$1),transform="(?:".concat(matrix,"|").concat(translate,"|").concat(rotate,"|").concat(scale,"|").concat(skewX,"|").concat(skewY,")"),transforms="(?:".concat(transform,"*)"),transformList=String.raw(_templateObject7||(_templateObject7=_taggedTemplateLiteral(["^s*(?:","?)s*$"],["^\\s*(?:","?)\\s*$"])),transforms),reTransformList=new RegExp(transformList),reTransform=new RegExp(transform,"g");function parseTransformAttribute(attributeValue){const matrices=[];if(!(attributeValue=cleanupSvgAttribute(attributeValue).replace(/\s*([()])\s*/gi,"$1"))||attributeValue&&!reTransformList.test(attributeValue))return[...iMatrix];for(const match of attributeValue.matchAll(reTransform)){const transformMatch=new RegExp(transform).exec(match[0]);if(!transformMatch)continue;let matrix=iMatrix;const matchedParams=transformMatch.filter((m=>!!m)),[,operation,...rawArgs]=matchedParams,[arg0,arg1,arg2,arg3,arg4,arg5]=rawArgs.map((arg=>parseFloat(arg)));switch(operation){case"translate":matrix=createTranslateMatrix(arg0,arg1);break;case"rotate":matrix=createRotateMatrix({angle:arg0},{x:arg1,y:arg2});break;case"scale":matrix=createScaleMatrix(arg0,arg1);break;case"skewX":matrix=createSkewXMatrix(arg0);break;case"skewY":matrix=createSkewYMatrix(arg0);break;case"matrix":matrix=[arg0,arg1,arg2,arg3,arg4,arg5]}matrices.push(matrix)}return multiplyTransformMatrixArray(matrices)}function normalizeValue(attr,value,parentAttributes,fontSize){const isArray=Array.isArray(value);let parsed,ouputValue=value;if("fill"!==attr&&"stroke"!==attr||value!==NONE){if("strokeUniform"===attr)return"non-scaling-stroke"===value;if("strokeDashArray"===attr)ouputValue=value===NONE?null:value.replace(/,/g," ").split(/\s+/).map(parseFloat);else if("transformMatrix"===attr)ouputValue=parentAttributes&&parentAttributes.transformMatrix?multiplyTransformMatrices(parentAttributes.transformMatrix,parseTransformAttribute(value)):parseTransformAttribute(value);else if("visible"===attr)ouputValue=value!==NONE&&"hidden"!==value,parentAttributes&&!1===parentAttributes.visible&&(ouputValue=!1);else if("opacity"===attr)ouputValue=parseFloat(value),parentAttributes&&void 0!==parentAttributes.opacity&&(ouputValue*=parentAttributes.opacity);else if("textAnchor"===attr)ouputValue="start"===value?LEFT:"end"===value?RIGHT:CENTER;else if("charSpacing"===attr)parsed=parseUnit(value,fontSize)/fontSize*1e3;else if("paintFirst"===attr){const fillIndex=value.indexOf("fill"),strokeIndex=value.indexOf("stroke");ouputValue="fill",(fillIndex>-1&&strokeIndex>-1&&strokeIndex<fillIndex||-1===fillIndex&&strokeIndex>-1)&&(ouputValue="stroke")}else{if("href"===attr||"xlink:href"===attr||"font"===attr)return value;if("imageSmoothing"===attr)return"optimizeQuality"===value;parsed=isArray?value.map(parseUnit):parseUnit(value,fontSize)}}else ouputValue="";return!isArray&&isNaN(parsed)?ouputValue:parsed}function parseStyleAttribute(element){const oStyle={},style=element.getAttribute("style");return style?("string"==typeof style?function parseStyleString(style,oStyle){style.replace(/;\s*$/,"").split(";").forEach((chunk=>{const[attr,value]=chunk.split(":");oStyle[attr.trim().toLowerCase()]=value.trim()}))}(style,oStyle):function parseStyleObject(style,oStyle){Object.entries(style).forEach((_ref=>{let[prop,value]=_ref;void 0!==value&&(oStyle[prop.toLowerCase()]=value)}))}(style,oStyle),oStyle):oStyle}const colorAttributesMap={stroke:"strokeOpacity",fill:"fillOpacity"};function parseAttributes(element,attributes,cssRules){if(!element)return{};let fontSize,parentAttributes={},parentFontSize=DEFAULT_SVG_FONT_SIZE;element.parentNode&&svgValidParentsRegEx.test(element.parentNode.nodeName)&&(parentAttributes=parseAttributes(element.parentElement,attributes,cssRules),parentAttributes.fontSize&&(fontSize=parentFontSize=parseUnit(parentAttributes.fontSize)));const ownAttributes=_objectSpread2(_objectSpread2(_objectSpread2({},attributes.reduce(((memo,attr)=>{const value=element.getAttribute(attr);return value&&(memo[attr]=value),memo}),{})),function getGlobalStylesForElement(element){let cssRules=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},styles={};for(const rule in cssRules)elementMatchesRule(element,rule.split(" "))&&(styles=_objectSpread2(_objectSpread2({},styles),cssRules[rule]));return styles}(element,cssRules)),parseStyleAttribute(element));ownAttributes["clip-path"]&&element.setAttribute("clip-path",ownAttributes["clip-path"]),ownAttributes["font-size"]&&(fontSize=parseUnit(ownAttributes["font-size"],parentFontSize),ownAttributes["font-size"]="".concat(fontSize));const normalizedStyle={};for(const attr in ownAttributes){const normalizedAttr=normalizeAttr(attr),normalizedValue=normalizeValue(normalizedAttr,ownAttributes[attr],parentAttributes,fontSize);normalizedStyle[normalizedAttr]=normalizedValue}normalizedStyle&&normalizedStyle.font&&function parseFontDeclaration(value,oStyle){const match=value.match(reFontDeclaration);if(!match)return;const fontStyle=match[1],fontWeight=match[3],fontSize=match[4],lineHeight=match[5],fontFamily=match[6];fontStyle&&(oStyle.fontStyle=fontStyle),fontWeight&&(oStyle.fontWeight=isNaN(parseFloat(fontWeight))?fontWeight:parseFloat(fontWeight)),fontSize&&(oStyle.fontSize=parseUnit(fontSize)),fontFamily&&(oStyle.fontFamily=fontFamily),lineHeight&&(oStyle.lineHeight="normal"===lineHeight?1:lineHeight)}(normalizedStyle.font,normalizedStyle);const mergedAttrs=_objectSpread2(_objectSpread2({},parentAttributes),normalizedStyle);return svgValidParentsRegEx.test(element.nodeName)?mergedAttrs:function setStrokeFillOpacity(attributes){const defaults=FabricObject.getDefaults();return Object.entries(colorAttributesMap).forEach((_ref=>{let[attr,colorAttr]=_ref;if(void 0===attributes[colorAttr]||""===attributes[attr])return;if(void 0===attributes[attr]){if(!defaults[attr])return;attributes[attr]=defaults[attr]}if(0===attributes[attr].indexOf("url("))return;const color=new Color(attributes[attr]);attributes[attr]=color.setAlpha(toFixed(color.getAlpha()*attributes[colorAttr],2)).toRgba()})),attributes}(mergedAttrs)}const _excluded$f=["left","top","width","height","visible"],RECT_PROPS=["rx","ry"];class Rect extends FabricObject{static getDefaults(){return _objectSpread2(_objectSpread2({},super.getDefaults()),Rect.ownDefaults)}constructor(options){super(options),this._initRxRy()}_initRxRy(){const{rx,ry}=this;rx&&!ry?this.ry=rx:ry&&!rx&&(this.rx=ry)}_render(ctx){const{width:w,height:h}=this,x=-w/2,y=-h/2,rx=this.rx?Math.min(this.rx,w/2):0,ry=this.ry?Math.min(this.ry,h/2):0,isRounded=0!==rx||0!==ry;ctx.beginPath(),ctx.moveTo(x+rx,y),ctx.lineTo(x+w-rx,y),isRounded&&ctx.bezierCurveTo(x+w-kRect*rx,y,x+w,y+kRect*ry,x+w,y+ry),ctx.lineTo(x+w,y+h-ry),isRounded&&ctx.bezierCurveTo(x+w,y+h-kRect*ry,x+w-kRect*rx,y+h,x+w-rx,y+h),ctx.lineTo(x+rx,y+h),isRounded&&ctx.bezierCurveTo(x+kRect*rx,y+h,x,y+h-kRect*ry,x,y+h-ry),ctx.lineTo(x,y+ry),isRounded&&ctx.bezierCurveTo(x,y+kRect*ry,x+kRect*rx,y,x+rx,y),ctx.closePath(),this._renderPaintInOrder(ctx)}toObject(){let propertiesToInclude=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return super.toObject([...RECT_PROPS,...propertiesToInclude])}_toSVG(){const{width,height,rx,ry}=this;return["<rect ","COMMON_PARTS",'x="'.concat(-width/2,'" y="').concat(-height/2,'" rx="').concat(rx,'" ry="').concat(ry,'" width="').concat(width,'" height="').concat(height,'" />\n')]}static async fromElement(element,options,cssRules){const _parseAttributes=parseAttributes(element,this.ATTRIBUTE_NAMES,cssRules),{left=0,top=0,width=0,height=0,visible=!0}=_parseAttributes,restOfparsedAttributes=_objectWithoutProperties(_parseAttributes,_excluded$f);return new this(_objectSpread2(_objectSpread2(_objectSpread2({},options),restOfparsedAttributes),{},{left,top,width,height,visible:Boolean(visible&&width&&height)}))}}_defineProperty(Rect,"type","Rect"),_defineProperty(Rect,"cacheProperties",[...cacheProperties,...RECT_PROPS]),_defineProperty(Rect,"ownDefaults",{rx:0,ry:0}),_defineProperty(Rect,"ATTRIBUTE_NAMES",[...SHARED_ATTRIBUTES,"x","y","rx","ry","width","height"]),classRegistry.setClass(Rect),classRegistry.setSVGClass(Rect);const getObjectBounds=(destinationGroup,object)=>{const{strokeUniform,strokeWidth,width,height,group:currentGroup}=object,t=currentGroup&&currentGroup!==destinationGroup?calcPlaneChangeMatrix(currentGroup.calcTransformMatrix(),destinationGroup.calcTransformMatrix()):null,objectCenter=t?object.getRelativeCenterPoint().transform(t):object.getRelativeCenterPoint(),accountForStroke=!object.isStrokeAccountedForInDimensions(),strokeUniformVector=strokeUniform&&accountForStroke?sendVectorToPlane(new Point(strokeWidth,strokeWidth),void 0,destinationGroup.calcTransformMatrix()):ZERO,scalingStrokeWidth=!strokeUniform&&accountForStroke?strokeWidth:0,sizeVector=sizeAfterTransform(width+scalingStrokeWidth,height+scalingStrokeWidth,multiplyTransformMatrixArray([t,object.calcOwnMatrix()],!0)).add(strokeUniformVector).scalarDivide(2);return[objectCenter.subtract(sizeVector),objectCenter.add(sizeVector)]};class LayoutStrategy{calcLayoutResult(context,objects){if(this.shouldPerformLayout(context))return this.calcBoundingBox(objects,context)}shouldPerformLayout(context){return"initialization"===context.type||"imperative"===context.type||!!context.prevStrategy&&context.strategy!==context.prevStrategy}shouldLayoutClipPath(_ref){let{type,target:{clipPath}}=_ref;return"initialization"!==type&&clipPath&&!clipPath.absolutePositioned}getInitialSize(context,result){return result.size}calcBoundingBox(objects,context){if("imperative"===context.type&&context.overrides)return context.overrides;if(0===objects.length)return;const{target}=context,{left,top,width,height}=makeBoundingBoxFromPoints(objects.map((object=>getObjectBounds(target,object))).reduce(((coords,curr)=>coords.concat(curr)),[])),bboxSize=new Point(width,height),bboxLeftTop=new Point(left,top),bboxCenter=bboxLeftTop.add(bboxSize.scalarDivide(2));if("initialization"===context.type){const actualSize=this.getInitialSize(context,{size:bboxSize,center:bboxCenter}),originFactor=new Point(-resolveOrigin(target.originX),-resolveOrigin(target.originY)),sizeCorrection=actualSize.subtract(bboxSize).multiply(originFactor),center=bboxLeftTop.add(bboxSize.multiply(originFactor));return{center:center.add(sizeCorrection),relativeCorrection:center.subtract(bboxCenter),size:actualSize}}return{center:bboxCenter.transform(target.calcOwnMatrix()),size:bboxSize}}}_defineProperty(LayoutStrategy,"type","strategy");class FitContentLayout extends LayoutStrategy{shouldPerformLayout(context){return!0}}_defineProperty(FitContentLayout,"type","fit-content"),classRegistry.setClass(FitContentLayout);const _excluded$e=["strategy"],_excluded2$3=["target","strategy","bubbles","prevStrategy"];class LayoutManager{constructor(){let strategy=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new FitContentLayout;_defineProperty(this,"strategy",void 0),this.strategy=strategy,this._subscriptions=new Map}performLayout(context){const strictContext=_objectSpread2(_objectSpread2({bubbles:!0,strategy:this.strategy},context),{},{prevStrategy:this._prevLayoutStrategy,stopPropagation(){this.bubbles=!1}});this.onBeforeLayout(strictContext);const layoutResult=this.getLayoutResult(strictContext);layoutResult&&this.commitLayout(strictContext,layoutResult),this.onAfterLayout(strictContext,layoutResult),this._prevLayoutStrategy=strictContext.strategy}subscribe(object,context){const{target}=context;this.unsubscribe(object,context);const disposers=[object.on("modified",(e=>this.performLayout({trigger:"modified",e:_objectSpread2(_objectSpread2({},e),{},{target:object}),type:"object_modified",target}))),...["moving","resizing","rotating","scaling","skewing","changed","modifyPoly"].map((key=>object.on(key,(e=>this.performLayout({trigger:key,e:_objectSpread2(_objectSpread2({},e),{},{target:object}),type:"object_modifying",target})))))];this._subscriptions.set(object,disposers)}unsubscribe(object,context){(this._subscriptions.get(object)||[]).forEach((d=>d())),this._subscriptions.delete(object)}unsubscribeTarget(target){target.forEachObject((object=>this.unsubscribe(object)))}onBeforeLayout(context){const{target}=context,{canvas}=target;if("initialization"===context.type||"added"===context.type?context.targets.forEach((object=>this.subscribe(object,context))):"removed"===context.type&&context.targets.forEach((object=>this.unsubscribe(object,context))),target.fire("layout:before",{context}),canvas&&canvas.fire("object:layout:before",{target,context}),"imperative"===context.type&&context.deep){const tricklingContext=_objectWithoutProperties(context,_excluded$e);target.forEachObject((object=>{var _layoutManager;null===(_layoutManager=object.layoutManager)||void 0===_layoutManager||_layoutManager.performLayout(_objectSpread2(_objectSpread2({},tricklingContext),{},{bubbles:!1,target:object}))}))}}getLayoutResult(context){const{target}=context,result=context.strategy.calcLayoutResult(context,target.getObjects());if(!result)return;const prevCenter="initialization"===context.type?new Point:target.getRelativeCenterPoint(),{center:nextCenter,correction=new Point,relativeCorrection=new Point}=result,offset=prevCenter.subtract(nextCenter).add(correction).transform("initialization"===context.type?iMatrix:invertTransform(target.calcOwnMatrix()),!0).add(relativeCorrection);return{result,prevCenter,nextCenter,offset}}commitLayout(context,layoutResult){const{target}=context,{result:{size},nextCenter}=layoutResult;var _context$x,_context$y;(target.set({width:size.x,height:size.y}),this.layoutObjects(context,layoutResult),"initialization"===context.type)?target.set({left:null!==(_context$x=context.x)&&void 0!==_context$x?_context$x:nextCenter.x+size.x*resolveOrigin(target.originX),top:null!==(_context$y=context.y)&&void 0!==_context$y?_context$y:nextCenter.y+size.y*resolveOrigin(target.originY)}):(target.setPositionByOrigin(nextCenter,CENTER,CENTER),target.setCoords(),target.set({dirty:!0}))}layoutObjects(context,layoutResult){const{target}=context;target.forEachObject((object=>{object.group===target&&this.layoutObject(context,layoutResult,object)})),context.strategy.shouldLayoutClipPath(context)&&this.layoutObject(context,layoutResult,target.clipPath)}layoutObject(context,_ref,object){let{offset}=_ref;object.set({left:object.left+offset.x,top:object.top+offset.y})}onAfterLayout(context,layoutResult){const{target,strategy,bubbles,prevStrategy:_}=context,bubblingContext=_objectWithoutProperties(context,_excluded2$3),{canvas}=target;target.fire("layout:after",{context,result:layoutResult}),canvas&&canvas.fire("object:layout:after",{context,result:layoutResult,target});const parent=target.group;bubbles&&null!=parent&&parent.layoutManager&&((bubblingContext.path||(bubblingContext.path=[])).push(target),parent.layoutManager.performLayout(_objectSpread2(_objectSpread2({},bubblingContext),{},{target:parent})))}dispose(){this._subscriptions.forEach((disposers=>disposers.forEach((d=>d())))),this._subscriptions.clear()}toObject(){return{type:"layoutManager",strategy:this.strategy.constructor.type}}toJSON(){return this.toObject()}}classRegistry.setClass(LayoutManager,"layoutManager");const _excluded$d=["type","objects","layoutManager"];class NoopLayoutManager extends LayoutManager{performLayout(){}}class Group extends(createCollectionMixin(FabricObject)){static getDefaults(){return _objectSpread2(_objectSpread2({},super.getDefaults()),Group.ownDefaults)}constructor(){let objects=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(options),_defineProperty(this,"_activeObjects",[]),_defineProperty(this,"__objectSelectionTracker",void 0),_defineProperty(this,"__objectSelectionDisposer",void 0),this._objects=[...objects],this.__objectSelectionTracker=this.__objectSelectionMonitor.bind(this,!0),this.__objectSelectionDisposer=this.__objectSelectionMonitor.bind(this,!1),this.forEachObject((object=>{this.enterGroup(object,!1)})),this.layoutManager=options.layoutManager||new LayoutManager,this.layoutManager.performLayout({type:"initialization",target:this,targets:[...objects],x:options.left,y:options.top})}canEnterGroup(object){return object===this||this.isDescendantOf(object)?(log("error","Group: circular object trees are not supported, this call has no effect"),!1):-1===this._objects.indexOf(object)||(log("error","Group: duplicate objects are not supported inside group, this call has no effect"),!1)}_filterObjectsBeforeEnteringGroup(objects){return objects.filter(((object,index,array)=>this.canEnterGroup(object)&&array.indexOf(object)===index))}add(){for(var _len=arguments.length,objects=new Array(_len),_key=0;_key<_len;_key++)objects[_key]=arguments[_key];const allowedObjects=this._filterObjectsBeforeEnteringGroup(objects),size=super.add(...allowedObjects);return this._onAfterObjectsChange("added",allowedObjects),size}insertAt(index){for(var _len2=arguments.length,objects=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++)objects[_key2-1]=arguments[_key2];const allowedObjects=this._filterObjectsBeforeEnteringGroup(objects),size=super.insertAt(index,...allowedObjects);return this._onAfterObjectsChange("added",allowedObjects),size}remove(){const removed=super.remove(...arguments);return this._onAfterObjectsChange("removed",removed),removed}_onObjectAdded(object){this.enterGroup(object,!0),this.fire("object:added",{target:object}),object.fire("added",{target:this})}_onObjectRemoved(object,removeParentTransform){this.exitGroup(object,removeParentTransform),this.fire("object:removed",{target:object}),object.fire("removed",{target:this})}_onAfterObjectsChange(type,targets){this.layoutManager.performLayout({type,targets,target:this})}_onStackOrderChanged(){this._set("dirty",!0)}_set(key,value){const prev=this[key];return super._set(key,value),"canvas"===key&&prev!==value&&(this._objects||[]).forEach((object=>{object._set(key,value)})),this}_shouldSetNestedCoords(){return this.subTargetCheck}removeAll(){return this._activeObjects=[],this.remove(...this._objects)}__objectSelectionMonitor(selected,_ref){let{target:object}=_ref;if(selected)this._activeObjects.push(object),this._set("dirty",!0);else if(this._activeObjects.length>0){const index=this._activeObjects.indexOf(object);index>-1&&(this._activeObjects.splice(index,1),this._set("dirty",!0))}}_watchObject(watch,object){watch&&this._watchObject(!1,object),watch?(object.on("selected",this.__objectSelectionTracker),object.on("deselected",this.__objectSelectionDisposer)):(object.off("selected",this.__objectSelectionTracker),object.off("deselected",this.__objectSelectionDisposer))}enterGroup(object,removeParentTransform){object.group&&object.group.remove(object),object._set("parent",this),this._enterGroup(object,removeParentTransform)}_enterGroup(object,removeParentTransform){removeParentTransform&&applyTransformToObject(object,multiplyTransformMatrices(invertTransform(this.calcTransformMatrix()),object.calcTransformMatrix())),this._shouldSetNestedCoords()&&object.setCoords(),object._set("group",this),object._set("canvas",this.canvas),this._watchObject(!0,object);const activeObject=this.canvas&&this.canvas.getActiveObject&&this.canvas.getActiveObject();activeObject&&(activeObject===object||object.isDescendantOf(activeObject))&&this._activeObjects.push(object)}exitGroup(object,removeParentTransform){this._exitGroup(object,removeParentTransform),object._set("parent",void 0),object._set("canvas",void 0)}_exitGroup(object,removeParentTransform){object._set("group",void 0),removeParentTransform||(applyTransformToObject(object,multiplyTransformMatrices(this.calcTransformMatrix(),object.calcTransformMatrix())),object.setCoords()),this._watchObject(!1,object);const index=this._activeObjects.length>0?this._activeObjects.indexOf(object):-1;index>-1&&this._activeObjects.splice(index,1)}shouldCache(){const ownCache=FabricObject.prototype.shouldCache.call(this);if(ownCache)for(let i=0;i<this._objects.length;i++)if(this._objects[i].willDrawShadow())return this.ownCaching=!1,!1;return ownCache}willDrawShadow(){if(super.willDrawShadow())return!0;for(let i=0;i<this._objects.length;i++)if(this._objects[i].willDrawShadow())return!0;return!1}isOnACache(){return this.ownCaching||!!this.group&&this.group.isOnACache()}drawObject(ctx){this._renderBackground(ctx);for(let i=0;i<this._objects.length;i++){var _this$canvas;null!==(_this$canvas=this.canvas)&&void 0!==_this$canvas&&_this$canvas.preserveObjectStacking&&this._objects[i].group!==this?(ctx.save(),ctx.transform(...invertTransform(this.calcTransformMatrix())),this._objects[i].render(ctx),ctx.restore()):this._objects[i].group===this&&this._objects[i].render(ctx)}this._drawClipPath(ctx,this.clipPath)}setCoords(){super.setCoords(),this._shouldSetNestedCoords()&&this.forEachObject((object=>object.setCoords()))}triggerLayout(){let options=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.layoutManager.performLayout(_objectSpread2({target:this,type:"imperative"},options))}render(ctx){this._transformDone=!0,super.render(ctx),this._transformDone=!1}__serializeObjects(method,propertiesToInclude){const _includeDefaultValues=this.includeDefaultValues;return this._objects.filter((function(obj){return!obj.excludeFromExport})).map((function(obj){const originalDefaults=obj.includeDefaultValues;obj.includeDefaultValues=_includeDefaultValues;const data=obj[method||"toObject"](propertiesToInclude);return obj.includeDefaultValues=originalDefaults,data}))}toObject(){let propertiesToInclude=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];const layoutManager=this.layoutManager.toObject();return _objectSpread2(_objectSpread2(_objectSpread2({},super.toObject(["subTargetCheck","interactive",...propertiesToInclude])),"fit-content"!==layoutManager.strategy||this.includeDefaultValues?{layoutManager}:{}),{},{objects:this.__serializeObjects("toObject",propertiesToInclude)})}toString(){return"#<Group: (".concat(this.complexity(),")>")}dispose(){this.layoutManager.unsubscribeTarget(this),this._activeObjects=[],this.forEachObject((object=>{this._watchObject(!1,object),object.dispose()})),super.dispose()}_createSVGBgRect(reviver){if(!this.backgroundColor)return"";const fillStroke=Rect.prototype._toSVG.call(this),commons=fillStroke.indexOf("COMMON_PARTS");fillStroke[commons]='for="group" ';const markup=fillStroke.join("");return reviver?reviver(markup):markup}_toSVG(reviver){const svgString=["<g ","COMMON_PARTS"," >\n"],bg=this._createSVGBgRect(reviver);bg&&svgString.push("\t\t",bg);for(let i=0;i<this._objects.length;i++)svgString.push("\t\t",this._objects[i].toSVG(reviver));return svgString.push("</g>\n"),svgString}getSvgStyles(){const opacity=void 0!==this.opacity&&1!==this.opacity?"opacity: ".concat(this.opacity,";"):"",visibility=this.visible?"":" visibility: hidden;";return[opacity,this.getSvgFilter(),visibility].join("")}toClipPathSVG(reviver){const svgString=[],bg=this._createSVGBgRect(reviver);bg&&svgString.push("\t",bg);for(let i=0;i<this._objects.length;i++)svgString.push("\t",this._objects[i].toClipPathSVG(reviver));return this._createBaseClipPathSVGMarkup(svgString,{reviver})}static fromObject(_ref2){let{type,objects=[],layoutManager}=_ref2,options=_objectWithoutProperties(_ref2,_excluded$d);return Promise.all([enlivenObjects(objects),enlivenObjectEnlivables(options)]).then((_ref3=>{let[objects,hydratedOptions]=_ref3;const group=new this(objects,_objectSpread2(_objectSpread2(_objectSpread2({},options),hydratedOptions),{},{layoutManager:new NoopLayoutManager}));if(layoutManager){const layoutClass=classRegistry.getClass(layoutManager.type),strategyClass=classRegistry.getClass(layoutManager.strategy);group.layoutManager=new layoutClass(new strategyClass)}else group.layoutManager=new LayoutManager;return group.setCoords(),group}))}}_defineProperty(Group,"type","Group"),_defineProperty(Group,"ownDefaults",{strokeWidth:0,subTargetCheck:!1,interactive:!1}),classRegistry.setClass(Group);const findScaleToFit=(source,destination)=>Math.min(destination.width/source.width,destination.height/source.height),findScaleToCover=(source,destination)=>Math.max(destination.width/source.width,destination.height/source.height),escapeXml=string=>string.replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&apos;").replace(/</g,"&lt;").replace(/>/g,"&gt;"),graphemeSplit=textstring=>{const graphemes=[];for(let chr,i=0;i<textstring.length;i++)!1!==(chr=getWholeChar(textstring,i))&&graphemes.push(chr);return graphemes},getWholeChar=(str,i)=>{const code=str.charCodeAt(i);if(isNaN(code))return"";if(code<55296||code>57343)return str.charAt(i);if(55296<=code&&code<=56319){if(str.length<=i+1)throw"High surrogate without following low surrogate";const next=str.charCodeAt(i+1);if(56320>next||next>57343)throw"High surrogate without following low surrogate";return str.charAt(i)+str.charAt(i+1)}if(0===i)throw"Low surrogate without preceding high surrogate";const prev=str.charCodeAt(i-1);if(55296>prev||prev>56319)throw"Low surrogate without preceding high surrogate";return!1};var _templateObject,lang_string=Object.freeze({__proto__:null,capitalize:function(string){let firstLetterOnly=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return"".concat(string.charAt(0).toUpperCase()).concat(firstLetterOnly?string.slice(1):string.slice(1).toLowerCase())},escapeXml,graphemeSplit});const p="(".concat(reNum,")"),reMoveToCommand="(M) (?:".concat(p," ").concat(p," ?)+"),reLineCommand="(L) (?:".concat(p," ").concat(p," ?)+"),reHorizontalLineCommand="(H) (?:".concat(p," ?)+"),reVerticalLineCommand="(V) (?:".concat(p," ?)+"),reClosePathCommand=String.raw(_templateObject||(_templateObject=_taggedTemplateLiteral(["(Z)s*"],["(Z)\\s*"]))),reCubicCurveCommand="(C) (?:".concat(p," ").concat(p," ").concat(p," ").concat(p," ").concat(p," ").concat(p," ?)+"),reCubicCurveShortcutCommand="(S) (?:".concat(p," ").concat(p," ").concat(p," ").concat(p," ?)+"),reQuadraticCurveCommand="(Q) (?:".concat(p," ").concat(p," ").concat(p," ").concat(p," ?)+"),reQuadraticCurveShortcutCommand="(T) (?:".concat(p," ").concat(p," ?)+"),reArcCommand="(A) (?:".concat(p," ").concat(p," ").concat(p," ([01]) ?([01]) ").concat(p," ").concat(p," ?)+"),rePathCommand="(?:(?:".concat(reMoveToCommand,")")+"|(?:".concat(reLineCommand,")")+"|(?:".concat(reHorizontalLineCommand,")")+"|(?:".concat(reVerticalLineCommand,")")+"|(?:".concat(reClosePathCommand,")")+"|(?:".concat(reCubicCurveCommand,")")+"|(?:".concat(reCubicCurveShortcutCommand,")")+"|(?:".concat(reQuadraticCurveCommand,")")+"|(?:".concat(reQuadraticCurveShortcutCommand,")")+"|(?:".concat(reArcCommand,"))"),repeatedCommands={m:"l",M:"L"},segmentToBezier=(theta1,theta2,cosTh,sinTh,rx,ry,cx1,cy1,mT,fromX,fromY)=>{const costh1=cos(theta1),sinth1=sin(theta1),costh2=cos(theta2),sinth2=sin(theta2),toX=cosTh*rx*costh2-sinTh*ry*sinth2+cx1,toY=sinTh*rx*costh2+cosTh*ry*sinth2+cy1;return["C",fromX+mT*(-cosTh*rx*sinth1-sinTh*ry*costh1),fromY+mT*(-sinTh*rx*sinth1+cosTh*ry*costh1),toX+mT*(cosTh*rx*sinth2+sinTh*ry*costh2),toY+mT*(sinTh*rx*sinth2-cosTh*ry*costh2),toX,toY]},calcVectorAngle=(ux,uy,vx,vy)=>{const ta=Math.atan2(uy,ux),tb=Math.atan2(vy,vx);return tb>=ta?tb-ta:2*Math.PI-(ta-tb)};function getBoundsOfCurve(begx,begy,cp1x,cp1y,cp2x,cp2y,endx,endy){let argsString;if(config.cachesBoundsOfCurve&&(argsString=[...arguments].join(),cache.boundsOfCurveCache[argsString]))return cache.boundsOfCurveCache[argsString];const sqrt=Math.sqrt,abs=Math.abs,tvalues=[],bounds=[[0,0],[0,0]];let b=6*begx-12*cp1x+6*cp2x,a=-3*begx+9*cp1x-9*cp2x+3*endx,c=3*cp1x-3*begx;for(let i=0;i<2;++i){if(i>0&&(b=6*begy-12*cp1y+6*cp2y,a=-3*begy+9*cp1y-9*cp2y+3*endy,c=3*cp1y-3*begy),abs(a)<1e-12){if(abs(b)<1e-12)continue;const t=-c/b;0<t&&t<1&&tvalues.push(t);continue}const b2ac=b*b-4*c*a;if(b2ac<0)continue;const sqrtb2ac=sqrt(b2ac),t1=(-b+sqrtb2ac)/(2*a);0<t1&&t1<1&&tvalues.push(t1);const t2=(-b-sqrtb2ac)/(2*a);0<t2&&t2<1&&tvalues.push(t2)}let j=tvalues.length;const jlen=j,iterator=getPointOnCubicBezierIterator(begx,begy,cp1x,cp1y,cp2x,cp2y,endx,endy);for(;j--;){const{x,y}=iterator(tvalues[j]);bounds[0][j]=x,bounds[1][j]=y}bounds[0][jlen]=begx,bounds[1][jlen]=begy,bounds[0][jlen+1]=endx,bounds[1][jlen+1]=endy;const result=[new Point(Math.min(...bounds[0]),Math.min(...bounds[1])),new Point(Math.max(...bounds[0]),Math.max(...bounds[1]))];return config.cachesBoundsOfCurve&&(cache.boundsOfCurveCache[argsString]=result),result}const fromArcToBeziers=(fx,fy,_ref)=>{let[_,rx,ry,rot,large,sweep,tx,ty]=_ref;const segsNorm=((toX,toY,rx,ry,large,sweep,rotateX)=>{if(0===rx||0===ry)return[];let fromX=0,fromY=0,root=0;const PI=Math.PI,theta=rotateX*PiBy180,sinTheta=sin(theta),cosTh=cos(theta),px=.5*(-cosTh*toX-sinTheta*toY),py=.5*(-cosTh*toY+sinTheta*toX),rx2=rx**2,ry2=ry**2,py2=py**2,px2=px**2,pl=rx2*ry2-rx2*py2-ry2*px2;let _rx=Math.abs(rx),_ry=Math.abs(ry);if(pl<0){const s=Math.sqrt(1-pl/(rx2*ry2));_rx*=s,_ry*=s}else root=(large===sweep?-1:1)*Math.sqrt(pl/(rx2*py2+ry2*px2));const cx=root*_rx*py/_ry,cy=-root*_ry*px/_rx,cx1=cosTh*cx-sinTheta*cy+.5*toX,cy1=sinTheta*cx+cosTh*cy+.5*toY;let mTheta=calcVectorAngle(1,0,(px-cx)/_rx,(py-cy)/_ry),dtheta=calcVectorAngle((px-cx)/_rx,(py-cy)/_ry,(-px-cx)/_rx,(-py-cy)/_ry);0===sweep&&dtheta>0?dtheta-=2*PI:1===sweep&&dtheta<0&&(dtheta+=2*PI);const segments=Math.ceil(Math.abs(dtheta/PI*2)),result=new Array(segments),mDelta=dtheta/segments,mT=8/3*Math.sin(mDelta/4)*Math.sin(mDelta/4)/Math.sin(mDelta/2);let th3=mTheta+mDelta;for(let i=0;i<segments;i++)result[i]=segmentToBezier(mTheta,th3,cosTh,sinTheta,_rx,_ry,cx1,cy1,mT,fromX,fromY),fromX=result[i][5],fromY=result[i][6],mTheta=th3,th3+=mDelta;return result})(tx-fx,ty-fy,rx,ry,large,sweep,rot);for(let i=0,len=segsNorm.length;i<len;i++)segsNorm[i][1]+=fx,segsNorm[i][2]+=fy,segsNorm[i][3]+=fx,segsNorm[i][4]+=fy,segsNorm[i][5]+=fx,segsNorm[i][6]+=fy;return segsNorm},makePathSimpler=path=>{let x=0,y=0,x1=0,y1=0;const destinationPath=[];let previous,controlX=0,controlY=0;for(const parsedCommand of path){const current=[...parsedCommand];let converted;switch(current[0]){case"l":current[1]+=x,current[2]+=y;case"L":x=current[1],y=current[2],converted=["L",x,y];break;case"h":current[1]+=x;case"H":x=current[1],converted=["L",x,y];break;case"v":current[1]+=y;case"V":y=current[1],converted=["L",x,y];break;case"m":current[1]+=x,current[2]+=y;case"M":x=current[1],y=current[2],x1=current[1],y1=current[2],converted=["M",x,y];break;case"c":current[1]+=x,current[2]+=y,current[3]+=x,current[4]+=y,current[5]+=x,current[6]+=y;case"C":controlX=current[3],controlY=current[4],x=current[5],y=current[6],converted=["C",current[1],current[2],controlX,controlY,x,y];break;case"s":current[1]+=x,current[2]+=y,current[3]+=x,current[4]+=y;case"S":"C"===previous?(controlX=2*x-controlX,controlY=2*y-controlY):(controlX=x,controlY=y),x=current[3],y=current[4],converted=["C",controlX,controlY,current[1],current[2],x,y],controlX=converted[3],controlY=converted[4];break;case"q":current[1]+=x,current[2]+=y,current[3]+=x,current[4]+=y;case"Q":controlX=current[1],controlY=current[2],x=current[3],y=current[4],converted=["Q",controlX,controlY,x,y];break;case"t":current[1]+=x,current[2]+=y;case"T":"Q"===previous?(controlX=2*x-controlX,controlY=2*y-controlY):(controlX=x,controlY=y),x=current[1],y=current[2],converted=["Q",controlX,controlY,x,y];break;case"a":current[6]+=x,current[7]+=y;case"A":fromArcToBeziers(x,y,current).forEach((b=>destinationPath.push(b))),x=current[6],y=current[7];break;case"z":case"Z":x=x1,y=y1,converted=["Z"]}converted?(destinationPath.push(converted),previous=converted[0]):previous=""}return destinationPath},calcLineLength=(x1,y1,x2,y2)=>Math.sqrt((x2-x1)**2+(y2-y1)**2),getPointOnCubicBezierIterator=(begx,begy,cp1x,cp1y,cp2x,cp2y,endx,endy)=>pct=>{const c1=pct**3,c2=(t=>3*t**2*(1-t))(pct),c3=(t=>3*t*(1-t)**2)(pct),c4=(t=>(1-t)**3)(pct);return new Point(endx*c1+cp2x*c2+cp1x*c3+begx*c4,endy*c1+cp2y*c2+cp1y*c3+begy*c4)},QB1=t=>t**2,QB2=t=>2*t*(1-t),QB3=t=>(1-t)**2,getTangentCubicIterator=(p1x,p1y,p2x,p2y,p3x,p3y,p4x,p4y)=>pct=>{const qb1=QB1(pct),qb2=QB2(pct),qb3=QB3(pct),tangentX=3*(qb3*(p2x-p1x)+qb2*(p3x-p2x)+qb1*(p4x-p3x)),tangentY=3*(qb3*(p2y-p1y)+qb2*(p3y-p2y)+qb1*(p4y-p3y));return Math.atan2(tangentY,tangentX)},getPointOnQuadraticBezierIterator=(p1x,p1y,p2x,p2y,p3x,p3y)=>pct=>{const c1=QB1(pct),c2=QB2(pct),c3=QB3(pct);return new Point(p3x*c1+p2x*c2+p1x*c3,p3y*c1+p2y*c2+p1y*c3)},getTangentQuadraticIterator=(p1x,p1y,p2x,p2y,p3x,p3y)=>pct=>{const invT=1-pct,tangentX=2*(invT*(p2x-p1x)+pct*(p3x-p2x)),tangentY=2*(invT*(p2y-p1y)+pct*(p3y-p2y));return Math.atan2(tangentY,tangentX)},pathIterator=(iterator,x1,y1)=>{let tempP=new Point(x1,y1),tmpLen=0;for(let perc=1;perc<=100;perc+=1){const p=iterator(perc/100);tmpLen+=calcLineLength(tempP.x,tempP.y,p.x,p.y),tempP=p}return tmpLen},findPercentageForDistance=(segInfo,distance)=>{let nextLen,perc=0,tmpLen=0,tempP={x:segInfo.x,y:segInfo.y},p=_objectSpread2({},tempP),nextStep=.01,lastPerc=0;const iterator=segInfo.iterator,angleFinder=segInfo.angleFinder;for(;tmpLen<distance&&nextStep>1e-4;)p=iterator(perc),lastPerc=perc,nextLen=calcLineLength(tempP.x,tempP.y,p.x,p.y),nextLen+tmpLen>distance?(perc-=nextStep,nextStep/=2):(tempP=p,perc+=nextStep,tmpLen+=nextLen);return _objectSpread2(_objectSpread2({},p),{},{angle:angleFinder(lastPerc)})},getPathSegmentsInfo=path=>{let iterator,tempInfo,totalLength=0,x1=0,y1=0,x2=0,y2=0;const info=[];for(const current of path){const basicInfo={x:x1,y:y1,command:current[0],length:0};switch(current[0]){case"M":tempInfo=basicInfo,tempInfo.x=x2=x1=current[1],tempInfo.y=y2=y1=current[2];break;case"L":tempInfo=basicInfo,tempInfo.length=calcLineLength(x1,y1,current[1],current[2]),x1=current[1],y1=current[2];break;case"C":iterator=getPointOnCubicBezierIterator(x1,y1,current[1],current[2],current[3],current[4],current[5],current[6]),tempInfo=basicInfo,tempInfo.iterator=iterator,tempInfo.angleFinder=getTangentCubicIterator(x1,y1,current[1],current[2],current[3],current[4],current[5],current[6]),tempInfo.length=pathIterator(iterator,x1,y1),x1=current[5],y1=current[6];break;case"Q":iterator=getPointOnQuadraticBezierIterator(x1,y1,current[1],current[2],current[3],current[4]),tempInfo=basicInfo,tempInfo.iterator=iterator,tempInfo.angleFinder=getTangentQuadraticIterator(x1,y1,current[1],current[2],current[3],current[4]),tempInfo.length=pathIterator(iterator,x1,y1),x1=current[3],y1=current[4];break;case"Z":tempInfo=basicInfo,tempInfo.destX=x2,tempInfo.destY=y2,tempInfo.length=calcLineLength(x1,y1,x2,y2),x1=x2,y1=y2}totalLength+=tempInfo.length,info.push(tempInfo)}return info.push({length:totalLength,x:x1,y:y1}),info},getPointOnPath=function(path,distance){let infos=arguments.length>2&&void 0!==arguments[2]?arguments[2]:getPathSegmentsInfo(path),i=0;for(;distance-infos[i].length>0&&i<infos.length-2;)distance-=infos[i].length,i++;const segInfo=infos[i],segPercent=distance/segInfo.length,segment=path[i];switch(segInfo.command){case"M":return{x:segInfo.x,y:segInfo.y,angle:0};case"Z":return _objectSpread2(_objectSpread2({},new Point(segInfo.x,segInfo.y).lerp(new Point(segInfo.destX,segInfo.destY),segPercent)),{},{angle:Math.atan2(segInfo.destY-segInfo.y,segInfo.destX-segInfo.x)});case"L":return _objectSpread2(_objectSpread2({},new Point(segInfo.x,segInfo.y).lerp(new Point(segment[1],segment[2]),segPercent)),{},{angle:Math.atan2(segment[2]-segInfo.y,segment[1]-segInfo.x)});case"C":case"Q":return findPercentageForDistance(segInfo,distance)}},parsePath=pathString=>{pathString=cleanupSvgAttribute(pathString);const res=[];for(const match of pathString.matchAll(new RegExp(rePathCommand,"gi"))){let matchStr=match[0];const chain=[];let paramArr;do{if(paramArr=new RegExp(rePathCommand,"i").exec(matchStr),!paramArr)break;const filteredGroups=paramArr.filter((g=>g));filteredGroups.shift();const command=filteredGroups.map((g=>{const numParse=Number.parseFloat(g);return Number.isNaN(numParse)?g:numParse}));if(chain.push(command),filteredGroups.length<=1)break;filteredGroups.shift(),matchStr=matchStr.replace(new RegExp("".concat(filteredGroups.join(" ?")," ?$")),"")}while(paramArr);chain.reverse().forEach(((c,idx)=>{const transformed=repeatedCommands[c[0]];idx>0&&("l"==transformed||"L"==transformed)&&(c[0]=transformed),res.push(c)}))}return res},getSmoothPathFromPoints=function(points){let correction=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,p1=new Point(points[0]),p2=new Point(points[1]),multSignX=1,multSignY=0;const path=[],len=points.length,manyPoints=len>2;let i;for(manyPoints&&(multSignX=points[2].x<p2.x?-1:points[2].x===p2.x?0:1,multSignY=points[2].y<p2.y?-1:points[2].y===p2.y?0:1),path.push(["M",p1.x-multSignX*correction,p1.y-multSignY*correction]),i=1;i<len;i++){if(!p1.eq(p2)){const midPoint=p1.midPointFrom(p2);path.push(["Q",p1.x,p1.y,midPoint.x,midPoint.y])}p1=points[i],i+1<points.length&&(p2=points[i+1])}return manyPoints&&(multSignX=p1.x>points[i-2].x?1:p1.x===points[i-2].x?0:-1,multSignY=p1.y>points[i-2].y?1:p1.y===points[i-2].y?0:-1),path.push(["L",p1.x+multSignX*correction,p1.y+multSignY*correction]),path},joinPath=(pathData,fractionDigits)=>pathData.map((segment=>segment.map(((arg,i)=>0===i||void 0===fractionDigits?arg:toFixed(arg,fractionDigits))).join(" "))).join(" ");function request(url){let options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const onComplete=options.onComplete||noop,xhr=new(getFabricWindow().XMLHttpRequest),signal=options.signal,abort=function(){xhr.abort()},removeListener=function(){signal&&signal.removeEventListener("abort",abort),xhr.onerror=xhr.ontimeout=noop};if(signal&&signal.aborted)throw new SignalAbortedError("request");return signal&&signal.addEventListener("abort",abort,{once:!0}),xhr.onreadystatechange=function(){4===xhr.readyState&&(removeListener(),onComplete(xhr),xhr.onreadystatechange=noop)},xhr.onerror=xhr.ontimeout=removeListener,xhr.open("get",url,!0),xhr.send(),xhr}const removeTransformMatrixForSvgParsing=(object,preserveAspectRatioOptions)=>{let center=object._findCenterFromElement();object.transformMatrix&&((object=>{if(object.transformMatrix){const{scaleX,scaleY,angle,skewX}=qrDecompose(object.transformMatrix);object.flipX=!1,object.flipY=!1,object.set("scaleX",scaleX),object.set("scaleY",scaleY),object.angle=angle,object.skewX=skewX,object.skewY=0}})(object),center=center.transform(object.transformMatrix)),delete object.transformMatrix,preserveAspectRatioOptions&&(object.scaleX*=preserveAspectRatioOptions.scaleX,object.scaleY*=preserveAspectRatioOptions.scaleY,object.cropX=preserveAspectRatioOptions.cropX,object.cropY=preserveAspectRatioOptions.cropY,center.x+=preserveAspectRatioOptions.offsetLeft,center.y+=preserveAspectRatioOptions.offsetTop,object.width=preserveAspectRatioOptions.width,object.height=preserveAspectRatioOptions.height),object.setPositionByOrigin(center,CENTER,CENTER)};var index$1=Object.freeze({__proto__:null,addTransformToObject,animate,animateColor,applyTransformToObject,calcAngleBetweenVectors,calcDimensionsMatrix,calcPlaneChangeMatrix,calcVectorRotation,cancelAnimFrame,capValue,composeMatrix,copyCanvasElement:canvas=>{var _newCanvas$getContext;const newCanvas=createCanvasElement();return newCanvas.width=canvas.width,newCanvas.height=canvas.height,null===(_newCanvas$getContext=newCanvas.getContext("2d"))||void 0===_newCanvas$getContext||_newCanvas$getContext.drawImage(canvas,0,0),newCanvas},cos,createCanvasElement,createImage,createRotateMatrix,createScaleMatrix,createSkewXMatrix,createSkewYMatrix,createTranslateMatrix,createVector,crossProduct,degreesToRadians,dotProduct,ease:easing,enlivenObjectEnlivables,enlivenObjects,findScaleToCover,findScaleToFit,getBoundsOfCurve,getOrthonormalVector,getPathSegmentsInfo,getPointOnPath,getPointer,getRandomInt,getRegularPolygonPath:(numVertexes,radius)=>{const interiorAngle=2*Math.PI/numVertexes;let rotationAdjustment=-halfPI;numVertexes%2==0&&(rotationAdjustment+=interiorAngle/2);const d=new Array(numVertexes+1);for(let i=0;i<numVertexes;i++){const rad=i*interiorAngle+rotationAdjustment,{x,y}=new Point(cos(rad),sin(rad)).scalarMultiply(radius);d[i]=[0===i?"M":"L",x,y]}return d[numVertexes]=["Z"],d},getSmoothPathFromPoints,getSvgAttributes:type=>{const commonAttributes=["instantiated_by_use","style","id","class"];switch(type){case"linearGradient":return commonAttributes.concat(["x1","y1","x2","y2","gradientUnits","gradientTransform"]);case"radialGradient":return commonAttributes.concat(["gradientUnits","gradientTransform","cx","cy","r","fx","fy","fr"]);case"stop":return commonAttributes.concat(["offset","stop-color","stop-opacity"])}return commonAttributes},getUnitVector,groupSVGElements:(elements,options)=>elements&&1===elements.length?elements[0]:new Group(elements,options),hasStyleChanged,invertTransform,isBetweenVectors,isIdentityMatrix:mat=>mat.every(((value,index)=>value===iMatrix[index])),isTouchEvent,isTransparent,joinPath,loadImage,magnitude,makeBoundingBoxFromPoints,makePathSimpler,matrixToSVG,mergeClipPaths:(c1,c2)=>{var _b$group;let a=c1,b=c2;a.inverted&&!b.inverted&&(a=c2,b=c1),sendObjectToPlane(b,null===(_b$group=b.group)||void 0===_b$group?void 0:_b$group.calcTransformMatrix(),a.calcTransformMatrix());const inverted=a.inverted&&b.inverted;return inverted&&(a.inverted=b.inverted=!1),new Group([a],{clipPath:b,inverted})},multiplyTransformMatrices,multiplyTransformMatrixArray,parsePath,parsePreserveAspectRatioAttribute,parseUnit,pick,projectStrokeOnPoints,qrDecompose,radiansToDegrees,removeFromArray,removeTransformFromObject:(object,transform)=>{const inverted=invertTransform(transform),finalTransform=multiplyTransformMatrices(inverted,object.calcOwnMatrix());applyTransformToObject(object,finalTransform)},removeTransformMatrixForSvgParsing,request,requestAnimFrame,resetObjectTransform,rotatePoint:(point,origin,radians)=>point.rotate(radians,origin),rotateVector,saveObjectTransform,sendObjectToPlane,sendPointToPlane,sendVectorToPlane,setStyle,sin,sizeAfterTransform,string:lang_string,stylesFromArray,stylesToArray,toDataURL,toFixed,transformPath:(path,transform,pathOffset)=>(pathOffset&&(transform=multiplyTransformMatrices(transform,[1,0,0,1,-pathOffset.x,-pathOffset.y])),path.map((pathSegment=>{const newSegment=[...pathSegment];for(let i=1;i<pathSegment.length-1;i+=2){const{x,y}=transformPoint({x:pathSegment[i],y:pathSegment[i+1]},transform);newSegment[i]=x,newSegment[i+1]=y}return newSegment}))),transformPoint});class CanvasDOMManager extends StaticCanvasDOMManager{constructor(arg0){let{allowTouchScrolling=!1,containerClass=""}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(arg0),_defineProperty(this,"upper",void 0),_defineProperty(this,"container",void 0);const{el:lowerCanvasEl}=this.lower,upperCanvasEl=this.createUpperCanvas();this.upper={el:upperCanvasEl,ctx:upperCanvasEl.getContext("2d")},this.applyCanvasStyle(lowerCanvasEl,{allowTouchScrolling}),this.applyCanvasStyle(upperCanvasEl,{allowTouchScrolling});const container=this.createContainerElement();container.classList.add(containerClass),lowerCanvasEl.parentNode&&lowerCanvasEl.parentNode.replaceChild(container,lowerCanvasEl),container.append(lowerCanvasEl,upperCanvasEl),this.container=container}createUpperCanvas(){const{el:lowerCanvasEl}=this.lower,el=createCanvasElement();return el.className=lowerCanvasEl.className,el.classList.remove("lower-canvas"),el.classList.add("upper-canvas"),el.setAttribute("data-fabric","top"),el.style.cssText=lowerCanvasEl.style.cssText,el.setAttribute("draggable","true"),el}createContainerElement(){const container=getFabricDocument().createElement("div");return container.setAttribute("data-fabric","wrapper"),setStyle(container,{position:"relative"}),makeElementUnselectable(container),container}applyCanvasStyle(element,_ref){let{allowTouchScrolling:allow}=_ref;setStyle(element,{position:"absolute",left:"0",top:"0"}),function allowTouchScrolling(element,allow){const touchAction=allow?"manipulation":NONE;setStyle(element,{"touch-action":touchAction,"-ms-touch-action":touchAction})}(element,allow),makeElementUnselectable(element)}setDimensions(size,retinaScaling){super.setDimensions(size,retinaScaling);const{el,ctx}=this.upper;setCanvasDimensions(el,ctx,size,retinaScaling)}setCSSDimensions(size){super.setCSSDimensions(size),setCSSDimensions(this.upper.el,size),setCSSDimensions(this.container,size)}cleanupDOM(size){const container=this.container,{el:lowerCanvasEl}=this.lower,{el:upperCanvasEl}=this.upper;super.cleanupDOM(size),container.removeChild(upperCanvasEl),container.removeChild(lowerCanvasEl),container.parentNode&&container.parentNode.replaceChild(lowerCanvasEl,container)}dispose(){super.dispose(),getEnv().dispose(this.upper.el),delete this.upper,delete this.container}}class SelectableCanvas extends StaticCanvas{constructor(){super(...arguments),_defineProperty(this,"targets",[]),_defineProperty(this,"_hoveredTargets",[]),_defineProperty(this,"_objectsToRender",void 0),_defineProperty(this,"_currentTransform",null),_defineProperty(this,"_groupSelector",null),_defineProperty(this,"contextTopDirty",!1)}static getDefaults(){return _objectSpread2(_objectSpread2({},super.getDefaults()),SelectableCanvas.ownDefaults)}get upperCanvasEl(){var _this$elements$upper;return null===(_this$elements$upper=this.elements.upper)||void 0===_this$elements$upper?void 0:_this$elements$upper.el}get contextTop(){var _this$elements$upper2;return null===(_this$elements$upper2=this.elements.upper)||void 0===_this$elements$upper2?void 0:_this$elements$upper2.ctx}get wrapperEl(){return this.elements.container}initElements(el){this.elements=new CanvasDOMManager(el,{allowTouchScrolling:this.allowTouchScrolling,containerClass:this.containerClass}),this._createCacheCanvas()}_onObjectAdded(obj){this._objectsToRender=void 0,super._onObjectAdded(obj)}_onObjectRemoved(obj){this._objectsToRender=void 0,obj===this._activeObject&&(this.fire("before:selection:cleared",{deselected:[obj]}),this._discardActiveObject(),this.fire("selection:cleared",{deselected:[obj]}),obj.fire("deselected",{target:obj})),obj===this._hoveredTarget&&(this._hoveredTarget=void 0,this._hoveredTargets=[]),super._onObjectRemoved(obj)}_onStackOrderChanged(){this._objectsToRender=void 0,super._onStackOrderChanged()}_chooseObjectsToRender(){const activeObject=this._activeObject;return!this.preserveObjectStacking&&activeObject?this._objects.filter((object=>!object.group&&object!==activeObject)).concat(activeObject):this._objects}renderAll(){this.cancelRequestedRender(),this.destroyed||(!this.contextTopDirty||this._groupSelector||this.isDrawingMode||(this.clearContext(this.contextTop),this.contextTopDirty=!1),this.hasLostContext&&(this.renderTopLayer(this.contextTop),this.hasLostContext=!1),!this._objectsToRender&&(this._objectsToRender=this._chooseObjectsToRender()),this.renderCanvas(this.getContext(),this._objectsToRender))}renderTopLayer(ctx){ctx.save(),this.isDrawingMode&&this._isCurrentlyDrawing&&(this.freeDrawingBrush&&this.freeDrawingBrush._render(),this.contextTopDirty=!0),this.selection&&this._groupSelector&&(this._drawSelection(ctx),this.contextTopDirty=!0),ctx.restore()}renderTop(){const ctx=this.contextTop;this.clearContext(ctx),this.renderTopLayer(ctx),this.fire("after:render",{ctx})}setTargetFindTolerance(value){value=Math.round(value),this.targetFindTolerance=value;const retina=this.getRetinaScaling(),size=Math.ceil((2*value+1)*retina);this.pixelFindCanvasEl.width=this.pixelFindCanvasEl.height=size,this.pixelFindContext.scale(retina,retina)}isTargetTransparent(target,x,y){const tolerance=this.targetFindTolerance,ctx=this.pixelFindContext;this.clearContext(ctx),ctx.save(),ctx.translate(-x+tolerance,-y+tolerance),ctx.transform(...this.viewportTransform);const selectionBgc=target.selectionBackgroundColor;target.selectionBackgroundColor="",target.render(ctx),target.selectionBackgroundColor=selectionBgc,ctx.restore();const enhancedTolerance=Math.round(tolerance*this.getRetinaScaling());return isTransparent(ctx,enhancedTolerance,enhancedTolerance,enhancedTolerance)}_isSelectionKeyPressed(e){const sKey=this.selectionKey;return!!sKey&&(Array.isArray(sKey)?!!sKey.find((key=>!!key&&!0===e[key])):e[sKey])}_shouldClearSelection(e,target){const activeObjects=this.getActiveObjects(),activeObject=this._activeObject;return!!(!target||target&&activeObject&&activeObjects.length>1&&-1===activeObjects.indexOf(target)&&activeObject!==target&&!this._isSelectionKeyPressed(e)||target&&!target.evented||target&&!target.selectable&&activeObject&&activeObject!==target)}_shouldCenterTransform(target,action,modifierKeyPressed){if(!target)return;let centerTransform;return"scale"===action||"scaleX"===action||"scaleY"===action||"resizing"===action?centerTransform=this.centeredScaling||target.centeredScaling:"rotate"===action&&(centerTransform=this.centeredRotation||target.centeredRotation),centerTransform?!modifierKeyPressed:modifierKeyPressed}_getOriginFromCorner(target,controlName){const origin={x:target.originX,y:target.originY};return controlName?(["ml","tl","bl"].includes(controlName)?origin.x=RIGHT:["mr","tr","br"].includes(controlName)&&(origin.x=LEFT),["tl","mt","tr"].includes(controlName)?origin.y="bottom":["bl","mb","br"].includes(controlName)&&(origin.y=TOP),origin):origin}_setupCurrentTransform(e,target,alreadySelected){var _control$getActionHan;const pointer=target.group?sendPointToPlane(this.getScenePoint(e),void 0,target.group.calcTransformMatrix()):this.getScenePoint(e),{key:corner="",control}=target.getActiveControl()||{},actionHandler=alreadySelected&&control?null===(_control$getActionHan=control.getActionHandler(e,target,control))||void 0===_control$getActionHan?void 0:_control$getActionHan.bind(control):dragHandler,action=((alreadySelected,corner,e,target)=>{if(!corner||!alreadySelected)return"drag";const control=target.controls[corner];return control.getActionName(e,control,target)})(alreadySelected,corner,e,target),altKey=e[this.centeredKey],origin=this._shouldCenterTransform(target,action,altKey)?{x:CENTER,y:CENTER}:this._getOriginFromCorner(target,corner),transform={target,action,actionHandler,actionPerformed:!1,corner,scaleX:target.scaleX,scaleY:target.scaleY,skewX:target.skewX,skewY:target.skewY,offsetX:pointer.x-target.left,offsetY:pointer.y-target.top,originX:origin.x,originY:origin.y,ex:pointer.x,ey:pointer.y,lastX:pointer.x,lastY:pointer.y,theta:degreesToRadians(target.angle),width:target.width,height:target.height,shiftKey:e.shiftKey,altKey,original:_objectSpread2(_objectSpread2({},saveObjectTransform(target)),{},{originX:origin.x,originY:origin.y})};this._currentTransform=transform,this.fire("before:transform",{e,transform})}setCursor(value){this.upperCanvasEl.style.cursor=value}_drawSelection(ctx){const{x,y,deltaX,deltaY}=this._groupSelector,start=new Point(x,y).transform(this.viewportTransform),extent=new Point(x+deltaX,y+deltaY).transform(this.viewportTransform),strokeOffset=this.selectionLineWidth/2;let minX=Math.min(start.x,extent.x),minY=Math.min(start.y,extent.y),maxX=Math.max(start.x,extent.x),maxY=Math.max(start.y,extent.y);this.selectionColor&&(ctx.fillStyle=this.selectionColor,ctx.fillRect(minX,minY,maxX-minX,maxY-minY)),this.selectionLineWidth&&this.selectionBorderColor&&(ctx.lineWidth=this.selectionLineWidth,ctx.strokeStyle=this.selectionBorderColor,minX+=strokeOffset,minY+=strokeOffset,maxX-=strokeOffset,maxY-=strokeOffset,FabricObject.prototype._setLineDash.call(this,ctx,this.selectionDashArray),ctx.strokeRect(minX,minY,maxX-minX,maxY-minY))}findTarget(e){if(this.skipTargetFind)return;const pointer=this.getViewportPoint(e),activeObject=this._activeObject,aObjects=this.getActiveObjects();if(this.targets=[],activeObject&&aObjects.length>=1){if(activeObject._findTargetCorner(pointer,isTouchEvent(e)))return activeObject;if(aObjects.length>1&&this.searchPossibleTargets([activeObject],pointer))return activeObject;if(activeObject===this.searchPossibleTargets([activeObject],pointer)){if(this.preserveObjectStacking){const subTargets=this.targets;this.targets=[];const target=this.searchPossibleTargets(this._objects,pointer);return e[this.altSelectionKey]&&target&&target!==activeObject?(this.targets=subTargets,activeObject):target}return activeObject}}return this.searchPossibleTargets(this._objects,pointer)}_pointIsInObjectSelectionArea(obj,point){let coords=obj.getCoords();const viewportZoom=this.getZoom(),padding=obj.padding/viewportZoom;if(padding){const[tl,tr,br,bl]=coords,angleRadians=Math.atan2(tr.y-tl.y,tr.x-tl.x),cosP=cos(angleRadians)*padding,sinP=sin(angleRadians)*padding,cosPSinP=cosP+sinP,cosPMinusSinP=cosP-sinP;coords=[new Point(tl.x-cosPMinusSinP,tl.y-cosPSinP),new Point(tr.x+cosPSinP,tr.y-cosPMinusSinP),new Point(br.x+cosPMinusSinP,br.y+cosPSinP),new Point(bl.x-cosPSinP,bl.y+cosPMinusSinP)]}return Intersection.isPointInPolygon(point,coords)}_checkTarget(obj,pointer){if(obj&&obj.visible&&obj.evented&&this._pointIsInObjectSelectionArea(obj,sendPointToPlane(pointer,void 0,this.viewportTransform))){if(!this.perPixelTargetFind&&!obj.perPixelTargetFind||obj.isEditing)return!0;if(!this.isTargetTransparent(obj,pointer.x,pointer.y))return!0}return!1}_searchPossibleTargets(objects,pointer){let i=objects.length;for(;i--;){const target=objects[i];if(this._checkTarget(target,pointer)){if(isCollection(target)&&target.subTargetCheck){const subTarget=this._searchPossibleTargets(target._objects,pointer);subTarget&&this.targets.push(subTarget)}return target}}}searchPossibleTargets(objects,pointer){const target=this._searchPossibleTargets(objects,pointer);return target&&isCollection(target)&&target.interactive&&this.targets[0]?this.targets[0]:target}getViewportPoint(e){return this._pointer?this._pointer:this.getPointer(e,!0)}getScenePoint(e){return this._absolutePointer?this._absolutePointer:this.getPointer(e)}getPointer(e){let fromViewport=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const upperCanvasEl=this.upperCanvasEl,bounds=upperCanvasEl.getBoundingClientRect();let pointer=getPointer(e),boundsWidth=bounds.width||0,boundsHeight=bounds.height||0;boundsWidth&&boundsHeight||(TOP in bounds&&"bottom"in bounds&&(boundsHeight=Math.abs(bounds.top-bounds.bottom)),RIGHT in bounds&&LEFT in bounds&&(boundsWidth=Math.abs(bounds.right-bounds.left))),this.calcOffset(),pointer.x=pointer.x-this._offset.left,pointer.y=pointer.y-this._offset.top,fromViewport||(pointer=sendPointToPlane(pointer,void 0,this.viewportTransform));const retinaScaling=this.getRetinaScaling();1!==retinaScaling&&(pointer.x/=retinaScaling,pointer.y/=retinaScaling);const cssScale=0===boundsWidth||0===boundsHeight?new Point(1,1):new Point(upperCanvasEl.width/boundsWidth,upperCanvasEl.height/boundsHeight);return pointer.multiply(cssScale)}_setDimensionsImpl(dimensions,options){this._resetTransformEventData(),super._setDimensionsImpl(dimensions,options),this._isCurrentlyDrawing&&this.freeDrawingBrush&&this.freeDrawingBrush._setBrushStyles(this.contextTop)}_createCacheCanvas(){this.pixelFindCanvasEl=createCanvasElement(),this.pixelFindContext=this.pixelFindCanvasEl.getContext("2d",{willReadFrequently:!0}),this.setTargetFindTolerance(this.targetFindTolerance)}getTopContext(){return this.elements.upper.ctx}getSelectionContext(){return this.elements.upper.ctx}getSelectionElement(){return this.elements.upper.el}getActiveObject(){return this._activeObject}getActiveObjects(){const active=this._activeObject;return isActiveSelection(active)?active.getObjects():active?[active]:[]}_fireSelectionEvents(oldObjects,e){let somethingChanged=!1,invalidate=!1;const objects=this.getActiveObjects(),added=[],removed=[];oldObjects.forEach((target=>{objects.includes(target)||(somethingChanged=!0,target.fire("deselected",{e,target}),removed.push(target))})),objects.forEach((target=>{oldObjects.includes(target)||(somethingChanged=!0,target.fire("selected",{e,target}),added.push(target))})),oldObjects.length>0&&objects.length>0?(invalidate=!0,somethingChanged&&this.fire("selection:updated",{e,selected:added,deselected:removed})):objects.length>0?(invalidate=!0,this.fire("selection:created",{e,selected:added})):oldObjects.length>0&&(invalidate=!0,this.fire("selection:cleared",{e,deselected:removed})),invalidate&&(this._objectsToRender=void 0)}setActiveObject(object,e){const currentActives=this.getActiveObjects(),selected=this._setActiveObject(object,e);return this._fireSelectionEvents(currentActives,e),selected}_setActiveObject(object,e){const prevActiveObject=this._activeObject;return prevActiveObject!==object&&(!(!this._discardActiveObject(e,object)&&this._activeObject)&&(!object.onSelect({e})&&(this._activeObject=object,isActiveSelection(object)&&prevActiveObject!==object&&(object.set("canvas",this),object.setCoords()),!0)))}_discardActiveObject(e,object){const obj=this._activeObject;return!!obj&&(!obj.onDeselect({e,object})&&(this._currentTransform&&this._currentTransform.target===obj&&this.endCurrentTransform(e),this._activeObject=void 0,!0))}discardActiveObject(e){const currentActives=this.getActiveObjects(),activeObject=this.getActiveObject();currentActives.length&&this.fire("before:selection:cleared",{e,deselected:[activeObject]});const discarded=this._discardActiveObject(e);return this._fireSelectionEvents(currentActives,e),discarded}endCurrentTransform(e){const transform=this._currentTransform;this._finalizeCurrentTransform(e),transform&&transform.target&&(transform.target.isMoving=!1),this._currentTransform=null}_finalizeCurrentTransform(e){const transform=this._currentTransform,target=transform.target,options={e,target,transform,action:transform.action};target._scaling&&(target._scaling=!1),target.setCoords(),transform.actionPerformed&&(this.fire("object:modified",options),target.fire("modified",options))}setViewportTransform(vpt){super.setViewportTransform(vpt);const activeObject=this._activeObject;activeObject&&activeObject.setCoords()}destroy(){const activeObject=this._activeObject;isActiveSelection(activeObject)&&(activeObject.removeAll(),activeObject.dispose()),delete this._activeObject,super.destroy(),this.pixelFindContext=null,this.pixelFindCanvasEl=void 0}clear(){this.discardActiveObject(),this._activeObject=void 0,this.clearContext(this.contextTop),super.clear()}drawControls(ctx){const activeObject=this._activeObject;activeObject&&activeObject._renderControls(ctx)}_toObject(instance,methodName,propertiesToInclude){const originalProperties=this._realizeGroupTransformOnObject(instance),object=super._toObject(instance,methodName,propertiesToInclude);return instance.set(originalProperties),object}_realizeGroupTransformOnObject(instance){const{group}=instance;if(group&&isActiveSelection(group)&&this._activeObject===group){const originalValues=pick(instance,["angle","flipX","flipY",LEFT,"scaleX","scaleY","skewX","skewY",TOP]);return addTransformToObject(instance,group.calcOwnMatrix()),originalValues}return{}}_setSVGObject(markup,instance,reviver){const originalProperties=this._realizeGroupTransformOnObject(instance);super._setSVGObject(markup,instance,reviver),instance.set(originalProperties)}}_defineProperty(SelectableCanvas,"ownDefaults",{uniformScaling:!0,uniScaleKey:"shiftKey",centeredScaling:!1,centeredRotation:!1,centeredKey:"altKey",altActionKey:"shiftKey",selection:!0,selectionKey:"shiftKey",selectionColor:"rgba(100, 100, 255, 0.3)",selectionDashArray:[],selectionBorderColor:"rgba(255, 255, 255, 0.3)",selectionLineWidth:1,selectionFullyContained:!1,hoverCursor:"move",moveCursor:"move",defaultCursor:"default",freeDrawingCursor:"crosshair",notAllowedCursor:"not-allowed",perPixelTargetFind:!1,targetFindTolerance:0,skipTargetFind:!1,stopContextMenu:!1,fireRightClick:!1,fireMiddleClick:!1,enablePointerEvents:!1,containerClass:"canvas-container",preserveObjectStacking:!1});class TextEditingManager{constructor(canvas){_defineProperty(this,"targets",[]),_defineProperty(this,"__disposer",void 0);const cb=()=>{const{hiddenTextarea}=canvas.getActiveObject()||{};hiddenTextarea&&hiddenTextarea.focus()},el=canvas.upperCanvasEl;el.addEventListener("click",cb),this.__disposer=()=>el.removeEventListener("click",cb)}exitTextEditing(){this.target=void 0,this.targets.forEach((target=>{target.isEditing&&target.exitEditing()}))}add(target){this.targets.push(target)}remove(target){this.unregister(target),removeFromArray(this.targets,target)}register(target){this.target=target}unregister(target){target===this.target&&(this.target=void 0)}onMouseMove(e){var _this$target;(null===(_this$target=this.target)||void 0===_this$target?void 0:_this$target.isEditing)&&this.target.updateSelectionOnMouseMove(e)}clear(){this.targets=[],this.target=void 0}dispose(){this.clear(),this.__disposer(),delete this.__disposer}}const _excluded$c=["target","oldTarget","fireCanvas","e"],addEventOptions={passive:!1},getEventPoints=(canvas,e)=>{const viewportPoint=canvas.getViewportPoint(e),scenePoint=canvas.getScenePoint(e);return{viewportPoint,scenePoint,pointer:viewportPoint,absolutePointer:scenePoint}},addListener=function(el){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];return el.addEventListener(...args)},removeListener=function(el){for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++)args[_key2-1]=arguments[_key2];return el.removeEventListener(...args)},syntheticEventConfig={mouse:{in:"over",out:"out",targetIn:"mouseover",targetOut:"mouseout",canvasIn:"mouse:over",canvasOut:"mouse:out"},drag:{in:"enter",out:"leave",targetIn:"dragenter",targetOut:"dragleave",canvasIn:"drag:enter",canvasOut:"drag:leave"}};class Canvas extends SelectableCanvas{constructor(el){super(el,arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}),_defineProperty(this,"_isClick",void 0),_defineProperty(this,"textEditingManager",new TextEditingManager(this)),["_onMouseDown","_onTouchStart","_onMouseMove","_onMouseUp","_onTouchEnd","_onResize","_onMouseWheel","_onMouseOut","_onMouseEnter","_onContextMenu","_onDoubleClick","_onDragStart","_onDragEnd","_onDragProgress","_onDragOver","_onDragEnter","_onDragLeave","_onDrop"].forEach((eventHandler=>{this[eventHandler]=this[eventHandler].bind(this)})),this.addOrRemove(addListener,"add")}_getEventPrefix(){return this.enablePointerEvents?"pointer":"mouse"}addOrRemove(functor,eventjsFunctor){const canvasElement=this.upperCanvasEl,eventTypePrefix=this._getEventPrefix();functor(getWindowFromElement(canvasElement),"resize",this._onResize),functor(canvasElement,eventTypePrefix+"down",this._onMouseDown),functor(canvasElement,"".concat(eventTypePrefix,"move"),this._onMouseMove,addEventOptions),functor(canvasElement,"".concat(eventTypePrefix,"out"),this._onMouseOut),functor(canvasElement,"".concat(eventTypePrefix,"enter"),this._onMouseEnter),functor(canvasElement,"wheel",this._onMouseWheel),functor(canvasElement,"contextmenu",this._onContextMenu),functor(canvasElement,"dblclick",this._onDoubleClick),functor(canvasElement,"dragstart",this._onDragStart),functor(canvasElement,"dragend",this._onDragEnd),functor(canvasElement,"dragover",this._onDragOver),functor(canvasElement,"dragenter",this._onDragEnter),functor(canvasElement,"dragleave",this._onDragLeave),functor(canvasElement,"drop",this._onDrop),this.enablePointerEvents||functor(canvasElement,"touchstart",this._onTouchStart,addEventOptions)}removeListeners(){this.addOrRemove(removeListener,"remove");const eventTypePrefix=this._getEventPrefix(),doc=getDocumentFromElement(this.upperCanvasEl);removeListener(doc,"".concat(eventTypePrefix,"up"),this._onMouseUp),removeListener(doc,"touchend",this._onTouchEnd,addEventOptions),removeListener(doc,"".concat(eventTypePrefix,"move"),this._onMouseMove,addEventOptions),removeListener(doc,"touchmove",this._onMouseMove,addEventOptions)}_onMouseWheel(e){this.__onMouseWheel(e)}_onMouseOut(e){const target=this._hoveredTarget,shared=_objectSpread2({e},getEventPoints(this,e));this.fire("mouse:out",_objectSpread2(_objectSpread2({},shared),{},{target})),this._hoveredTarget=void 0,target&&target.fire("mouseout",_objectSpread2({},shared)),this._hoveredTargets.forEach((nestedTarget=>{this.fire("mouse:out",_objectSpread2(_objectSpread2({},shared),{},{target:nestedTarget})),nestedTarget&&nestedTarget.fire("mouseout",_objectSpread2({},shared))})),this._hoveredTargets=[]}_onMouseEnter(e){this._currentTransform||this.findTarget(e)||(this.fire("mouse:over",_objectSpread2({e},getEventPoints(this,e))),this._hoveredTarget=void 0,this._hoveredTargets=[])}_onDragStart(e){this._isClick=!1;const activeObject=this.getActiveObject();if(activeObject&&activeObject.onDragStart(e)){this._dragSource=activeObject;const options={e,target:activeObject};return this.fire("dragstart",options),activeObject.fire("dragstart",options),void addListener(this.upperCanvasEl,"drag",this._onDragProgress)}stopEvent(e)}_renderDragEffects(e,source,target){let dirty=!1;const dropTarget=this._dropTarget;dropTarget&&dropTarget!==source&&dropTarget!==target&&(dropTarget.clearContextTop(),dirty=!0),null==source||source.clearContextTop(),target!==source&&(null==target||target.clearContextTop());const ctx=this.contextTop;ctx.save(),ctx.transform(...this.viewportTransform),source&&(ctx.save(),source.transform(ctx),source.renderDragSourceEffect(e),ctx.restore(),dirty=!0),target&&(ctx.save(),target.transform(ctx),target.renderDropTargetEffect(e),ctx.restore(),dirty=!0),ctx.restore(),dirty&&(this.contextTopDirty=!0)}_onDragEnd(e){const didDrop=!!e.dataTransfer&&e.dataTransfer.dropEffect!==NONE,dropTarget=didDrop?this._activeObject:void 0,options={e,target:this._dragSource,subTargets:this.targets,dragSource:this._dragSource,didDrop,dropTarget};removeListener(this.upperCanvasEl,"drag",this._onDragProgress),this.fire("dragend",options),this._dragSource&&this._dragSource.fire("dragend",options),delete this._dragSource,this._onMouseUp(e)}_onDragProgress(e){const options={e,target:this._dragSource,dragSource:this._dragSource,dropTarget:this._draggedoverTarget};this.fire("drag",options),this._dragSource&&this._dragSource.fire("drag",options)}findDragTargets(e){this.targets=[];return{target:this._searchPossibleTargets(this._objects,this.getViewportPoint(e)),targets:[...this.targets]}}_onDragOver(e){const{target,targets}=this.findDragTargets(e),dragSource=this._dragSource,options={e,target,subTargets:targets,dragSource,canDrop:!1,dropTarget:void 0};let dropTarget;this.fire("dragover",options),this._fireEnterLeaveEvents(target,options),target&&(target.canDrop(e)&&(dropTarget=target),target.fire("dragover",options));for(let i=0;i<targets.length;i++){const subTarget=targets[i];subTarget.canDrop(e)&&(dropTarget=subTarget),subTarget.fire("dragover",options)}this._renderDragEffects(e,dragSource,dropTarget),this._dropTarget=dropTarget}_onDragEnter(e){const{target,targets}=this.findDragTargets(e),options={e,target,subTargets:targets,dragSource:this._dragSource};this.fire("dragenter",options),this._fireEnterLeaveEvents(target,options)}_onDragLeave(e){const options={e,target:this._draggedoverTarget,subTargets:this.targets,dragSource:this._dragSource};this.fire("dragleave",options),this._fireEnterLeaveEvents(void 0,options),this._renderDragEffects(e,this._dragSource),this._dropTarget=void 0,this.targets=[],this._hoveredTargets=[]}_onDrop(e){const{target,targets}=this.findDragTargets(e),options=this._basicEventHandler("drop:before",_objectSpread2({e,target,subTargets:targets,dragSource:this._dragSource},getEventPoints(this,e)));options.didDrop=!1,options.dropTarget=void 0,this._basicEventHandler("drop",options),this.fire("drop:after",options)}_onContextMenu(e){const target=this.findTarget(e),subTargets=this.targets||[],options=this._basicEventHandler("contextmenu:before",{e,target,subTargets});return this.stopContextMenu&&stopEvent(e),this._basicEventHandler("contextmenu",options),!1}_onDoubleClick(e){this._cacheTransformEventData(e),this._handleEvent(e,"dblclick"),this._resetTransformEventData()}getPointerId(evt){const changedTouches=evt.changedTouches;return changedTouches?changedTouches[0]&&changedTouches[0].identifier:this.enablePointerEvents?evt.pointerId:-1}_isMainEvent(evt){return!0===evt.isPrimary||!1!==evt.isPrimary&&("touchend"===evt.type&&0===evt.touches.length||(!evt.changedTouches||evt.changedTouches[0].identifier===this.mainTouchId))}_onTouchStart(e){e.preventDefault(),null===this.mainTouchId&&(this.mainTouchId=this.getPointerId(e)),this.__onMouseDown(e),this._resetTransformEventData();const canvasElement=this.upperCanvasEl,eventTypePrefix=this._getEventPrefix(),doc=getDocumentFromElement(canvasElement);addListener(doc,"touchend",this._onTouchEnd,addEventOptions),addListener(doc,"touchmove",this._onMouseMove,addEventOptions),removeListener(canvasElement,"".concat(eventTypePrefix,"down"),this._onMouseDown)}_onMouseDown(e){this.__onMouseDown(e),this._resetTransformEventData();const canvasElement=this.upperCanvasEl,eventTypePrefix=this._getEventPrefix();removeListener(canvasElement,"".concat(eventTypePrefix,"move"),this._onMouseMove,addEventOptions);const doc=getDocumentFromElement(canvasElement);addListener(doc,"".concat(eventTypePrefix,"up"),this._onMouseUp),addListener(doc,"".concat(eventTypePrefix,"move"),this._onMouseMove,addEventOptions)}_onTouchEnd(e){if(e.touches.length>0)return;this.__onMouseUp(e),this._resetTransformEventData(),this.mainTouchId=null;const eventTypePrefix=this._getEventPrefix(),doc=getDocumentFromElement(this.upperCanvasEl);removeListener(doc,"touchend",this._onTouchEnd,addEventOptions),removeListener(doc,"touchmove",this._onMouseMove,addEventOptions),this._willAddMouseDown&&clearTimeout(this._willAddMouseDown),this._willAddMouseDown=setTimeout((()=>{addListener(this.upperCanvasEl,"".concat(eventTypePrefix,"down"),this._onMouseDown),this._willAddMouseDown=0}),400)}_onMouseUp(e){this.__onMouseUp(e),this._resetTransformEventData();const canvasElement=this.upperCanvasEl,eventTypePrefix=this._getEventPrefix();if(this._isMainEvent(e)){const doc=getDocumentFromElement(this.upperCanvasEl);removeListener(doc,"".concat(eventTypePrefix,"up"),this._onMouseUp),removeListener(doc,"".concat(eventTypePrefix,"move"),this._onMouseMove,addEventOptions),addListener(canvasElement,"".concat(eventTypePrefix,"move"),this._onMouseMove,addEventOptions)}}_onMouseMove(e){const activeObject=this.getActiveObject();!this.allowTouchScrolling&&(!activeObject||!activeObject.shouldStartDragging())&&e.preventDefault&&e.preventDefault(),this.__onMouseMove(e)}_onResize(){this.calcOffset(),this._resetTransformEventData()}_shouldRender(target){const activeObject=this.getActiveObject();return!!activeObject!=!!target||activeObject&&target&&activeObject!==target}__onMouseUp(e){var _this$_activeObject;this._cacheTransformEventData(e),this._handleEvent(e,"up:before");const transform=this._currentTransform,isClick=this._isClick,target=this._target,{button}=e;if(button)return(this.fireMiddleClick&&1===button||this.fireRightClick&&2===button)&&this._handleEvent(e,"up"),void this._resetTransformEventData();if(this.isDrawingMode&&this._isCurrentlyDrawing)return void this._onMouseUpInDrawingMode(e);if(!this._isMainEvent(e))return;let pointer,corner,shouldRender=!1;if(transform&&(this._finalizeCurrentTransform(e),shouldRender=transform.actionPerformed),!isClick){const targetWasActive=target===this._activeObject;this.handleSelection(e),shouldRender||(shouldRender=this._shouldRender(target)||!targetWasActive&&target===this._activeObject)}if(target){if(corner=target._findTargetCorner(this.getViewportPoint(e),isTouchEvent(e)),target.selectable&&target!==this._activeObject&&"up"===target.activeOn)this.setActiveObject(target,e),shouldRender=!0;else{const control=target.controls[corner],mouseUpHandler=control&&control.getMouseUpHandler(e,target,control);mouseUpHandler&&(pointer=this.getScenePoint(e),mouseUpHandler.call(control,e,transform,pointer.x,pointer.y))}target.isMoving=!1}if(transform&&(transform.target!==target||transform.corner!==corner)){const originalControl=transform.target&&transform.target.controls[transform.corner],originalMouseUpHandler=originalControl&&originalControl.getMouseUpHandler(e,transform.target,originalControl);pointer=pointer||this.getScenePoint(e),originalMouseUpHandler&&originalMouseUpHandler.call(originalControl,e,transform,pointer.x,pointer.y)}this._setCursorFromEvent(e,target),this._handleEvent(e,"up"),this._groupSelector=null,this._currentTransform=null,target&&(target.__corner=void 0),shouldRender?this.requestRenderAll():isClick||null!==(_this$_activeObject=this._activeObject)&&void 0!==_this$_activeObject&&_this$_activeObject.isEditing||this.renderTop()}_basicEventHandler(eventType,options){const{target,subTargets=[]}=options;this.fire(eventType,options),target&&target.fire(eventType,options);for(let i=0;i<subTargets.length;i++)subTargets[i]!==target&&subTargets[i].fire(eventType,options);return options}_handleEvent(e,eventType){const target=this._target,targets=this.targets||[],options=_objectSpread2(_objectSpread2({e,target,subTargets:targets},getEventPoints(this,e)),{},{transform:this._currentTransform},"up:before"===eventType||"up"===eventType?{isClick:this._isClick,currentTarget:this.findTarget(e),currentSubTargets:this.targets}:{});this.fire("mouse:".concat(eventType),options),target&&target.fire("mouse".concat(eventType),options);for(let i=0;i<targets.length;i++)targets[i]!==target&&targets[i].fire("mouse".concat(eventType),options)}_onMouseDownInDrawingMode(e){this._isCurrentlyDrawing=!0,this.getActiveObject()&&(this.discardActiveObject(e),this.requestRenderAll());const pointer=this.getScenePoint(e);this.freeDrawingBrush&&this.freeDrawingBrush.onMouseDown(pointer,{e,pointer}),this._handleEvent(e,"down")}_onMouseMoveInDrawingMode(e){if(this._isCurrentlyDrawing){const pointer=this.getScenePoint(e);this.freeDrawingBrush&&this.freeDrawingBrush.onMouseMove(pointer,{e,pointer})}this.setCursor(this.freeDrawingCursor),this._handleEvent(e,"move")}_onMouseUpInDrawingMode(e){const pointer=this.getScenePoint(e);this.freeDrawingBrush?this._isCurrentlyDrawing=!!this.freeDrawingBrush.onMouseUp({e,pointer}):this._isCurrentlyDrawing=!1,this._handleEvent(e,"up")}__onMouseDown(e){this._isClick=!0,this._cacheTransformEventData(e),this._handleEvent(e,"down:before");let target=this._target;const{button}=e;if(button)return(this.fireMiddleClick&&1===button||this.fireRightClick&&2===button)&&this._handleEvent(e,"down"),void this._resetTransformEventData();if(this.isDrawingMode)return void this._onMouseDownInDrawingMode(e);if(!this._isMainEvent(e))return;if(this._currentTransform)return;let shouldRender=this._shouldRender(target),grouped=!1;if(this.handleMultiSelection(e,target)?(target=this._activeObject,grouped=!0,shouldRender=!0):this._shouldClearSelection(e,target)&&this.discardActiveObject(e),this.selection&&(!target||!target.selectable&&!target.isEditing&&target!==this._activeObject)){const p=this.getScenePoint(e);this._groupSelector={x:p.x,y:p.y,deltaY:0,deltaX:0}}if(target){const alreadySelected=target===this._activeObject;target.selectable&&"down"===target.activeOn&&this.setActiveObject(target,e);const corner=target._findTargetCorner(this.getViewportPoint(e),isTouchEvent(e));if(target===this._activeObject&&(corner||!grouped)){this._setupCurrentTransform(e,target,alreadySelected);const control=target.controls[corner],pointer=this.getScenePoint(e),mouseDownHandler=control&&control.getMouseDownHandler(e,target,control);mouseDownHandler&&mouseDownHandler.call(control,e,this._currentTransform,pointer.x,pointer.y)}}shouldRender&&(this._objectsToRender=void 0),this._handleEvent(e,"down"),shouldRender&&this.requestRenderAll()}_resetTransformEventData(){this._target=void 0,this._pointer=void 0,this._absolutePointer=void 0}_cacheTransformEventData(e){this._resetTransformEventData(),this._pointer=this.getViewportPoint(e),this._absolutePointer=sendPointToPlane(this._pointer,void 0,this.viewportTransform),this._target=this._currentTransform?this._currentTransform.target:this.findTarget(e)}__onMouseMove(e){if(this._isClick=!1,this._handleEvent(e,"move:before"),this._cacheTransformEventData(e),this.isDrawingMode)return void this._onMouseMoveInDrawingMode(e);if(!this._isMainEvent(e))return;const groupSelector=this._groupSelector;if(groupSelector){const pointer=this.getScenePoint(e);groupSelector.deltaX=pointer.x-groupSelector.x,groupSelector.deltaY=pointer.y-groupSelector.y,this.renderTop()}else if(this._currentTransform)this._transformObject(e);else{const target=this.findTarget(e);this._setCursorFromEvent(e,target),this._fireOverOutEvents(e,target)}this.textEditingManager.onMouseMove(e),this._handleEvent(e,"move"),this._resetTransformEventData()}_fireOverOutEvents(e,target){const _hoveredTarget=this._hoveredTarget,_hoveredTargets=this._hoveredTargets,targets=this.targets,length=Math.max(_hoveredTargets.length,targets.length);this.fireSyntheticInOutEvents("mouse",{e,target,oldTarget:_hoveredTarget,fireCanvas:!0});for(let i=0;i<length;i++)this.fireSyntheticInOutEvents("mouse",{e,target:targets[i],oldTarget:_hoveredTargets[i]});this._hoveredTarget=target,this._hoveredTargets=this.targets.concat()}_fireEnterLeaveEvents(target,data){const draggedoverTarget=this._draggedoverTarget,_hoveredTargets=this._hoveredTargets,targets=this.targets,length=Math.max(_hoveredTargets.length,targets.length);this.fireSyntheticInOutEvents("drag",_objectSpread2(_objectSpread2({},data),{},{target,oldTarget:draggedoverTarget,fireCanvas:!0}));for(let i=0;i<length;i++)this.fireSyntheticInOutEvents("drag",_objectSpread2(_objectSpread2({},data),{},{target:targets[i],oldTarget:_hoveredTargets[i]}));this._draggedoverTarget=target}fireSyntheticInOutEvents(type,_ref){let{target,oldTarget,fireCanvas,e}=_ref,data=_objectWithoutProperties(_ref,_excluded$c);const{targetIn,targetOut,canvasIn,canvasOut}=syntheticEventConfig[type],targetChanged=oldTarget!==target;if(oldTarget&&targetChanged){const outOpt=_objectSpread2(_objectSpread2({},data),{},{e,target:oldTarget,nextTarget:target},getEventPoints(this,e));fireCanvas&&this.fire(canvasOut,outOpt),oldTarget.fire(targetOut,outOpt)}if(target&&targetChanged){const inOpt=_objectSpread2(_objectSpread2({},data),{},{e,target,previousTarget:oldTarget},getEventPoints(this,e));fireCanvas&&this.fire(canvasIn,inOpt),target.fire(targetIn,inOpt)}}__onMouseWheel(e){this._cacheTransformEventData(e),this._handleEvent(e,"wheel"),this._resetTransformEventData()}_transformObject(e){const scenePoint=this.getScenePoint(e),transform=this._currentTransform,target=transform.target,localPointer=target.group?sendPointToPlane(scenePoint,void 0,target.group.calcTransformMatrix()):scenePoint;transform.shiftKey=e.shiftKey,transform.altKey=!!this.centeredKey&&e[this.centeredKey],this._performTransformAction(e,transform,localPointer),transform.actionPerformed&&this.requestRenderAll()}_performTransformAction(e,transform,pointer){const x=pointer.x,y=pointer.y,action=transform.action,actionHandler=transform.actionHandler;let actionPerformed=!1;actionHandler&&(actionPerformed=actionHandler(e,transform,x,y)),"drag"===action&&actionPerformed&&(transform.target.isMoving=!0,this.setCursor(transform.target.moveCursor||this.moveCursor)),transform.actionPerformed=transform.actionPerformed||actionPerformed}_setCursorFromEvent(e,target){if(!target)return void this.setCursor(this.defaultCursor);let hoverCursor=target.hoverCursor||this.hoverCursor;const activeSelection=isActiveSelection(this._activeObject)?this._activeObject:null,corner=(!activeSelection||target.group!==activeSelection)&&target._findTargetCorner(this.getViewportPoint(e));if(corner){const control=target.controls[corner];this.setCursor(control.cursorStyleHandler(e,control,target))}else target.subTargetCheck&&this.targets.concat().reverse().map((_target=>{hoverCursor=_target.hoverCursor||hoverCursor})),this.setCursor(hoverCursor)}handleMultiSelection(e,target){const activeObject=this._activeObject,isAS=isActiveSelection(activeObject);if(activeObject&&this._isSelectionKeyPressed(e)&&this.selection&&target&&target.selectable&&(activeObject!==target||isAS)&&(isAS||!target.isDescendantOf(activeObject)&&!activeObject.isDescendantOf(target))&&!target.onSelect({e})&&!activeObject.getActiveControl()){if(isAS){const prevActiveObjects=activeObject.getObjects();if(target===activeObject){const pointer=this.getViewportPoint(e);if(!(target=this.searchPossibleTargets(prevActiveObjects,pointer)||this.searchPossibleTargets(this._objects,pointer))||!target.selectable)return!1}target.group===activeObject?(activeObject.remove(target),this._hoveredTarget=target,this._hoveredTargets=[...this.targets],1===activeObject.size()&&this._setActiveObject(activeObject.item(0),e)):(activeObject.multiSelectAdd(target),this._hoveredTarget=activeObject,this._hoveredTargets=[...this.targets]),this._fireSelectionEvents(prevActiveObjects,e)}else{activeObject.exitEditing&&activeObject.exitEditing();const newActiveSelection=new(classRegistry.getClass("ActiveSelection"))([],{canvas:this});newActiveSelection.multiSelectAdd(activeObject,target),this._hoveredTarget=newActiveSelection,this._setActiveObject(newActiveSelection,e),this._fireSelectionEvents([activeObject],e)}return!0}return!1}handleSelection(e){if(!this.selection||!this._groupSelector)return!1;const{x,y,deltaX,deltaY}=this._groupSelector,point1=new Point(x,y),point2=point1.add(new Point(deltaX,deltaY)),tl=point1.min(point2),size=point1.max(point2).subtract(tl),collectedObjects=this.collectObjects({left:tl.x,top:tl.y,width:size.x,height:size.y},{includeIntersecting:!this.selectionFullyContained}),objects=point1.eq(point2)?collectedObjects[0]?[collectedObjects[0]]:[]:collectedObjects.length>1?collectedObjects.filter((object=>!object.onSelect({e}))).reverse():collectedObjects;if(1===objects.length)this.setActiveObject(objects[0],e);else if(objects.length>1){const klass=classRegistry.getClass("ActiveSelection");this.setActiveObject(new klass(objects,{canvas:this}),e)}return this._groupSelector=null,!0}clear(){this.textEditingManager.clear(),super.clear()}destroy(){this.removeListeners(),this.textEditingManager.dispose(),super.destroy()}}const linearDefaultCoords={x1:0,y1:0,x2:0,y2:0},radialDefaultCoords=_objectSpread2(_objectSpread2({},linearDefaultCoords),{},{r1:0,r2:0}),RE_PERCENT=/^(\d+\.\d+)%|(\d+)%$/;function isPercent(value){return value&&RE_PERCENT.test(value)}function parsePercent(value,valueIfNaN){const parsed="number"==typeof value?value:"string"==typeof value?parseFloat(value)/(isPercent(value)?100:1):NaN;return capValue(0,ifNaN(parsed,valueIfNaN),1)}const RE_KEY_VALUE_PAIRS=/\s*;\s*/,RE_KEY_VALUE=/\s*:\s*/;function parseColorStop(el,multiplier){let colorValue,opacity;const style=el.getAttribute("style");if(style){const keyValuePairs=style.split(RE_KEY_VALUE_PAIRS);""===keyValuePairs[keyValuePairs.length-1]&&keyValuePairs.pop();for(let i=keyValuePairs.length;i--;){const[key,value]=keyValuePairs[i].split(RE_KEY_VALUE).map((s=>s.trim()));"stop-color"===key?colorValue=value:"stop-opacity"===key&&(opacity=value)}}const color=new Color(colorValue||el.getAttribute("stop-color")||"rgb(0,0,0)");return{offset:parsePercent(el.getAttribute("offset"),0),color:color.toRgb(),opacity:ifNaN(parseFloat(opacity||el.getAttribute("stop-opacity")||""),1)*color.getAlpha()*multiplier}}function parseColorStops(el,opacityAttr){const colorStops=[],colorStopEls=el.getElementsByTagName("stop"),multiplier=parsePercent(opacityAttr,1);for(let i=colorStopEls.length;i--;)colorStops.push(parseColorStop(colorStopEls[i],multiplier));return colorStops}function parseType(el){return"linearGradient"===el.nodeName||"LINEARGRADIENT"===el.nodeName?"linear":"radial"}function parseGradientUnits(el){return"userSpaceOnUse"===el.getAttribute("gradientUnits")?"pixels":"percentage"}function getValue(el,key){return el.getAttribute(key)}function parseCoords(el,size){return function convertPercentUnitsToValues(valuesToConvert,_ref){let finalValue,{width,height,gradientUnits}=_ref;return Object.keys(valuesToConvert).reduce(((acc,prop)=>{const propValue=valuesToConvert[prop];return"Infinity"===propValue?finalValue=1:"-Infinity"===propValue?finalValue=0:(finalValue="string"==typeof propValue?parseFloat(propValue):propValue,"string"==typeof propValue&&isPercent(propValue)&&(finalValue*=.01,"pixels"===gradientUnits&&("x1"!==prop&&"x2"!==prop&&"r2"!==prop||(finalValue*=width),"y1"!==prop&&"y2"!==prop||(finalValue*=height)))),acc[prop]=finalValue,acc}),{})}("linear"===parseType(el)?function parseLinearCoords(el){return{x1:getValue(el,"x1")||0,y1:getValue(el,"y1")||0,x2:getValue(el,"x2")||"100%",y2:getValue(el,"y2")||0}}(el):function parseRadialCoords(el){return{x1:getValue(el,"fx")||getValue(el,"cx")||"50%",y1:getValue(el,"fy")||getValue(el,"cy")||"50%",r1:0,x2:getValue(el,"cx")||"50%",y2:getValue(el,"cy")||"50%",r2:getValue(el,"r")||"50%"}}(el),_objectSpread2(_objectSpread2({},size),{},{gradientUnits:parseGradientUnits(el)}))}class Gradient{constructor(_ref){let{type="linear",gradientUnits="pixels",coords={},colorStops=[],offsetX=0,offsetY=0,gradientTransform,id}=_ref;this.id=id?"".concat(id,"_").concat(uid()):uid(),this.type=type,this.gradientUnits=gradientUnits,this.gradientTransform=gradientTransform,this.offsetX=offsetX,this.offsetY=offsetY,this.coords=_objectSpread2(_objectSpread2({},"radial"===this.type?radialDefaultCoords:linearDefaultCoords),coords),this.colorStops=colorStops.slice()}addColorStop(colorStops){for(const position in colorStops){const color=new Color(colorStops[position]);this.colorStops.push({offset:parseFloat(position),color:color.toRgb(),opacity:color.getAlpha()})}return this}toObject(propertiesToInclude){return _objectSpread2(_objectSpread2({},pick(this,propertiesToInclude)),{},{type:this.type,coords:this.coords,colorStops:this.colorStops,offsetX:this.offsetX,offsetY:this.offsetY,gradientUnits:this.gradientUnits,gradientTransform:this.gradientTransform?[...this.gradientTransform]:void 0})}toSVG(object){let{additionalTransform:preTransform}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const markup=[],transform=this.gradientTransform?this.gradientTransform.concat():iMatrix.concat(),gradientUnits="pixels"===this.gradientUnits?"userSpaceOnUse":"objectBoundingBox",colorStops=this.colorStops.map((colorStop=>_objectSpread2({},colorStop))).sort(((a,b)=>a.offset-b.offset));let offsetX=-this.offsetX,offsetY=-this.offsetY;var fabricObject;"objectBoundingBox"===gradientUnits?(offsetX/=object.width,offsetY/=object.height):(offsetX+=object.width/2,offsetY+=object.height/2),(fabricObject=object)&&"function"==typeof fabricObject._renderPathCommands&&"percentage"!==this.gradientUnits&&(offsetX-=object.pathOffset.x,offsetY-=object.pathOffset.y),transform[4]-=offsetX,transform[5]-=offsetY;const commonAttributes=['id="SVGID_'.concat(this.id,'"'),'gradientUnits="'.concat(gradientUnits,'"'),'gradientTransform="'.concat(preTransform?preTransform+" ":"").concat(matrixToSVG(transform),'"'),""].join(" ");if("linear"===this.type){const{x1,y1,x2,y2}=this.coords;markup.push("<linearGradient ",commonAttributes,' x1="',x1,'" y1="',y1,'" x2="',x2,'" y2="',y2,'">\n')}else if("radial"===this.type){const{x1,y1,x2,y2,r1,r2}=this.coords,needsSwap=r1>r2;markup.push("<radialGradient ",commonAttributes,' cx="',needsSwap?x1:x2,'" cy="',needsSwap?y1:y2,'" r="',needsSwap?r1:r2,'" fx="',needsSwap?x2:x1,'" fy="',needsSwap?y2:y1,'">\n'),needsSwap&&(colorStops.reverse(),colorStops.forEach((colorStop=>{colorStop.offset=1-colorStop.offset})));const minRadius=Math.min(r1,r2);if(minRadius>0){const percentageShift=minRadius/Math.max(r1,r2);colorStops.forEach((colorStop=>{colorStop.offset+=percentageShift*(1-colorStop.offset)}))}}return colorStops.forEach((_ref2=>{let{color,offset,opacity}=_ref2;markup.push("<stop ",'offset="',100*offset+"%",'" style="stop-color:',color,void 0!==opacity?";stop-opacity: "+opacity:";",'"/>\n')})),markup.push("linear"===this.type?"</linearGradient>":"</radialGradient>","\n"),markup.join("")}toLive(ctx){const coords=this.coords,gradient="linear"===this.type?ctx.createLinearGradient(coords.x1,coords.y1,coords.x2,coords.y2):ctx.createRadialGradient(coords.x1,coords.y1,coords.r1,coords.x2,coords.y2,coords.r2);return this.colorStops.forEach((_ref3=>{let{color,opacity,offset}=_ref3;gradient.addColorStop(offset,void 0!==opacity?new Color(color).setAlpha(opacity).toRgba():color)})),gradient}static fromElement(el,instance,svgOptions){const gradientUnits=parseGradientUnits(el),center=instance._findCenterFromElement();return new this(_objectSpread2({id:el.getAttribute("id")||void 0,type:parseType(el),coords:parseCoords(el,{width:svgOptions.viewBoxWidth||svgOptions.width,height:svgOptions.viewBoxHeight||svgOptions.height}),colorStops:parseColorStops(el,svgOptions.opacity),gradientUnits,gradientTransform:parseTransformAttribute(el.getAttribute("gradientTransform")||"")},"pixels"===gradientUnits?{offsetX:instance.width/2-center.x,offsetY:instance.height/2-center.y}:{offsetX:0,offsetY:0}))}}_defineProperty(Gradient,"type","Gradient"),classRegistry.setClass(Gradient,"gradient");const _excluded$b=["type","source"];class Pattern{get type(){return"pattern"}set type(value){log("warn","Setting type has no effect",value)}constructor(options){_defineProperty(this,"repeat","repeat"),_defineProperty(this,"offsetX",0),_defineProperty(this,"offsetY",0),_defineProperty(this,"crossOrigin",""),_defineProperty(this,"patternTransform",null),this.id=uid(),Object.assign(this,options)}isImageSource(){return!!this.source&&"string"==typeof this.source.src}isCanvasSource(){return!!this.source&&!!this.source.toDataURL}sourceToString(){return this.isImageSource()?this.source.src:this.isCanvasSource()?this.source.toDataURL():""}toLive(ctx){return this.source&&(!this.isImageSource()||this.source.complete&&0!==this.source.naturalWidth&&0!==this.source.naturalHeight)?ctx.createPattern(this.source,this.repeat):null}toObject(){let propertiesToInclude=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];const{repeat,crossOrigin}=this;return _objectSpread2(_objectSpread2({},pick(this,propertiesToInclude)),{},{type:"pattern",source:this.sourceToString(),repeat,crossOrigin,offsetX:toFixed(this.offsetX,config.NUM_FRACTION_DIGITS),offsetY:toFixed(this.offsetY,config.NUM_FRACTION_DIGITS),patternTransform:this.patternTransform?[...this.patternTransform]:null})}toSVG(_ref){let{width,height}=_ref;const{source:patternSource,repeat,id}=this,patternOffsetX=ifNaN(this.offsetX/width,0),patternOffsetY=ifNaN(this.offsetY/height,0),patternWidth="repeat-y"===repeat||"no-repeat"===repeat?1+Math.abs(patternOffsetX||0):ifNaN(patternSource.width/width,0),patternHeight="repeat-x"===repeat||"no-repeat"===repeat?1+Math.abs(patternOffsetY||0):ifNaN(patternSource.height/height,0);return['<pattern id="SVGID_'.concat(id,'" x="').concat(patternOffsetX,'" y="').concat(patternOffsetY,'" width="').concat(patternWidth,'" height="').concat(patternHeight,'">'),'<image x="0" y="0" width="'.concat(patternSource.width,'" height="').concat(patternSource.height,'" xlink:href="').concat(this.sourceToString(),'"></image>'),"</pattern>",""].join("\n")}static async fromObject(_ref2,options){let{type,source}=_ref2,serialized=_objectWithoutProperties(_ref2,_excluded$b);const img=await loadImage(source,_objectSpread2(_objectSpread2({},options),{},{crossOrigin:serialized.crossOrigin}));return new this(_objectSpread2(_objectSpread2({},serialized),{},{source:img}))}}_defineProperty(Pattern,"type","Pattern"),classRegistry.setClass(Pattern),classRegistry.setClass(Pattern,"pattern");class BaseBrush{constructor(canvas){_defineProperty(this,"color","rgb(0, 0, 0)"),_defineProperty(this,"width",1),_defineProperty(this,"shadow",null),_defineProperty(this,"strokeLineCap","round"),_defineProperty(this,"strokeLineJoin","round"),_defineProperty(this,"strokeMiterLimit",10),_defineProperty(this,"strokeDashArray",null),_defineProperty(this,"limitedToCanvasSize",!1),this.canvas=canvas}_setBrushStyles(ctx){ctx.strokeStyle=this.color,ctx.lineWidth=this.width,ctx.lineCap=this.strokeLineCap,ctx.miterLimit=this.strokeMiterLimit,ctx.lineJoin=this.strokeLineJoin,ctx.setLineDash(this.strokeDashArray||[])}_saveAndTransform(ctx){const v=this.canvas.viewportTransform;ctx.save(),ctx.transform(v[0],v[1],v[2],v[3],v[4],v[5])}needsFullRender(){return new Color(this.color).getAlpha()<1||!!this.shadow}_setShadow(){if(!this.shadow||!this.canvas)return;const canvas=this.canvas,shadow=this.shadow,ctx=canvas.contextTop,zoom=canvas.getZoom()*canvas.getRetinaScaling();ctx.shadowColor=shadow.color,ctx.shadowBlur=shadow.blur*zoom,ctx.shadowOffsetX=shadow.offsetX*zoom,ctx.shadowOffsetY=shadow.offsetY*zoom}_resetShadow(){const ctx=this.canvas.contextTop;ctx.shadowColor="",ctx.shadowBlur=ctx.shadowOffsetX=ctx.shadowOffsetY=0}_isOutSideCanvas(pointer){return pointer.x<0||pointer.x>this.canvas.getWidth()||pointer.y<0||pointer.y>this.canvas.getHeight()}}const _excluded$a=["path","left","top"],_excluded2$2=["d"];class Path extends FabricObject{constructor(path){let _ref=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{path:_,left,top}=_ref;super(_objectWithoutProperties(_ref,_excluded$a)),this._setPath(path||[],!0),"number"==typeof left&&this.set(LEFT,left),"number"==typeof top&&this.set(TOP,top)}_setPath(path,adjustPosition){this.path=makePathSimpler(Array.isArray(path)?path:parsePath(path)),this.setBoundingBox(adjustPosition)}_findCenterFromElement(){const bbox=this._calcBoundsFromPath();return new Point(bbox.left+bbox.width/2,bbox.top+bbox.height/2)}_renderPathCommands(ctx){let subpathStartX=0,subpathStartY=0,x=0,y=0,controlX=0,controlY=0;const l=-this.pathOffset.x,t=-this.pathOffset.y;ctx.beginPath();for(const command of this.path)switch(command[0]){case"L":x=command[1],y=command[2],ctx.lineTo(x+l,y+t);break;case"M":x=command[1],y=command[2],subpathStartX=x,subpathStartY=y,ctx.moveTo(x+l,y+t);break;case"C":x=command[5],y=command[6],controlX=command[3],controlY=command[4],ctx.bezierCurveTo(command[1]+l,command[2]+t,controlX+l,controlY+t,x+l,y+t);break;case"Q":ctx.quadraticCurveTo(command[1]+l,command[2]+t,command[3]+l,command[4]+t),x=command[3],y=command[4],controlX=command[1],controlY=command[2];break;case"Z":x=subpathStartX,y=subpathStartY,ctx.closePath()}}_render(ctx){this._renderPathCommands(ctx),this._renderPaintInOrder(ctx)}toString(){return"#<Path (".concat(this.complexity(),'): { "top": ').concat(this.top,', "left": ').concat(this.left," }>")}toObject(){let propertiesToInclude=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return _objectSpread2(_objectSpread2({},super.toObject(propertiesToInclude)),{},{path:this.path.map((pathCmd=>pathCmd.slice()))})}toDatalessObject(){let propertiesToInclude=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];const o=this.toObject(propertiesToInclude);return this.sourcePath&&(delete o.path,o.sourcePath=this.sourcePath),o}_toSVG(){const path=joinPath(this.path,config.NUM_FRACTION_DIGITS);return["<path ","COMMON_PARTS",'d="'.concat(path,'" stroke-linecap="round" />\n')]}_getOffsetTransform(){const digits=config.NUM_FRACTION_DIGITS;return" translate(".concat(toFixed(-this.pathOffset.x,digits),", ").concat(toFixed(-this.pathOffset.y,digits),")")}toClipPathSVG(reviver){const additionalTransform=this._getOffsetTransform();return"\t"+this._createBaseClipPathSVGMarkup(this._toSVG(),{reviver,additionalTransform})}toSVG(reviver){const additionalTransform=this._getOffsetTransform();return this._createBaseSVGMarkup(this._toSVG(),{reviver,additionalTransform})}complexity(){return this.path.length}setDimensions(){this.setBoundingBox()}setBoundingBox(adjustPosition){const{width,height,pathOffset}=this._calcDimensions();this.set({width,height,pathOffset}),adjustPosition&&this.setPositionByOrigin(pathOffset,CENTER,CENTER)}_calcBoundsFromPath(){const bounds=[];let subpathStartX=0,subpathStartY=0,x=0,y=0;for(const command of this.path)switch(command[0]){case"L":x=command[1],y=command[2],bounds.push(new Point(subpathStartX,subpathStartY),new Point(x,y));break;case"M":x=command[1],y=command[2],subpathStartX=x,subpathStartY=y;break;case"C":bounds.push(...getBoundsOfCurve(x,y,command[1],command[2],command[3],command[4],command[5],command[6])),x=command[5],y=command[6];break;case"Q":bounds.push(...getBoundsOfCurve(x,y,command[1],command[2],command[1],command[2],command[3],command[4])),x=command[3],y=command[4];break;case"Z":x=subpathStartX,y=subpathStartY}return makeBoundingBoxFromPoints(bounds)}_calcDimensions(){const bbox=this._calcBoundsFromPath();return _objectSpread2(_objectSpread2({},bbox),{},{pathOffset:new Point(bbox.left+bbox.width/2,bbox.top+bbox.height/2)})}static fromObject(object){return this._fromObject(object,{extraParam:"path"})}static async fromElement(element,options,cssRules){const _parseAttributes=parseAttributes(element,this.ATTRIBUTE_NAMES,cssRules),{d}=_parseAttributes;return new this(d,_objectSpread2(_objectSpread2(_objectSpread2({},_objectWithoutProperties(_parseAttributes,_excluded2$2)),options),{},{left:void 0,top:void 0}))}}_defineProperty(Path,"type","Path"),_defineProperty(Path,"cacheProperties",[...cacheProperties,"path","fillRule"]),_defineProperty(Path,"ATTRIBUTE_NAMES",[...SHARED_ATTRIBUTES,"d"]),classRegistry.setClass(Path),classRegistry.setSVGClass(Path);const _excluded$9=["left","top","radius"],CIRCLE_PROPS=["radius","startAngle","endAngle"];class Circle extends FabricObject{static getDefaults(){return _objectSpread2(_objectSpread2({},super.getDefaults()),Circle.ownDefaults)}_set(key,value){return super._set(key,value),"radius"===key&&this.setRadius(value),this}_render(ctx){ctx.beginPath(),ctx.arc(0,0,this.radius,degreesToRadians(this.startAngle),degreesToRadians(this.endAngle),!1),this._renderPaintInOrder(ctx)}getRadiusX(){return this.get("radius")*this.get("scaleX")}getRadiusY(){return this.get("radius")*this.get("scaleY")}setRadius(value){this.radius=value,this.set({width:2*value,height:2*value})}toObject(){let propertiesToInclude=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return super.toObject([...CIRCLE_PROPS,...propertiesToInclude])}_toSVG(){const angle=(this.endAngle-this.startAngle)%360;if(0===angle)return["<circle ","COMMON_PARTS",'cx="0" cy="0" ','r="',"".concat(this.radius),'" />\n'];{const{radius}=this,start=degreesToRadians(this.startAngle),end=degreesToRadians(this.endAngle),startX=cos(start)*radius,startY=sin(start)*radius,endX=cos(end)*radius,endY=sin(end)*radius,largeFlag=angle>180?"1":"0";return['<path d="M '.concat(startX," ").concat(startY)," A ".concat(radius," ").concat(radius)," 0 ","".concat(largeFlag," 1")," ".concat(endX," ").concat(endY),'" ',"COMMON_PARTS"," />\n"]}}static async fromElement(element,options,cssRules){const _ref=parseAttributes(element,this.ATTRIBUTE_NAMES,cssRules),{left=0,top=0,radius=0}=_ref;return new this(_objectSpread2(_objectSpread2({},_objectWithoutProperties(_ref,_excluded$9)),{},{radius,left:left-radius,top:top-radius}))}static fromObject(object){return super._fromObject(object)}}_defineProperty(Circle,"type","Circle"),_defineProperty(Circle,"cacheProperties",[...cacheProperties,...CIRCLE_PROPS]),_defineProperty(Circle,"ownDefaults",{radius:0,startAngle:0,endAngle:360}),_defineProperty(Circle,"ATTRIBUTE_NAMES",["cx","cy","r",...SHARED_ATTRIBUTES]),classRegistry.setClass(Circle),classRegistry.setSVGClass(Circle);const _excluded$8=["x1","y1","x2","y2"],_excluded2$1=["x1","y1","x2","y2"],coordProps=["x1","x2","y1","y2"];class Line extends FabricObject{constructor(){let[x1,y1,x2,y2]=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[0,0,0,0],options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(_objectSpread2(_objectSpread2({},options),{},{x1,y1,x2,y2})),this._setWidthHeight();const{left,top}=options;"number"==typeof left&&this.set(LEFT,left),"number"==typeof top&&this.set(TOP,top)}_setWidthHeight(){const{x1,y1,x2,y2}=this;this.width=Math.abs(x2-x1),this.height=Math.abs(y2-y1);const{left,top,width,height}=makeBoundingBoxFromPoints([{x:x1,y:y1},{x:x2,y:y2}]),position=new Point(left+width/2,top+height/2);this.setPositionByOrigin(position,CENTER,CENTER)}_set(key,value){return super._set(key,value),coordProps.includes(key)&&this._setWidthHeight(),this}_render(ctx){ctx.beginPath();const p=this.calcLinePoints();ctx.moveTo(p.x1,p.y1),ctx.lineTo(p.x2,p.y2),ctx.lineWidth=this.strokeWidth;const origStrokeStyle=ctx.strokeStyle;var _this$stroke;isFiller(this.stroke)?ctx.strokeStyle=this.stroke.toLive(ctx):ctx.strokeStyle=null!==(_this$stroke=this.stroke)&&void 0!==_this$stroke?_this$stroke:ctx.fillStyle;this.stroke&&this._renderStroke(ctx),ctx.strokeStyle=origStrokeStyle}_findCenterFromElement(){return new Point((this.x1+this.x2)/2,(this.y1+this.y2)/2)}toObject(){let propertiesToInclude=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return _objectSpread2(_objectSpread2({},super.toObject(propertiesToInclude)),this.calcLinePoints())}_getNonTransformedDimensions(){const dim=super._getNonTransformedDimensions();return"butt"===this.strokeLineCap&&(0===this.width&&(dim.y-=this.strokeWidth),0===this.height&&(dim.x-=this.strokeWidth)),dim}calcLinePoints(){const{x1:_x1,x2:_x2,y1:_y1,y2:_y2,width,height}=this,xMult=_x1<=_x2?-1:1,yMult=_y1<=_y2?-1:1;return{x1:xMult*width/2,x2:xMult*-width/2,y1:yMult*height/2,y2:yMult*-height/2}}_toSVG(){const{x1,x2,y1,y2}=this.calcLinePoints();return["<line ","COMMON_PARTS",'x1="'.concat(x1,'" y1="').concat(y1,'" x2="').concat(x2,'" y2="').concat(y2,'" />\n')]}static async fromElement(element,options,cssRules){const _parseAttributes=parseAttributes(element,this.ATTRIBUTE_NAMES,cssRules),{x1=0,y1=0,x2=0,y2=0}=_parseAttributes;return new this([x1,y1,x2,y2],_objectWithoutProperties(_parseAttributes,_excluded$8))}static fromObject(_ref){let{x1,y1,x2,y2}=_ref,object=_objectWithoutProperties(_ref,_excluded2$1);return this._fromObject(_objectSpread2(_objectSpread2({},object),{},{points:[x1,y1,x2,y2]}),{extraParam:"points"})}}_defineProperty(Line,"type","Line"),_defineProperty(Line,"cacheProperties",[...cacheProperties,...coordProps]),_defineProperty(Line,"ATTRIBUTE_NAMES",SHARED_ATTRIBUTES.concat(coordProps)),classRegistry.setClass(Line),classRegistry.setSVGClass(Line);class Triangle extends FabricObject{static getDefaults(){return _objectSpread2(_objectSpread2({},super.getDefaults()),Triangle.ownDefaults)}_render(ctx){const widthBy2=this.width/2,heightBy2=this.height/2;ctx.beginPath(),ctx.moveTo(-widthBy2,heightBy2),ctx.lineTo(0,-heightBy2),ctx.lineTo(widthBy2,heightBy2),ctx.closePath(),this._renderPaintInOrder(ctx)}_toSVG(){const widthBy2=this.width/2,heightBy2=this.height/2;return["<polygon ","COMMON_PARTS",'points="',"".concat(-widthBy2," ").concat(heightBy2,",0 ").concat(-heightBy2,",").concat(widthBy2," ").concat(heightBy2),'" />']}}_defineProperty(Triangle,"type","Triangle"),_defineProperty(Triangle,"ownDefaults",{width:100,height:100}),classRegistry.setClass(Triangle),classRegistry.setSVGClass(Triangle);const ELLIPSE_PROPS=["rx","ry"];class Ellipse extends FabricObject{static getDefaults(){return _objectSpread2(_objectSpread2({},super.getDefaults()),Ellipse.ownDefaults)}_set(key,value){switch(super._set(key,value),key){case"rx":this.rx=value,this.set("width",2*value);break;case"ry":this.ry=value,this.set("height",2*value)}return this}getRx(){return this.get("rx")*this.get("scaleX")}getRy(){return this.get("ry")*this.get("scaleY")}toObject(){let propertiesToInclude=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return super.toObject([...ELLIPSE_PROPS,...propertiesToInclude])}_toSVG(){return["<ellipse ","COMMON_PARTS",'cx="0" cy="0" rx="'.concat(this.rx,'" ry="').concat(this.ry,'" />\n')]}_render(ctx){ctx.beginPath(),ctx.save(),ctx.transform(1,0,0,this.ry/this.rx,0,0),ctx.arc(0,0,this.rx,0,twoMathPi,!1),ctx.restore(),this._renderPaintInOrder(ctx)}static async fromElement(element,options,cssRules){const parsedAttributes=parseAttributes(element,this.ATTRIBUTE_NAMES,cssRules);return parsedAttributes.left=(parsedAttributes.left||0)-parsedAttributes.rx,parsedAttributes.top=(parsedAttributes.top||0)-parsedAttributes.ry,new this(parsedAttributes)}}_defineProperty(Ellipse,"type","Ellipse"),_defineProperty(Ellipse,"cacheProperties",[...cacheProperties,...ELLIPSE_PROPS]),_defineProperty(Ellipse,"ownDefaults",{rx:0,ry:0}),_defineProperty(Ellipse,"ATTRIBUTE_NAMES",[...SHARED_ATTRIBUTES,"cx","cy","rx","ry"]),classRegistry.setClass(Ellipse),classRegistry.setSVGClass(Ellipse);const _excluded$7=["left","top"],polylineDefaultValues={exactBoundingBox:!1};class Polyline extends FabricObject{static getDefaults(){return _objectSpread2(_objectSpread2({},super.getDefaults()),Polyline.ownDefaults)}constructor(){let options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(_objectSpread2({points:arguments.length>0&&void 0!==arguments[0]?arguments[0]:[]},options)),_defineProperty(this,"strokeDiff",void 0);const{left,top}=options;this.initialized=!0,this.setBoundingBox(!0),"number"==typeof left&&this.set(LEFT,left),"number"==typeof top&&this.set(TOP,top)}isOpen(){return!0}_projectStrokeOnPoints(options){return projectStrokeOnPoints(this.points,options,this.isOpen())}_calcDimensions(options){options=_objectSpread2({scaleX:this.scaleX,scaleY:this.scaleY,skewX:this.skewX,skewY:this.skewY,strokeLineCap:this.strokeLineCap,strokeLineJoin:this.strokeLineJoin,strokeMiterLimit:this.strokeMiterLimit,strokeUniform:this.strokeUniform,strokeWidth:this.strokeWidth},options||{});const points=this.exactBoundingBox?this._projectStrokeOnPoints(options).map((projection=>projection.projectedPoint)):this.points;if(0===points.length)return{left:0,top:0,width:0,height:0,pathOffset:new Point,strokeOffset:new Point,strokeDiff:new Point};const bbox=makeBoundingBoxFromPoints(points),matrix=calcDimensionsMatrix(_objectSpread2(_objectSpread2({},options),{},{scaleX:1,scaleY:1})),bboxNoStroke=makeBoundingBoxFromPoints(this.points.map((p=>transformPoint(p,matrix,!0)))),scale=new Point(this.scaleX,this.scaleY);let offsetX=bbox.left+bbox.width/2,offsetY=bbox.top+bbox.height/2;return this.exactBoundingBox&&(offsetX-=offsetY*Math.tan(degreesToRadians(this.skewX)),offsetY-=offsetX*Math.tan(degreesToRadians(this.skewY))),_objectSpread2(_objectSpread2({},bbox),{},{pathOffset:new Point(offsetX,offsetY),strokeOffset:new Point(bboxNoStroke.left,bboxNoStroke.top).subtract(new Point(bbox.left,bbox.top)).multiply(scale),strokeDiff:new Point(bbox.width,bbox.height).subtract(new Point(bboxNoStroke.width,bboxNoStroke.height)).multiply(scale)})}_findCenterFromElement(){const bbox=makeBoundingBoxFromPoints(this.points);return new Point(bbox.left+bbox.width/2,bbox.top+bbox.height/2)}setDimensions(){this.setBoundingBox()}setBoundingBox(adjustPosition){const{left,top,width,height,pathOffset,strokeOffset,strokeDiff}=this._calcDimensions();this.set({width,height,pathOffset,strokeOffset,strokeDiff}),adjustPosition&&this.setPositionByOrigin(new Point(left+width/2,top+height/2),CENTER,CENTER)}isStrokeAccountedForInDimensions(){return this.exactBoundingBox}_getNonTransformedDimensions(){return this.exactBoundingBox?new Point(this.width,this.height):super._getNonTransformedDimensions()}_getTransformedDimensions(){let options=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this.exactBoundingBox){let size;if(Object.keys(options).some((key=>this.strokeUniform||this.constructor.layoutProperties.includes(key)))){var _options$width,_options$height;const{width,height}=this._calcDimensions(options);size=new Point(null!==(_options$width=options.width)&&void 0!==_options$width?_options$width:width,null!==(_options$height=options.height)&&void 0!==_options$height?_options$height:height)}else{var _options$width2,_options$height2;size=new Point(null!==(_options$width2=options.width)&&void 0!==_options$width2?_options$width2:this.width,null!==(_options$height2=options.height)&&void 0!==_options$height2?_options$height2:this.height)}return size.multiply(new Point(options.scaleX||this.scaleX,options.scaleY||this.scaleY))}return super._getTransformedDimensions(options)}_set(key,value){const changed=this.initialized&&this[key]!==value,output=super._set(key,value);return this.exactBoundingBox&&changed&&(("scaleX"===key||"scaleY"===key)&&this.strokeUniform&&this.constructor.layoutProperties.includes("strokeUniform")||this.constructor.layoutProperties.includes(key))&&this.setDimensions(),output}toObject(){let propertiesToInclude=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return _objectSpread2(_objectSpread2({},super.toObject(propertiesToInclude)),{},{points:cloneDeep(this.points)})}_toSVG(){const points=[],diffX=this.pathOffset.x,diffY=this.pathOffset.y,NUM_FRACTION_DIGITS=config.NUM_FRACTION_DIGITS;for(let i=0,len=this.points.length;i<len;i++)points.push(toFixed(this.points[i].x-diffX,NUM_FRACTION_DIGITS),",",toFixed(this.points[i].y-diffY,NUM_FRACTION_DIGITS)," ");return["<".concat(this.constructor.type.toLowerCase()," "),"COMMON_PARTS",'points="'.concat(points.join(""),'" />\n')]}_render(ctx){const len=this.points.length,x=this.pathOffset.x,y=this.pathOffset.y;if(len&&!isNaN(this.points[len-1].y)){ctx.beginPath(),ctx.moveTo(this.points[0].x-x,this.points[0].y-y);for(let i=0;i<len;i++){const point=this.points[i];ctx.lineTo(point.x-x,point.y-y)}!this.isOpen()&&ctx.closePath(),this._renderPaintInOrder(ctx)}}complexity(){return this.points.length}static async fromElement(element,options,cssRules){return new this(function parsePointsAttribute(points){if(!points)return[];const pointsSplit=points.replace(/,/g," ").trim().split(/\s+/),parsedPoints=[];for(let i=0;i<pointsSplit.length;i+=2)parsedPoints.push({x:parseFloat(pointsSplit[i]),y:parseFloat(pointsSplit[i+1])});return parsedPoints}(element.getAttribute("points")),_objectSpread2(_objectSpread2({},_objectWithoutProperties(parseAttributes(element,this.ATTRIBUTE_NAMES,cssRules),_excluded$7)),options))}static fromObject(object){return this._fromObject(object,{extraParam:"points"})}}_defineProperty(Polyline,"ownDefaults",polylineDefaultValues),_defineProperty(Polyline,"type","Polyline"),_defineProperty(Polyline,"layoutProperties",["skewX","skewY","strokeLineCap","strokeLineJoin","strokeMiterLimit","strokeWidth","strokeUniform","points"]),_defineProperty(Polyline,"cacheProperties",[...cacheProperties,"points"]),_defineProperty(Polyline,"ATTRIBUTE_NAMES",[...SHARED_ATTRIBUTES]),classRegistry.setClass(Polyline),classRegistry.setSVGClass(Polyline);class Polygon extends Polyline{static getDefaults(){return _objectSpread2(_objectSpread2({},super.getDefaults()),Polyline.ownDefaults)}isOpen(){return!1}}_defineProperty(Polygon,"ownDefaults",polylineDefaultValues),_defineProperty(Polygon,"type","Polygon"),classRegistry.setClass(Polygon),classRegistry.setSVGClass(Polygon);const fontProperties=["fontSize","fontWeight","fontFamily","fontStyle"],textDecorationProperties=["underline","overline","linethrough"],textLayoutProperties=[...fontProperties,"lineHeight","text","charSpacing","textAlign","styles","path","pathStartOffset","pathSide","pathAlign"],additionalProps=[...textLayoutProperties,...textDecorationProperties,"textBackgroundColor","direction"],styleProperties=[...fontProperties,...textDecorationProperties,"stroke","strokeWidth","fill","deltaY","textBackgroundColor"],textDefaultValues={_reNewline:reNewline,_reSpacesAndTabs:/[ \t\r]/g,_reSpaceAndTab:/[ \t\r]/,_reWords:/\S+/g,fontSize:40,fontWeight:"normal",fontFamily:"Times New Roman",underline:!1,overline:!1,linethrough:!1,textAlign:LEFT,fontStyle:"normal",lineHeight:1.16,superscript:{size:.6,baseline:-.35},subscript:{size:.6,baseline:.11},textBackgroundColor:"",stroke:null,shadow:null,path:void 0,pathStartOffset:0,pathSide:LEFT,pathAlign:"baseline",_fontSizeFraction:.222,offsets:{underline:.1,linethrough:-.315,overline:-.88},_fontSizeMult:1.13,charSpacing:0,deltaY:0,direction:"ltr",CACHE_FONT_SIZE:400,MIN_TEXT_WIDTH:2},JUSTIFY="justify";class StyledText extends FabricObject{isEmptyStyles(lineIndex){if(!this.styles)return!0;if(void 0!==lineIndex&&!this.styles[lineIndex])return!0;const obj=void 0===lineIndex?this.styles:{line:this.styles[lineIndex]};for(const p1 in obj)for(const p2 in obj[p1])for(const p3 in obj[p1][p2])return!1;return!0}styleHas(property,lineIndex){if(!this.styles)return!1;if(void 0!==lineIndex&&!this.styles[lineIndex])return!1;const obj=void 0===lineIndex?this.styles:{0:this.styles[lineIndex]};for(const p1 in obj)for(const p2 in obj[p1])if(void 0!==obj[p1][p2][property])return!0;return!1}cleanStyle(property){if(!this.styles)return!1;const obj=this.styles;let letterCount,stylePropertyValue,stylesCount=0,allStyleObjectPropertiesMatch=!0,graphemeCount=0;for(const p1 in obj){letterCount=0;for(const p2 in obj[p1]){const styleObject=obj[p1][p2]||{};stylesCount++,void 0!==styleObject[property]?(stylePropertyValue?styleObject[property]!==stylePropertyValue&&(allStyleObjectPropertiesMatch=!1):stylePropertyValue=styleObject[property],styleObject[property]===this[property]&&delete styleObject[property]):allStyleObjectPropertiesMatch=!1,0!==Object.keys(styleObject).length?letterCount++:delete obj[p1][p2]}0===letterCount&&delete obj[p1]}for(let i=0;i<this._textLines.length;i++)graphemeCount+=this._textLines[i].length;allStyleObjectPropertiesMatch&&stylesCount===graphemeCount&&(this[property]=stylePropertyValue,this.removeStyle(property))}removeStyle(property){if(!this.styles)return;const obj=this.styles;let line,lineNum,charNum;for(lineNum in obj){for(charNum in line=obj[lineNum],line)delete line[charNum][property],0===Object.keys(line[charNum]).length&&delete line[charNum];0===Object.keys(line).length&&delete obj[lineNum]}}_extendStyles(index,style){const{lineIndex,charIndex}=this.get2DCursorLocation(index);this._getLineStyle(lineIndex)||this._setLineStyle(lineIndex);const newStyle=pickBy(_objectSpread2(_objectSpread2({},this._getStyleDeclaration(lineIndex,charIndex)),style),(value=>void 0!==value));this._setStyleDeclaration(lineIndex,charIndex,newStyle)}getSelectionStyles(startIndex,endIndex,complete){const styles=[];for(let i=startIndex;i<(endIndex||startIndex);i++)styles.push(this.getStyleAtPosition(i,complete));return styles}getStyleAtPosition(position,complete){const{lineIndex,charIndex}=this.get2DCursorLocation(position);return complete?this.getCompleteStyleDeclaration(lineIndex,charIndex):this._getStyleDeclaration(lineIndex,charIndex)}setSelectionStyles(styles,startIndex,endIndex){for(let i=startIndex;i<(endIndex||startIndex);i++)this._extendStyles(i,styles);this._forceClearCache=!0}_getStyleDeclaration(lineIndex,charIndex){var _lineStyle$charIndex;const lineStyle=this.styles&&this.styles[lineIndex];return lineStyle&&null!==(_lineStyle$charIndex=lineStyle[charIndex])&&void 0!==_lineStyle$charIndex?_lineStyle$charIndex:{}}getCompleteStyleDeclaration(lineIndex,charIndex){return _objectSpread2(_objectSpread2({},pick(this,this.constructor._styleProperties)),this._getStyleDeclaration(lineIndex,charIndex))}_setStyleDeclaration(lineIndex,charIndex,style){this.styles[lineIndex][charIndex]=style}_deleteStyleDeclaration(lineIndex,charIndex){delete this.styles[lineIndex][charIndex]}_getLineStyle(lineIndex){return!!this.styles[lineIndex]}_setLineStyle(lineIndex){this.styles[lineIndex]={}}_deleteLineStyle(lineIndex){delete this.styles[lineIndex]}}_defineProperty(StyledText,"_styleProperties",styleProperties);const multipleSpacesRegex=/  +/g,dblQuoteRegex=/"/g;function createSVGInlineRect(color,left,top,width,height){return"\t\t".concat(function(color,_ref){let{left,top,width,height}=_ref,precision=arguments.length>2&&void 0!==arguments[2]?arguments[2]:config.NUM_FRACTION_DIGITS;const svgColor=colorPropToSVG("fill",color,!1),[x,y,w,h]=[left,top,width,height].map((value=>toFixed(value,precision)));return"<rect ".concat(svgColor,' x="').concat(x,'" y="').concat(y,'" width="').concat(w,'" height="').concat(h,'"></rect>')}(color,{left,top,width,height}),"\n")}const _excluded$6=["textAnchor","textDecoration","dx","dy","top","left","fontSize","strokeWidth"];let measuringContext;class FabricText extends StyledText{static getDefaults(){return _objectSpread2(_objectSpread2({},super.getDefaults()),FabricText.ownDefaults)}constructor(text){let options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(_objectSpread2(_objectSpread2({},options),{},{text,styles:(null==options?void 0:options.styles)||{}})),_defineProperty(this,"__charBounds",[]),this.initialized=!0,this.path&&this.setPathInfo(),this.initDimensions(),this.setCoords()}setPathInfo(){const path=this.path;path&&(path.segmentsInfo=getPathSegmentsInfo(path.path))}_splitText(){const newLines=this._splitTextIntoLines(this.text);return this.textLines=newLines.lines,this._textLines=newLines.graphemeLines,this._unwrappedTextLines=newLines._unwrappedLines,this._text=newLines.graphemeText,newLines}initDimensions(){this._splitText(),this._clearCache(),this.dirty=!0,this.path?(this.width=this.path.width,this.height=this.path.height):(this.width=this.calcTextWidth()||this.cursorWidth||this.MIN_TEXT_WIDTH,this.height=this.calcTextHeight()),this.textAlign.includes(JUSTIFY)&&this.enlargeSpaces()}enlargeSpaces(){let diffSpace,currentLineWidth,numberOfSpaces,accumulatedSpace,line,charBound,spaces;for(let i=0,len=this._textLines.length;i<len;i++)if((this.textAlign===JUSTIFY||i!==len-1&&!this.isEndOfWrapping(i))&&(accumulatedSpace=0,line=this._textLines[i],currentLineWidth=this.getLineWidth(i),currentLineWidth<this.width&&(spaces=this.textLines[i].match(this._reSpacesAndTabs)))){numberOfSpaces=spaces.length,diffSpace=(this.width-currentLineWidth)/numberOfSpaces;for(let j=0;j<=line.length;j++)charBound=this.__charBounds[i][j],this._reSpaceAndTab.test(line[j])?(charBound.width+=diffSpace,charBound.kernedWidth+=diffSpace,charBound.left+=accumulatedSpace,accumulatedSpace+=diffSpace):charBound.left+=accumulatedSpace}}isEndOfWrapping(lineIndex){return lineIndex===this._textLines.length-1}missingNewlineOffset(lineIndex){return 1}get2DCursorLocation(selectionStart,skipWrapping){const lines=skipWrapping?this._unwrappedTextLines:this._textLines;let i;for(i=0;i<lines.length;i++){if(selectionStart<=lines[i].length)return{lineIndex:i,charIndex:selectionStart};selectionStart-=lines[i].length+this.missingNewlineOffset(i,skipWrapping)}return{lineIndex:i-1,charIndex:lines[i-1].length<selectionStart?lines[i-1].length:selectionStart}}toString(){return"#<Text (".concat(this.complexity(),'): { "text": "').concat(this.text,'", "fontFamily": "').concat(this.fontFamily,'" }>')}_getCacheCanvasDimensions(){const dims=super._getCacheCanvasDimensions(),fontSize=this.fontSize;return dims.width+=fontSize*dims.zoomX,dims.height+=fontSize*dims.zoomY,dims}_render(ctx){const path=this.path;path&&!path.isNotVisible()&&path._render(ctx),this._setTextStyles(ctx),this._renderTextLinesBackground(ctx),this._renderTextDecoration(ctx,"underline"),this._renderText(ctx),this._renderTextDecoration(ctx,"overline"),this._renderTextDecoration(ctx,"linethrough")}_renderText(ctx){"stroke"===this.paintFirst?(this._renderTextStroke(ctx),this._renderTextFill(ctx)):(this._renderTextFill(ctx),this._renderTextStroke(ctx))}_setTextStyles(ctx,charStyle,forMeasuring){if(ctx.textBaseline="alphabetic",this.path)switch(this.pathAlign){case CENTER:ctx.textBaseline="middle";break;case"ascender":ctx.textBaseline=TOP;break;case"descender":ctx.textBaseline="bottom"}ctx.font=this._getFontDeclaration(charStyle,forMeasuring)}calcTextWidth(){let maxWidth=this.getLineWidth(0);for(let i=1,len=this._textLines.length;i<len;i++){const currentLineWidth=this.getLineWidth(i);currentLineWidth>maxWidth&&(maxWidth=currentLineWidth)}return maxWidth}_renderTextLine(method,ctx,line,left,top,lineIndex){this._renderChars(method,ctx,line,left,top,lineIndex)}_renderTextLinesBackground(ctx){if(!this.textBackgroundColor&&!this.styleHas("textBackgroundColor"))return;const originalFill=ctx.fillStyle,leftOffset=this._getLeftOffset();let lineTopOffset=this._getTopOffset();for(let i=0,len=this._textLines.length;i<len;i++){const heightOfLine=this.getHeightOfLine(i);if(!this.textBackgroundColor&&!this.styleHas("textBackgroundColor",i)){lineTopOffset+=heightOfLine;continue}const jlen=this._textLines[i].length,lineLeftOffset=this._getLineLeftOffset(i);let drawStart,currentColor,boxWidth=0,boxStart=0,lastColor=this.getValueOfPropertyAt(i,0,"textBackgroundColor");for(let j=0;j<jlen;j++){const charBox=this.__charBounds[i][j];currentColor=this.getValueOfPropertyAt(i,j,"textBackgroundColor"),this.path?(ctx.save(),ctx.translate(charBox.renderLeft,charBox.renderTop),ctx.rotate(charBox.angle),ctx.fillStyle=currentColor,currentColor&&ctx.fillRect(-charBox.width/2,-heightOfLine/this.lineHeight*(1-this._fontSizeFraction),charBox.width,heightOfLine/this.lineHeight),ctx.restore()):currentColor!==lastColor?(drawStart=leftOffset+lineLeftOffset+boxStart,"rtl"===this.direction&&(drawStart=this.width-drawStart-boxWidth),ctx.fillStyle=lastColor,lastColor&&ctx.fillRect(drawStart,lineTopOffset,boxWidth,heightOfLine/this.lineHeight),boxStart=charBox.left,boxWidth=charBox.width,lastColor=currentColor):boxWidth+=charBox.kernedWidth}currentColor&&!this.path&&(drawStart=leftOffset+lineLeftOffset+boxStart,"rtl"===this.direction&&(drawStart=this.width-drawStart-boxWidth),ctx.fillStyle=currentColor,ctx.fillRect(drawStart,lineTopOffset,boxWidth,heightOfLine/this.lineHeight)),lineTopOffset+=heightOfLine}ctx.fillStyle=originalFill,this._removeShadow(ctx)}_measureChar(_char,charStyle,previousChar,prevCharStyle){const fontCache=cache.getFontCache(charStyle),fontDeclaration=this._getFontDeclaration(charStyle),couple=previousChar+_char,stylesAreEqual=previousChar&&fontDeclaration===this._getFontDeclaration(prevCharStyle),fontMultiplier=charStyle.fontSize/this.CACHE_FONT_SIZE;let width,coupleWidth,previousWidth,kernedWidth;if(previousChar&&void 0!==fontCache[previousChar]&&(previousWidth=fontCache[previousChar]),void 0!==fontCache[_char]&&(kernedWidth=width=fontCache[_char]),stylesAreEqual&&void 0!==fontCache[couple]&&(coupleWidth=fontCache[couple],kernedWidth=coupleWidth-previousWidth),void 0===width||void 0===previousWidth||void 0===coupleWidth){const ctx=function getMeasuringContext(){return measuringContext||(measuringContext=createCanvasElement().getContext("2d")),measuringContext}();this._setTextStyles(ctx,charStyle,!0),void 0===width&&(kernedWidth=width=ctx.measureText(_char).width,fontCache[_char]=width),void 0===previousWidth&&stylesAreEqual&&previousChar&&(previousWidth=ctx.measureText(previousChar).width,fontCache[previousChar]=previousWidth),stylesAreEqual&&void 0===coupleWidth&&(coupleWidth=ctx.measureText(couple).width,fontCache[couple]=coupleWidth,kernedWidth=coupleWidth-previousWidth)}return{width:width*fontMultiplier,kernedWidth:kernedWidth*fontMultiplier}}getHeightOfChar(line,_char){return this.getValueOfPropertyAt(line,_char,"fontSize")}measureLine(lineIndex){const lineInfo=this._measureLine(lineIndex);return 0!==this.charSpacing&&(lineInfo.width-=this._getWidthOfCharSpacing()),lineInfo.width<0&&(lineInfo.width=0),lineInfo}_measureLine(lineIndex){let prevGrapheme,graphemeInfo,width=0;const reverse=this.pathSide===RIGHT,path=this.path,line=this._textLines[lineIndex],llength=line.length,lineBounds=new Array(llength);this.__charBounds[lineIndex]=lineBounds;for(let i=0;i<llength;i++){const grapheme=line[i];graphemeInfo=this._getGraphemeBox(grapheme,lineIndex,i,prevGrapheme),lineBounds[i]=graphemeInfo,width+=graphemeInfo.kernedWidth,prevGrapheme=grapheme}if(lineBounds[llength]={left:graphemeInfo?graphemeInfo.left+graphemeInfo.width:0,width:0,kernedWidth:0,height:this.fontSize,deltaY:0},path&&path.segmentsInfo){let positionInPath=0;const totalPathLength=path.segmentsInfo[path.segmentsInfo.length-1].length;switch(this.textAlign){case LEFT:positionInPath=reverse?totalPathLength-width:0;break;case CENTER:positionInPath=(totalPathLength-width)/2;break;case RIGHT:positionInPath=reverse?0:totalPathLength-width}positionInPath+=this.pathStartOffset*(reverse?-1:1);for(let i=reverse?llength-1:0;reverse?i>=0:i<llength;reverse?i--:i++)graphemeInfo=lineBounds[i],positionInPath>totalPathLength?positionInPath%=totalPathLength:positionInPath<0&&(positionInPath+=totalPathLength),this._setGraphemeOnPath(positionInPath,graphemeInfo),positionInPath+=graphemeInfo.kernedWidth}return{width,numOfSpaces:0}}_setGraphemeOnPath(positionInPath,graphemeInfo){const centerPosition=positionInPath+graphemeInfo.kernedWidth/2,path=this.path,info=getPointOnPath(path.path,centerPosition,path.segmentsInfo);graphemeInfo.renderLeft=info.x-path.pathOffset.x,graphemeInfo.renderTop=info.y-path.pathOffset.y,graphemeInfo.angle=info.angle+(this.pathSide===RIGHT?Math.PI:0)}_getGraphemeBox(grapheme,lineIndex,charIndex,prevGrapheme,skipLeft){const style=this.getCompleteStyleDeclaration(lineIndex,charIndex),prevStyle=prevGrapheme?this.getCompleteStyleDeclaration(lineIndex,charIndex-1):{},info=this._measureChar(grapheme,style,prevGrapheme,prevStyle);let charSpacing,kernedWidth=info.kernedWidth,width=info.width;0!==this.charSpacing&&(charSpacing=this._getWidthOfCharSpacing(),width+=charSpacing,kernedWidth+=charSpacing);const box={width,left:0,height:style.fontSize,kernedWidth,deltaY:style.deltaY};if(charIndex>0&&!skipLeft){const previousBox=this.__charBounds[lineIndex][charIndex-1];box.left=previousBox.left+previousBox.width+info.kernedWidth-info.width}return box}getHeightOfLine(lineIndex){if(this.__lineHeights[lineIndex])return this.__lineHeights[lineIndex];let maxHeight=this.getHeightOfChar(lineIndex,0);for(let i=1,len=this._textLines[lineIndex].length;i<len;i++)maxHeight=Math.max(this.getHeightOfChar(lineIndex,i),maxHeight);return this.__lineHeights[lineIndex]=maxHeight*this.lineHeight*this._fontSizeMult}calcTextHeight(){let lineHeight,height=0;for(let i=0,len=this._textLines.length;i<len;i++)lineHeight=this.getHeightOfLine(i),height+=i===len-1?lineHeight/this.lineHeight:lineHeight;return height}_getLeftOffset(){return"ltr"===this.direction?-this.width/2:this.width/2}_getTopOffset(){return-this.height/2}_renderTextCommon(ctx,method){ctx.save();let lineHeights=0;const left=this._getLeftOffset(),top=this._getTopOffset();for(let i=0,len=this._textLines.length;i<len;i++){const heightOfLine=this.getHeightOfLine(i),maxHeight=heightOfLine/this.lineHeight,leftOffset=this._getLineLeftOffset(i);this._renderTextLine(method,ctx,this._textLines[i],left+leftOffset,top+lineHeights+maxHeight,i),lineHeights+=heightOfLine}ctx.restore()}_renderTextFill(ctx){(this.fill||this.styleHas("fill"))&&this._renderTextCommon(ctx,"fillText")}_renderTextStroke(ctx){(this.stroke&&0!==this.strokeWidth||!this.isEmptyStyles())&&(this.shadow&&!this.shadow.affectStroke&&this._removeShadow(ctx),ctx.save(),this._setLineDash(ctx,this.strokeDashArray),ctx.beginPath(),this._renderTextCommon(ctx,"strokeText"),ctx.closePath(),ctx.restore())}_renderChars(method,ctx,line,left,top,lineIndex){const lineHeight=this.getHeightOfLine(lineIndex),isJustify=this.textAlign.includes(JUSTIFY),path=this.path,shortCut=!isJustify&&0===this.charSpacing&&this.isEmptyStyles(lineIndex)&&!path,isLtr="ltr"===this.direction,sign="ltr"===this.direction?1:-1,currentDirection=ctx.direction;let actualStyle,nextStyle,charBox,timeToRender,drawingLeft,charsToRender="",boxWidth=0;if(ctx.save(),currentDirection!==this.direction&&(ctx.canvas.setAttribute("dir",isLtr?"ltr":"rtl"),ctx.direction=isLtr?"ltr":"rtl",ctx.textAlign=isLtr?LEFT:RIGHT),top-=lineHeight*this._fontSizeFraction/this.lineHeight,shortCut)return this._renderChar(method,ctx,lineIndex,0,line.join(""),left,top),void ctx.restore();for(let i=0,len=line.length-1;i<=len;i++)timeToRender=i===len||this.charSpacing||path,charsToRender+=line[i],charBox=this.__charBounds[lineIndex][i],0===boxWidth?(left+=sign*(charBox.kernedWidth-charBox.width),boxWidth+=charBox.width):boxWidth+=charBox.kernedWidth,isJustify&&!timeToRender&&this._reSpaceAndTab.test(line[i])&&(timeToRender=!0),timeToRender||(actualStyle=actualStyle||this.getCompleteStyleDeclaration(lineIndex,i),nextStyle=this.getCompleteStyleDeclaration(lineIndex,i+1),timeToRender=hasStyleChanged(actualStyle,nextStyle,!1)),timeToRender&&(path?(ctx.save(),ctx.translate(charBox.renderLeft,charBox.renderTop),ctx.rotate(charBox.angle),this._renderChar(method,ctx,lineIndex,i,charsToRender,-boxWidth/2,0),ctx.restore()):(drawingLeft=left,this._renderChar(method,ctx,lineIndex,i,charsToRender,drawingLeft,top)),charsToRender="",actualStyle=nextStyle,left+=sign*boxWidth,boxWidth=0);ctx.restore()}_applyPatternGradientTransformText(filler){const pCanvas=createCanvasElement(),width=this.width+this.strokeWidth,height=this.height+this.strokeWidth,pCtx=pCanvas.getContext("2d");return pCanvas.width=width,pCanvas.height=height,pCtx.beginPath(),pCtx.moveTo(0,0),pCtx.lineTo(width,0),pCtx.lineTo(width,height),pCtx.lineTo(0,height),pCtx.closePath(),pCtx.translate(width/2,height/2),pCtx.fillStyle=filler.toLive(pCtx),this._applyPatternGradientTransform(pCtx,filler),pCtx.fill(),pCtx.createPattern(pCanvas,"no-repeat")}handleFiller(ctx,property,filler){let offsetX,offsetY;return isFiller(filler)?"percentage"===filler.gradientUnits||filler.gradientTransform||filler.patternTransform?(offsetX=-this.width/2,offsetY=-this.height/2,ctx.translate(offsetX,offsetY),ctx[property]=this._applyPatternGradientTransformText(filler),{offsetX,offsetY}):(ctx[property]=filler.toLive(ctx),this._applyPatternGradientTransform(ctx,filler)):(ctx[property]=filler,{offsetX:0,offsetY:0})}_setStrokeStyles(ctx,_ref){let{stroke,strokeWidth}=_ref;return ctx.lineWidth=strokeWidth,ctx.lineCap=this.strokeLineCap,ctx.lineDashOffset=this.strokeDashOffset,ctx.lineJoin=this.strokeLineJoin,ctx.miterLimit=this.strokeMiterLimit,this.handleFiller(ctx,"strokeStyle",stroke)}_setFillStyles(ctx,_ref2){let{fill}=_ref2;return this.handleFiller(ctx,"fillStyle",fill)}_renderChar(method,ctx,lineIndex,charIndex,_char,left,top){const decl=this._getStyleDeclaration(lineIndex,charIndex),fullDecl=this.getCompleteStyleDeclaration(lineIndex,charIndex),shouldFill="fillText"===method&&fullDecl.fill,shouldStroke="strokeText"===method&&fullDecl.stroke&&fullDecl.strokeWidth;if(shouldStroke||shouldFill){if(ctx.save(),ctx.font=this._getFontDeclaration(fullDecl),decl.textBackgroundColor&&this._removeShadow(ctx),decl.deltaY&&(top+=decl.deltaY),shouldFill){const fillOffsets=this._setFillStyles(ctx,fullDecl);ctx.fillText(_char,left-fillOffsets.offsetX,top-fillOffsets.offsetY)}if(shouldStroke){const strokeOffsets=this._setStrokeStyles(ctx,fullDecl);ctx.strokeText(_char,left-strokeOffsets.offsetX,top-strokeOffsets.offsetY)}ctx.restore()}}setSuperscript(start,end){this._setScript(start,end,this.superscript)}setSubscript(start,end){this._setScript(start,end,this.subscript)}_setScript(start,end,schema){const loc=this.get2DCursorLocation(start,!0),fontSize=this.getValueOfPropertyAt(loc.lineIndex,loc.charIndex,"fontSize"),dy=this.getValueOfPropertyAt(loc.lineIndex,loc.charIndex,"deltaY"),style={fontSize:fontSize*schema.size,deltaY:dy+fontSize*schema.baseline};this.setSelectionStyles(style,start,end)}_getLineLeftOffset(lineIndex){const lineWidth=this.getLineWidth(lineIndex),lineDiff=this.width-lineWidth,textAlign=this.textAlign,direction=this.direction,isEndOfWrapping=this.isEndOfWrapping(lineIndex);let leftOffset=0;return textAlign===JUSTIFY||"justify-center"===textAlign&&!isEndOfWrapping||"justify-right"===textAlign&&!isEndOfWrapping||"justify-left"===textAlign&&!isEndOfWrapping?0:(textAlign===CENTER&&(leftOffset=lineDiff/2),textAlign===RIGHT&&(leftOffset=lineDiff),"justify-center"===textAlign&&(leftOffset=lineDiff/2),"justify-right"===textAlign&&(leftOffset=lineDiff),"rtl"===direction&&(textAlign===RIGHT||textAlign===JUSTIFY||"justify-right"===textAlign?leftOffset=0:textAlign===LEFT||"justify-left"===textAlign?leftOffset=-lineDiff:textAlign!==CENTER&&"justify-center"!==textAlign||(leftOffset=-lineDiff/2)),leftOffset)}_clearCache(){this._forceClearCache=!1,this.__lineWidths=[],this.__lineHeights=[],this.__charBounds=[]}getLineWidth(lineIndex){if(void 0!==this.__lineWidths[lineIndex])return this.__lineWidths[lineIndex];const{width}=this.measureLine(lineIndex);return this.__lineWidths[lineIndex]=width,width}_getWidthOfCharSpacing(){return 0!==this.charSpacing?this.fontSize*this.charSpacing/1e3:0}getValueOfPropertyAt(lineIndex,charIndex,property){var _charStyle$property;return null!==(_charStyle$property=this._getStyleDeclaration(lineIndex,charIndex)[property])&&void 0!==_charStyle$property?_charStyle$property:this[property]}_renderTextDecoration(ctx,type){if(!this[type]&&!this.styleHas(type))return;let topOffset=this._getTopOffset();const leftOffset=this._getLeftOffset(),path=this.path,charSpacing=this._getWidthOfCharSpacing(),offsetY=this.offsets[type];for(let i=0,len=this._textLines.length;i<len;i++){const heightOfLine=this.getHeightOfLine(i);if(!this[type]&&!this.styleHas(type,i)){topOffset+=heightOfLine;continue}const line=this._textLines[i],maxHeight=heightOfLine/this.lineHeight,lineLeftOffset=this._getLineLeftOffset(i);let currentDecoration,currentFill,boxStart=0,boxWidth=0,lastDecoration=this.getValueOfPropertyAt(i,0,type),lastFill=this.getValueOfPropertyAt(i,0,"fill");const top=topOffset+maxHeight*(1-this._fontSizeFraction);let size=this.getHeightOfChar(i,0),dy=this.getValueOfPropertyAt(i,0,"deltaY");for(let j=0,jlen=line.length;j<jlen;j++){const charBox=this.__charBounds[i][j];currentDecoration=this.getValueOfPropertyAt(i,j,type),currentFill=this.getValueOfPropertyAt(i,j,"fill");const currentSize=this.getHeightOfChar(i,j),currentDy=this.getValueOfPropertyAt(i,j,"deltaY");if(path&&currentDecoration&&currentFill)ctx.save(),ctx.fillStyle=lastFill,ctx.translate(charBox.renderLeft,charBox.renderTop),ctx.rotate(charBox.angle),ctx.fillRect(-charBox.kernedWidth/2,offsetY*currentSize+currentDy,charBox.kernedWidth,this.fontSize/15),ctx.restore();else if((currentDecoration!==lastDecoration||currentFill!==lastFill||currentSize!==size||currentDy!==dy)&&boxWidth>0){let drawStart=leftOffset+lineLeftOffset+boxStart;"rtl"===this.direction&&(drawStart=this.width-drawStart-boxWidth),lastDecoration&&lastFill&&(ctx.fillStyle=lastFill,ctx.fillRect(drawStart,top+offsetY*size+dy,boxWidth,this.fontSize/15)),boxStart=charBox.left,boxWidth=charBox.width,lastDecoration=currentDecoration,lastFill=currentFill,size=currentSize,dy=currentDy}else boxWidth+=charBox.kernedWidth}let drawStart=leftOffset+lineLeftOffset+boxStart;"rtl"===this.direction&&(drawStart=this.width-drawStart-boxWidth),ctx.fillStyle=currentFill,currentDecoration&&currentFill&&ctx.fillRect(drawStart,top+offsetY*size+dy,boxWidth-charSpacing,this.fontSize/15),topOffset+=heightOfLine}this._removeShadow(ctx)}_getFontDeclaration(){let{fontFamily=this.fontFamily,fontStyle=this.fontStyle,fontWeight=this.fontWeight,fontSize=this.fontSize}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},forMeasuring=arguments.length>1?arguments[1]:void 0;const parsedFontFamily=fontFamily.includes("'")||fontFamily.includes('"')||fontFamily.includes(",")||FabricText.genericFonts.includes(fontFamily.toLowerCase())?fontFamily:'"'.concat(fontFamily,'"');return[fontStyle,fontWeight,"".concat(forMeasuring?this.CACHE_FONT_SIZE:fontSize,"px"),parsedFontFamily].join(" ")}render(ctx){this.visible&&(this.canvas&&this.canvas.skipOffscreen&&!this.group&&!this.isOnScreen()||(this._forceClearCache&&this.initDimensions(),super.render(ctx)))}graphemeSplit(value){return graphemeSplit(value)}_splitTextIntoLines(text){const lines=text.split(this._reNewline),newLines=new Array(lines.length),newLine=["\n"];let newText=[];for(let i=0;i<lines.length;i++)newLines[i]=this.graphemeSplit(lines[i]),newText=newText.concat(newLines[i],newLine);return newText.pop(),{_unwrappedLines:newLines,lines,graphemeText:newText,graphemeLines:newLines}}toObject(){let propertiesToInclude=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return _objectSpread2(_objectSpread2({},super.toObject([...additionalProps,...propertiesToInclude])),{},{styles:stylesToArray(this.styles,this.text)},this.path?{path:this.path.toObject()}:{})}set(key,value){const{textLayoutProperties}=this.constructor;super.set(key,value);let needsDims=!1,isAddingPath=!1;if("object"==typeof key)for(const _key in key)"path"===_key&&this.setPathInfo(),needsDims=needsDims||textLayoutProperties.includes(_key),isAddingPath=isAddingPath||"path"===_key;else needsDims=textLayoutProperties.includes(key),isAddingPath="path"===key;return isAddingPath&&this.setPathInfo(),needsDims&&this.initialized&&(this.initDimensions(),this.setCoords()),this}complexity(){return 1}static async fromElement(element,options,cssRules){const parsedAttributes=parseAttributes(element,FabricText.ATTRIBUTE_NAMES,cssRules),_options$parsedAttrib=_objectSpread2(_objectSpread2({},options),parsedAttributes),{textAnchor=LEFT,textDecoration="",dx=0,dy=0,top=0,left=0,fontSize=DEFAULT_SVG_FONT_SIZE,strokeWidth=1}=_options$parsedAttrib,restOfOptions=_objectWithoutProperties(_options$parsedAttrib,_excluded$6),text=new this((element.textContent||"").replace(/^\s+|\s+$|\n+/g,"").replace(/\s+/g," "),_objectSpread2({left:left+dx,top:top+dy,underline:textDecoration.includes("underline"),overline:textDecoration.includes("overline"),linethrough:textDecoration.includes("line-through"),strokeWidth:0,fontSize},restOfOptions)),textHeightScaleFactor=text.getScaledHeight()/text.height,scaledDiff=((text.height+text.strokeWidth)*text.lineHeight-text.height)*textHeightScaleFactor,textHeight=text.getScaledHeight()+scaledDiff;let offX=0;return textAnchor===CENTER&&(offX=text.getScaledWidth()/2),textAnchor===RIGHT&&(offX=text.getScaledWidth()),text.set({left:text.left-offX,top:text.top-(textHeight-text.fontSize*(.07+text._fontSizeFraction))/text.lineHeight,strokeWidth}),text}static fromObject(object){return this._fromObject(_objectSpread2(_objectSpread2({},object),{},{styles:stylesFromArray(object.styles||{},object.text)}),{extraParam:"text"})}}_defineProperty(FabricText,"textLayoutProperties",textLayoutProperties),_defineProperty(FabricText,"cacheProperties",[...cacheProperties,...additionalProps]),_defineProperty(FabricText,"ownDefaults",textDefaultValues),_defineProperty(FabricText,"type","Text"),_defineProperty(FabricText,"genericFonts",["sans-serif","serif","cursive","fantasy","monospace"]),_defineProperty(FabricText,"ATTRIBUTE_NAMES",SHARED_ATTRIBUTES.concat("x","y","dx","dy","font-family","font-style","font-weight","font-size","letter-spacing","text-decoration","text-anchor")),applyMixins(FabricText,[class TextSVGExportMixin extends FabricObjectSVGExportMixin{_toSVG(){const offsets=this._getSVGLeftTopOffsets(),textAndBg=this._getSVGTextAndBg(offsets.textTop,offsets.textLeft);return this._wrapSVGTextAndBg(textAndBg)}toSVG(reviver){return this._createBaseSVGMarkup(this._toSVG(),{reviver,noStyle:!0,withShadow:!0})}_getSVGLeftTopOffsets(){return{textLeft:-this.width/2,textTop:-this.height/2,lineTop:this.getHeightOfLine(0)}}_wrapSVGTextAndBg(_ref){let{textBgRects,textSpans}=_ref;const textDecoration=this.getSvgTextDecoration(this);return[textBgRects.join(""),'\t\t<text xml:space="preserve" ',this.fontFamily?'font-family="'.concat(this.fontFamily.replace(dblQuoteRegex,"'"),'" '):"",this.fontSize?'font-size="'.concat(this.fontSize,'" '):"",this.fontStyle?'font-style="'.concat(this.fontStyle,'" '):"",this.fontWeight?'font-weight="'.concat(this.fontWeight,'" '):"",textDecoration?'text-decoration="'.concat(textDecoration,'" '):"","rtl"===this.direction?'direction="'.concat(this.direction,'" '):"",'style="',this.getSvgStyles(!0),'"',this.addPaintOrder()," >",textSpans.join(""),"</text>\n"]}_getSVGTextAndBg(textTopOffset,textLeftOffset){const textSpans=[],textBgRects=[];let lineOffset,height=textTopOffset;this.backgroundColor&&textBgRects.push(...createSVGInlineRect(this.backgroundColor,-this.width/2,-this.height/2,this.width,this.height));for(let i=0,len=this._textLines.length;i<len;i++)lineOffset=this._getLineLeftOffset(i),"rtl"===this.direction&&(lineOffset+=this.width),(this.textBackgroundColor||this.styleHas("textBackgroundColor",i))&&this._setSVGTextLineBg(textBgRects,i,textLeftOffset+lineOffset,height),this._setSVGTextLineText(textSpans,i,textLeftOffset+lineOffset,height),height+=this.getHeightOfLine(i);return{textSpans,textBgRects}}_createTextCharSpan(char,styleDecl,left,top){const styleProps=this.getSvgSpanStyles(styleDecl,char!==char.trim()||!!char.match(multipleSpacesRegex)),fillStyles=styleProps?'style="'.concat(styleProps,'"'):"",dy=styleDecl.deltaY,dySpan=dy?' dy="'.concat(toFixed(dy,config.NUM_FRACTION_DIGITS),'" '):"";return'<tspan x="'.concat(toFixed(left,config.NUM_FRACTION_DIGITS),'" y="').concat(toFixed(top,config.NUM_FRACTION_DIGITS),'" ').concat(dySpan).concat(fillStyles,">").concat(escapeXml(char),"</tspan>")}_setSVGTextLineText(textSpans,lineIndex,textLeftOffset,textTopOffset){const lineHeight=this.getHeightOfLine(lineIndex),isJustify=this.textAlign.includes(JUSTIFY),line=this._textLines[lineIndex];let actualStyle,nextStyle,charBox,style,timeToRender,charsToRender="",boxWidth=0;textTopOffset+=lineHeight*(1-this._fontSizeFraction)/this.lineHeight;for(let i=0,len=line.length-1;i<=len;i++)timeToRender=i===len||this.charSpacing,charsToRender+=line[i],charBox=this.__charBounds[lineIndex][i],0===boxWidth?(textLeftOffset+=charBox.kernedWidth-charBox.width,boxWidth+=charBox.width):boxWidth+=charBox.kernedWidth,isJustify&&!timeToRender&&this._reSpaceAndTab.test(line[i])&&(timeToRender=!0),timeToRender||(actualStyle=actualStyle||this.getCompleteStyleDeclaration(lineIndex,i),nextStyle=this.getCompleteStyleDeclaration(lineIndex,i+1),timeToRender=hasStyleChanged(actualStyle,nextStyle,!0)),timeToRender&&(style=this._getStyleDeclaration(lineIndex,i),textSpans.push(this._createTextCharSpan(charsToRender,style,textLeftOffset,textTopOffset)),charsToRender="",actualStyle=nextStyle,"rtl"===this.direction?textLeftOffset-=boxWidth:textLeftOffset+=boxWidth,boxWidth=0)}_setSVGTextLineBg(textBgRects,i,leftOffset,textTopOffset){const line=this._textLines[i],heightOfLine=this.getHeightOfLine(i)/this.lineHeight;let currentColor,boxWidth=0,boxStart=0,lastColor=this.getValueOfPropertyAt(i,0,"textBackgroundColor");for(let j=0;j<line.length;j++){const{left,width,kernedWidth}=this.__charBounds[i][j];currentColor=this.getValueOfPropertyAt(i,j,"textBackgroundColor"),currentColor!==lastColor?(lastColor&&textBgRects.push(...createSVGInlineRect(lastColor,leftOffset+boxStart,textTopOffset,boxWidth,heightOfLine)),boxStart=left,boxWidth=width,lastColor=currentColor):boxWidth+=kernedWidth}currentColor&&textBgRects.push(...createSVGInlineRect(lastColor,leftOffset+boxStart,textTopOffset,boxWidth,heightOfLine))}_getSVGLineTopOffset(lineIndex){let j,lineTopOffset=0;for(j=0;j<lineIndex;j++)lineTopOffset+=this.getHeightOfLine(j);const lastHeight=this.getHeightOfLine(j);return{lineTop:lineTopOffset,offset:(this._fontSizeMult-this._fontSizeFraction)*lastHeight/(this.lineHeight*this._fontSizeMult)}}getSvgStyles(skipShadow){return"".concat(super.getSvgStyles(skipShadow)," white-space: pre;")}getSvgSpanStyles(style,useWhiteSpace){const{fontFamily,strokeWidth,stroke,fill,fontSize,fontStyle,fontWeight,deltaY}=style,textDecoration=this.getSvgTextDecoration(style);return[stroke?colorPropToSVG("stroke",stroke):"",strokeWidth?"stroke-width: ".concat(strokeWidth,"; "):"",fontFamily?"font-family: ".concat(fontFamily.includes("'")||fontFamily.includes('"')?fontFamily:"'".concat(fontFamily,"'"),"; "):"",fontSize?"font-size: ".concat(fontSize,"px; "):"",fontStyle?"font-style: ".concat(fontStyle,"; "):"",fontWeight?"font-weight: ".concat(fontWeight,"; "):"",textDecoration?"text-decoration: ".concat(textDecoration,"; "):textDecoration,fill?colorPropToSVG("fill",fill):"",deltaY?"baseline-shift: ".concat(-deltaY,"; "):"",useWhiteSpace?"white-space: pre; ":""].join("")}getSvgTextDecoration(style){return["overline","underline","line-through"].filter((decoration=>style[decoration.replace("-","")])).join(" ")}}]),classRegistry.setClass(FabricText),classRegistry.setSVGClass(FabricText);class DraggableTextDelegate{constructor(target){_defineProperty(this,"target",void 0),_defineProperty(this,"__mouseDownInPlace",!1),_defineProperty(this,"__dragStartFired",!1),_defineProperty(this,"__isDraggingOver",!1),_defineProperty(this,"__dragStartSelection",void 0),_defineProperty(this,"__dragImageDisposer",void 0),_defineProperty(this,"_dispose",void 0),this.target=target;const disposers=[this.target.on("dragenter",this.dragEnterHandler.bind(this)),this.target.on("dragover",this.dragOverHandler.bind(this)),this.target.on("dragleave",this.dragLeaveHandler.bind(this)),this.target.on("dragend",this.dragEndHandler.bind(this)),this.target.on("drop",this.dropHandler.bind(this))];this._dispose=()=>{disposers.forEach((d=>d())),this._dispose=void 0}}isPointerOverSelection(e){const target=this.target,newSelection=target.getSelectionStartFromPointer(e);return target.isEditing&&newSelection>=target.selectionStart&&newSelection<=target.selectionEnd&&target.selectionStart<target.selectionEnd}start(e){return this.__mouseDownInPlace=this.isPointerOverSelection(e)}isActive(){return this.__mouseDownInPlace}end(e){const active=this.isActive();return active&&!this.__dragStartFired&&(this.target.setCursorByClick(e),this.target.initDelayedCursor(!0)),this.__mouseDownInPlace=!1,this.__dragStartFired=!1,this.__isDraggingOver=!1,active}getDragStartSelection(){return this.__dragStartSelection}setDragImage(e,_ref){var _e$dataTransfer;let{selectionStart,selectionEnd}=_ref;const target=this.target,canvas=target.canvas,flipFactor=new Point(target.flipX?-1:1,target.flipY?-1:1),boundaries=target._getCursorBoundaries(selectionStart),pos=new Point(boundaries.left+boundaries.leftOffset,boundaries.top+boundaries.topOffset).multiply(flipFactor).transform(target.calcTransformMatrix()),diff=canvas.getScenePoint(e).subtract(pos),retinaScaling=target.getCanvasRetinaScaling(),bbox=target.getBoundingRect(),correction=pos.subtract(new Point(bbox.left,bbox.top)),vpt=canvas.viewportTransform,offset=correction.add(diff).transform(vpt,!0),bgc=target.backgroundColor,styles=cloneDeep(target.styles);target.backgroundColor="";const styleOverride={stroke:"transparent",fill:"transparent",textBackgroundColor:"transparent"};target.setSelectionStyles(styleOverride,0,selectionStart),target.setSelectionStyles(styleOverride,selectionEnd,target.text.length),target.dirty=!0;const dragImage=target.toCanvasElement({enableRetinaScaling:canvas.enableRetinaScaling,viewportTransform:!0});target.backgroundColor=bgc,target.styles=styles,target.dirty=!0,setStyle(dragImage,{position:"fixed",left:"".concat(-dragImage.width,"px"),border:NONE,width:"".concat(dragImage.width/retinaScaling,"px"),height:"".concat(dragImage.height/retinaScaling,"px")}),this.__dragImageDisposer&&this.__dragImageDisposer(),this.__dragImageDisposer=()=>{dragImage.remove()},getDocumentFromElement(e.target||this.target.hiddenTextarea).body.appendChild(dragImage),null===(_e$dataTransfer=e.dataTransfer)||void 0===_e$dataTransfer||_e$dataTransfer.setDragImage(dragImage,offset.x,offset.y)}onDragStart(e){this.__dragStartFired=!0;const target=this.target,active=this.isActive();if(active&&e.dataTransfer){const selection=this.__dragStartSelection={selectionStart:target.selectionStart,selectionEnd:target.selectionEnd},value=target._text.slice(selection.selectionStart,selection.selectionEnd).join(""),data=_objectSpread2({text:target.text,value},selection);e.dataTransfer.setData("text/plain",value),e.dataTransfer.setData("application/fabric",JSON.stringify({value,styles:target.getSelectionStyles(selection.selectionStart,selection.selectionEnd,!0)})),e.dataTransfer.effectAllowed="copyMove",this.setDragImage(e,data)}return target.abortCursorAnimation(),active}canDrop(e){if(this.target.editable&&!this.target.getActiveControl()&&!e.defaultPrevented){if(this.isActive()&&this.__dragStartSelection){const index=this.target.getSelectionStartFromPointer(e),dragStartSelection=this.__dragStartSelection;return index<dragStartSelection.selectionStart||index>dragStartSelection.selectionEnd}return!0}return!1}targetCanDrop(e){return this.target.canDrop(e)}dragEnterHandler(_ref2){let{e}=_ref2;const canDrop=this.targetCanDrop(e);!this.__isDraggingOver&&canDrop&&(this.__isDraggingOver=!0)}dragOverHandler(ev){const{e}=ev,canDrop=this.targetCanDrop(e);!this.__isDraggingOver&&canDrop?this.__isDraggingOver=!0:this.__isDraggingOver&&!canDrop&&(this.__isDraggingOver=!1),this.__isDraggingOver&&(e.preventDefault(),ev.canDrop=!0,ev.dropTarget=this.target)}dragLeaveHandler(){(this.__isDraggingOver||this.isActive())&&(this.__isDraggingOver=!1)}dropHandler(ev){var _e$dataTransfer2;const{e}=ev,didDrop=e.defaultPrevented;this.__isDraggingOver=!1,e.preventDefault();let insert=null===(_e$dataTransfer2=e.dataTransfer)||void 0===_e$dataTransfer2?void 0:_e$dataTransfer2.getData("text/plain");if(insert&&!didDrop){const target=this.target,canvas=target.canvas;let insertAt=target.getSelectionStartFromPointer(e);const{styles}=e.dataTransfer.types.includes("application/fabric")?JSON.parse(e.dataTransfer.getData("application/fabric")):{},trailing=insert[Math.max(0,insert.length-1)],selectionStartOffset=0;if(this.__dragStartSelection){const selectionStart=this.__dragStartSelection.selectionStart,selectionEnd=this.__dragStartSelection.selectionEnd;insertAt>selectionStart&&insertAt<=selectionEnd?insertAt=selectionStart:insertAt>selectionEnd&&(insertAt-=selectionEnd-selectionStart),target.removeChars(selectionStart,selectionEnd),delete this.__dragStartSelection}target._reNewline.test(trailing)&&(target._reNewline.test(target._text[insertAt])||insertAt===target._text.length)&&(insert=insert.trimEnd()),ev.didDrop=!0,ev.dropTarget=target,target.insertChars(insert,styles,insertAt),canvas.setActiveObject(target),target.enterEditing(e),target.selectionStart=Math.min(insertAt+selectionStartOffset,target._text.length),target.selectionEnd=Math.min(target.selectionStart+insert.length,target._text.length),target.hiddenTextarea.value=target.text,target._updateTextarea(),target.hiddenTextarea.focus(),target.fire("changed",{index:insertAt+selectionStartOffset,action:"drop"}),canvas.fire("text:changed",{target}),canvas.contextTopDirty=!0,canvas.requestRenderAll()}}dragEndHandler(_ref3){let{e}=_ref3;if(this.isActive()&&this.__dragStartFired&&this.__dragStartSelection){var _e$dataTransfer3;const target=this.target,canvas=this.target.canvas,{selectionStart,selectionEnd}=this.__dragStartSelection,dropEffect=(null===(_e$dataTransfer3=e.dataTransfer)||void 0===_e$dataTransfer3?void 0:_e$dataTransfer3.dropEffect)||NONE;dropEffect===NONE?(target.selectionStart=selectionStart,target.selectionEnd=selectionEnd,target._updateTextarea(),target.hiddenTextarea.focus()):(target.clearContextTop(),"move"===dropEffect&&(target.removeChars(selectionStart,selectionEnd),target.selectionStart=target.selectionEnd=selectionStart,target.hiddenTextarea&&(target.hiddenTextarea.value=target.text),target._updateTextarea(),target.fire("changed",{index:selectionStart,action:"dragend"}),canvas.fire("text:changed",{target}),canvas.requestRenderAll()),target.exitEditing())}this.__dragImageDisposer&&this.__dragImageDisposer(),delete this.__dragImageDisposer,delete this.__dragStartSelection,this.__isDraggingOver=!1}dispose(){this._dispose&&this._dispose()}}const reNonWord=/[ \n\.,;!\?\-]/;class ITextBehavior extends FabricText{constructor(){super(...arguments),_defineProperty(this,"_currentCursorOpacity",1)}initBehavior(){this._tick=this._tick.bind(this),this._onTickComplete=this._onTickComplete.bind(this),this.updateSelectionOnMouseMove=this.updateSelectionOnMouseMove.bind(this)}onDeselect(options){return this.isEditing&&this.exitEditing(),this.selected=!1,super.onDeselect(options)}_animateCursor(_ref){let{toValue,duration,delay,onComplete}=_ref;return animate({startValue:this._currentCursorOpacity,endValue:toValue,duration,delay,onComplete,abort:()=>!this.canvas||this.selectionStart!==this.selectionEnd,onChange:value=>{this._currentCursorOpacity=value,this.renderCursorOrSelection()}})}_tick(delay){this._currentTickState=this._animateCursor({toValue:1,duration:this.cursorDuration,delay,onComplete:this._onTickComplete})}_onTickComplete(){var _this$_currentTickCom;null===(_this$_currentTickCom=this._currentTickCompleteState)||void 0===_this$_currentTickCom||_this$_currentTickCom.abort(),this._currentTickCompleteState=this._animateCursor({toValue:0,duration:this.cursorDuration/2,delay:100,onComplete:this._tick})}initDelayedCursor(restart){this.abortCursorAnimation(),this._tick(restart?0:this.cursorDelay)}abortCursorAnimation(){let shouldClear=!1;[this._currentTickState,this._currentTickCompleteState].forEach((cursorAnimation=>{cursorAnimation&&!cursorAnimation.isDone()&&(shouldClear=!0,cursorAnimation.abort())})),this._currentCursorOpacity=1,shouldClear&&this.clearContextTop()}restartCursorIfNeeded(){[this._currentTickState,this._currentTickCompleteState].some((cursorAnimation=>!cursorAnimation||cursorAnimation.isDone()))&&this.initDelayedCursor()}selectAll(){return this.selectionStart=0,this.selectionEnd=this._text.length,this._fireSelectionChanged(),this._updateTextarea(),this}getSelectedText(){return this._text.slice(this.selectionStart,this.selectionEnd).join("")}findWordBoundaryLeft(startFrom){let offset=0,index=startFrom-1;if(this._reSpace.test(this._text[index]))for(;this._reSpace.test(this._text[index]);)offset++,index--;for(;/\S/.test(this._text[index])&&index>-1;)offset++,index--;return startFrom-offset}findWordBoundaryRight(startFrom){let offset=0,index=startFrom;if(this._reSpace.test(this._text[index]))for(;this._reSpace.test(this._text[index]);)offset++,index++;for(;/\S/.test(this._text[index])&&index<this._text.length;)offset++,index++;return startFrom+offset}findLineBoundaryLeft(startFrom){let offset=0,index=startFrom-1;for(;!/\n/.test(this._text[index])&&index>-1;)offset++,index--;return startFrom-offset}findLineBoundaryRight(startFrom){let offset=0,index=startFrom;for(;!/\n/.test(this._text[index])&&index<this._text.length;)offset++,index++;return startFrom+offset}searchWordBoundary(selectionStart,direction){const text=this._text;let index=selectionStart>0&&this._reSpace.test(text[selectionStart])&&(-1===direction||!reNewline.test(text[selectionStart-1]))?selectionStart-1:selectionStart,_char=text[index];for(;index>0&&index<text.length&&!reNonWord.test(_char);)index+=direction,_char=text[index];return-1===direction&&reNonWord.test(_char)&&index++,index}selectWord(selectionStart){selectionStart=selectionStart||this.selectionStart;const newSelectionStart=this.searchWordBoundary(selectionStart,-1),newSelectionEnd=Math.max(newSelectionStart,this.searchWordBoundary(selectionStart,1));this.selectionStart=newSelectionStart,this.selectionEnd=newSelectionEnd,this._fireSelectionChanged(),this._updateTextarea(),this.renderCursorOrSelection()}selectLine(selectionStart){selectionStart=selectionStart||this.selectionStart;const newSelectionStart=this.findLineBoundaryLeft(selectionStart),newSelectionEnd=this.findLineBoundaryRight(selectionStart);return this.selectionStart=newSelectionStart,this.selectionEnd=newSelectionEnd,this._fireSelectionChanged(),this._updateTextarea(),this}enterEditing(e){!this.isEditing&&this.editable&&(this.canvas&&(this.canvas.calcOffset(),this.canvas.textEditingManager.exitTextEditing()),this.isEditing=!0,this.initHiddenTextarea(),this.hiddenTextarea.focus(),this.hiddenTextarea.value=this.text,this._updateTextarea(),this._saveEditingProps(),this._setEditingProps(),this._textBeforeEdit=this.text,this._tick(),this.fire("editing:entered",e?{e}:void 0),this._fireSelectionChanged(),this.canvas&&(this.canvas.fire("text:editing:entered",{target:this,e}),this.canvas.requestRenderAll()))}updateSelectionOnMouseMove(e){if(this.getActiveControl())return;const el=this.hiddenTextarea;getDocumentFromElement(el).activeElement!==el&&el.focus();const newSelectionStart=this.getSelectionStartFromPointer(e),currentStart=this.selectionStart,currentEnd=this.selectionEnd;(newSelectionStart===this.__selectionStartOnMouseDown&&currentStart!==currentEnd||currentStart!==newSelectionStart&&currentEnd!==newSelectionStart)&&(newSelectionStart>this.__selectionStartOnMouseDown?(this.selectionStart=this.__selectionStartOnMouseDown,this.selectionEnd=newSelectionStart):(this.selectionStart=newSelectionStart,this.selectionEnd=this.__selectionStartOnMouseDown),this.selectionStart===currentStart&&this.selectionEnd===currentEnd||(this._fireSelectionChanged(),this._updateTextarea(),this.renderCursorOrSelection()))}_setEditingProps(){this.hoverCursor="text",this.canvas&&(this.canvas.defaultCursor=this.canvas.moveCursor="text"),this.borderColor=this.editingBorderColor,this.hasControls=this.selectable=!1,this.lockMovementX=this.lockMovementY=!0}fromStringToGraphemeSelection(start,end,text){const smallerTextStart=text.slice(0,start),graphemeStart=this.graphemeSplit(smallerTextStart).length;if(start===end)return{selectionStart:graphemeStart,selectionEnd:graphemeStart};const smallerTextEnd=text.slice(start,end);return{selectionStart:graphemeStart,selectionEnd:graphemeStart+this.graphemeSplit(smallerTextEnd).length}}fromGraphemeToStringSelection(start,end,graphemes){const graphemeStart=graphemes.slice(0,start).join("").length;if(start===end)return{selectionStart:graphemeStart,selectionEnd:graphemeStart};return{selectionStart:graphemeStart,selectionEnd:graphemeStart+graphemes.slice(start,end).join("").length}}_updateTextarea(){if(this.cursorOffsetCache={},this.hiddenTextarea){if(!this.inCompositionMode){const newSelection=this.fromGraphemeToStringSelection(this.selectionStart,this.selectionEnd,this._text);this.hiddenTextarea.selectionStart=newSelection.selectionStart,this.hiddenTextarea.selectionEnd=newSelection.selectionEnd}this.updateTextareaPosition()}}updateFromTextArea(){if(!this.hiddenTextarea)return;this.cursorOffsetCache={};const textarea=this.hiddenTextarea;this.text=textarea.value,this.set("dirty",!0),this.initDimensions(),this.setCoords();const newSelection=this.fromStringToGraphemeSelection(textarea.selectionStart,textarea.selectionEnd,textarea.value);this.selectionEnd=this.selectionStart=newSelection.selectionEnd,this.inCompositionMode||(this.selectionStart=newSelection.selectionStart),this.updateTextareaPosition()}updateTextareaPosition(){if(this.selectionStart===this.selectionEnd){const style=this._calcTextareaPosition();this.hiddenTextarea.style.left=style.left,this.hiddenTextarea.style.top=style.top}}_calcTextareaPosition(){if(!this.canvas)return{left:"1px",top:"1px"};const desiredPosition=this.inCompositionMode?this.compositionStart:this.selectionStart,boundaries=this._getCursorBoundaries(desiredPosition),cursorLocation=this.get2DCursorLocation(desiredPosition),lineIndex=cursorLocation.lineIndex,charIndex=cursorLocation.charIndex,charHeight=this.getValueOfPropertyAt(lineIndex,charIndex,"fontSize")*this.lineHeight,leftOffset=boundaries.leftOffset,retinaScaling=this.getCanvasRetinaScaling(),upperCanvas=this.canvas.upperCanvasEl,upperCanvasWidth=upperCanvas.width/retinaScaling,upperCanvasHeight=upperCanvas.height/retinaScaling,maxWidth=upperCanvasWidth-charHeight,maxHeight=upperCanvasHeight-charHeight,p=new Point(boundaries.left+leftOffset,boundaries.top+boundaries.topOffset+charHeight).transform(this.calcTransformMatrix()).transform(this.canvas.viewportTransform).multiply(new Point(upperCanvas.clientWidth/upperCanvasWidth,upperCanvas.clientHeight/upperCanvasHeight));return p.x<0&&(p.x=0),p.x>maxWidth&&(p.x=maxWidth),p.y<0&&(p.y=0),p.y>maxHeight&&(p.y=maxHeight),p.x+=this.canvas._offset.left,p.y+=this.canvas._offset.top,{left:"".concat(p.x,"px"),top:"".concat(p.y,"px"),fontSize:"".concat(charHeight,"px"),charHeight}}_saveEditingProps(){this._savedProps={hasControls:this.hasControls,borderColor:this.borderColor,lockMovementX:this.lockMovementX,lockMovementY:this.lockMovementY,hoverCursor:this.hoverCursor,selectable:this.selectable,defaultCursor:this.canvas&&this.canvas.defaultCursor,moveCursor:this.canvas&&this.canvas.moveCursor}}_restoreEditingProps(){this._savedProps&&(this.hoverCursor=this._savedProps.hoverCursor,this.hasControls=this._savedProps.hasControls,this.borderColor=this._savedProps.borderColor,this.selectable=this._savedProps.selectable,this.lockMovementX=this._savedProps.lockMovementX,this.lockMovementY=this._savedProps.lockMovementY,this.canvas&&(this.canvas.defaultCursor=this._savedProps.defaultCursor||this.canvas.defaultCursor,this.canvas.moveCursor=this._savedProps.moveCursor||this.canvas.moveCursor),delete this._savedProps)}_exitEditing(){const hiddenTextarea=this.hiddenTextarea;this.selected=!1,this.isEditing=!1,hiddenTextarea&&(hiddenTextarea.blur&&hiddenTextarea.blur(),hiddenTextarea.parentNode&&hiddenTextarea.parentNode.removeChild(hiddenTextarea)),this.hiddenTextarea=null,this.abortCursorAnimation(),this.selectionStart!==this.selectionEnd&&this.clearContextTop()}exitEditing(){const isTextChanged=this._textBeforeEdit!==this.text;return this._exitEditing(),this.selectionEnd=this.selectionStart,this._restoreEditingProps(),this._forceClearCache&&(this.initDimensions(),this.setCoords()),this.fire("editing:exited"),isTextChanged&&this.fire("modified"),this.canvas&&(this.canvas.fire("text:editing:exited",{target:this}),isTextChanged&&this.canvas.fire("object:modified",{target:this})),this}_removeExtraneousStyles(){for(const prop in this.styles)this._textLines[prop]||delete this.styles[prop]}removeStyleFromTo(start,end){const{lineIndex:lineStart,charIndex:charStart}=this.get2DCursorLocation(start,!0),{lineIndex:lineEnd,charIndex:charEnd}=this.get2DCursorLocation(end,!0);if(lineStart!==lineEnd){if(this.styles[lineStart])for(let i=charStart;i<this._unwrappedTextLines[lineStart].length;i++)delete this.styles[lineStart][i];if(this.styles[lineEnd])for(let i=charEnd;i<this._unwrappedTextLines[lineEnd].length;i++){const styleObj=this.styles[lineEnd][i];styleObj&&(this.styles[lineStart]||(this.styles[lineStart]={}),this.styles[lineStart][charStart+i-charEnd]=styleObj)}for(let i=lineStart+1;i<=lineEnd;i++)delete this.styles[i];this.shiftLineStyles(lineEnd,lineStart-lineEnd)}else if(this.styles[lineStart]){const styleObj=this.styles[lineStart],diff=charEnd-charStart;for(let i=charStart;i<charEnd;i++)delete styleObj[i];for(const char in this.styles[lineStart]){const numericChar=parseInt(char,10);numericChar>=charEnd&&(styleObj[numericChar-diff]=styleObj[char],delete styleObj[char])}}}shiftLineStyles(lineIndex,offset){const clonedStyles=Object.assign({},this.styles);for(const line in this.styles){const numericLine=parseInt(line,10);numericLine>lineIndex&&(this.styles[numericLine+offset]=clonedStyles[numericLine],clonedStyles[numericLine-offset]||delete this.styles[numericLine])}}insertNewlineStyleObject(lineIndex,charIndex,qty,copiedStyle){const newLineStyles={},originalLineLength=this._unwrappedTextLines[lineIndex].length,isEndOfLine=originalLineLength===charIndex;let someStyleIsCarryingOver=!1;qty||(qty=1),this.shiftLineStyles(lineIndex,qty);const currentCharStyle=this.styles[lineIndex]?this.styles[lineIndex][0===charIndex?charIndex:charIndex-1]:void 0;for(const index in this.styles[lineIndex]){const numIndex=parseInt(index,10);numIndex>=charIndex&&(someStyleIsCarryingOver=!0,newLineStyles[numIndex-charIndex]=this.styles[lineIndex][index],isEndOfLine&&0===charIndex||delete this.styles[lineIndex][index])}let styleCarriedOver=!1;for(someStyleIsCarryingOver&&!isEndOfLine&&(this.styles[lineIndex+qty]=newLineStyles,styleCarriedOver=!0),(styleCarriedOver||originalLineLength>charIndex)&&qty--;qty>0;)copiedStyle&&copiedStyle[qty-1]?this.styles[lineIndex+qty]={0:_objectSpread2({},copiedStyle[qty-1])}:currentCharStyle?this.styles[lineIndex+qty]={0:_objectSpread2({},currentCharStyle)}:delete this.styles[lineIndex+qty],qty--;this._forceClearCache=!0}insertCharStyleObject(lineIndex,charIndex,quantity,copiedStyle){this.styles||(this.styles={});const currentLineStyles=this.styles[lineIndex],currentLineStylesCloned=currentLineStyles?_objectSpread2({},currentLineStyles):{};quantity||(quantity=1);for(const index in currentLineStylesCloned){const numericIndex=parseInt(index,10);numericIndex>=charIndex&&(currentLineStyles[numericIndex+quantity]=currentLineStylesCloned[numericIndex],currentLineStylesCloned[numericIndex-quantity]||delete currentLineStyles[numericIndex])}if(this._forceClearCache=!0,copiedStyle){for(;quantity--;)Object.keys(copiedStyle[quantity]).length&&(this.styles[lineIndex]||(this.styles[lineIndex]={}),this.styles[lineIndex][charIndex+quantity]=_objectSpread2({},copiedStyle[quantity]));return}if(!currentLineStyles)return;const newStyle=currentLineStyles[charIndex?charIndex-1:1];for(;newStyle&&quantity--;)this.styles[lineIndex][charIndex+quantity]=_objectSpread2({},newStyle)}insertNewStyleBlock(insertedText,start,copiedStyle){const cursorLoc=this.get2DCursorLocation(start,!0),addedLines=[0];let i,linesLength=0;for(let i=0;i<insertedText.length;i++)"\n"===insertedText[i]?(linesLength++,addedLines[linesLength]=0):addedLines[linesLength]++;for(addedLines[0]>0&&(this.insertCharStyleObject(cursorLoc.lineIndex,cursorLoc.charIndex,addedLines[0],copiedStyle),copiedStyle=copiedStyle&&copiedStyle.slice(addedLines[0]+1)),linesLength&&this.insertNewlineStyleObject(cursorLoc.lineIndex,cursorLoc.charIndex+addedLines[0],linesLength),i=1;i<linesLength;i++)addedLines[i]>0?this.insertCharStyleObject(cursorLoc.lineIndex+i,0,addedLines[i],copiedStyle):copiedStyle&&this.styles[cursorLoc.lineIndex+i]&&copiedStyle[0]&&(this.styles[cursorLoc.lineIndex+i][0]=copiedStyle[0]),copiedStyle=copiedStyle&&copiedStyle.slice(addedLines[i]+1);addedLines[i]>0&&this.insertCharStyleObject(cursorLoc.lineIndex+i,0,addedLines[i],copiedStyle)}removeChars(start){let end=arguments.length>1&&void 0!==arguments[1]?arguments[1]:start+1;this.removeStyleFromTo(start,end),this._text.splice(start,end-start),this.text=this._text.join(""),this.set("dirty",!0),this.initDimensions(),this.setCoords(),this._removeExtraneousStyles()}insertChars(text,style,start){let end=arguments.length>3&&void 0!==arguments[3]?arguments[3]:start;end>start&&this.removeStyleFromTo(start,end);const graphemes=this.graphemeSplit(text);this.insertNewStyleBlock(graphemes,start,style),this._text=[...this._text.slice(0,start),...graphemes,...this._text.slice(end)],this.text=this._text.join(""),this.set("dirty",!0),this.initDimensions(),this.setCoords(),this._removeExtraneousStyles()}setSelectionStartEndWithShift(start,end,newSelection){newSelection<=start?(end===start?this._selectionDirection=LEFT:this._selectionDirection===RIGHT&&(this._selectionDirection=LEFT,this.selectionEnd=start),this.selectionStart=newSelection):newSelection>start&&newSelection<end?this._selectionDirection===RIGHT?this.selectionEnd=newSelection:this.selectionStart=newSelection:(end===start?this._selectionDirection=RIGHT:this._selectionDirection===LEFT&&(this._selectionDirection=RIGHT,this.selectionStart=end),this.selectionEnd=newSelection)}}class ITextKeyBehavior extends ITextBehavior{initHiddenTextarea(){const doc=this.canvas&&getDocumentFromElement(this.canvas.getElement())||getFabricDocument(),textarea=doc.createElement("textarea");Object.entries({autocapitalize:"off",autocorrect:"off",autocomplete:"off",spellcheck:"false","data-fabric":"textarea",wrap:"off"}).map((_ref=>{let[attribute,value]=_ref;return textarea.setAttribute(attribute,value)}));const{top,left,fontSize}=this._calcTextareaPosition();textarea.style.cssText="position: absolute; top: ".concat(top,"; left: ").concat(left,"; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding-top: ").concat(fontSize,";"),(this.hiddenTextareaContainer||doc.body).appendChild(textarea),Object.entries({blur:"blur",keydown:"onKeyDown",keyup:"onKeyUp",input:"onInput",copy:"copy",cut:"copy",paste:"paste",compositionstart:"onCompositionStart",compositionupdate:"onCompositionUpdate",compositionend:"onCompositionEnd"}).map((_ref2=>{let[eventName,handler]=_ref2;return textarea.addEventListener(eventName,this[handler].bind(this))})),this.hiddenTextarea=textarea}blur(){this.abortCursorAnimation()}onKeyDown(e){if(!this.isEditing)return;const keyMap="rtl"===this.direction?this.keysMapRtl:this.keysMap;if(e.keyCode in keyMap)this[keyMap[e.keyCode]](e);else{if(!(e.keyCode in this.ctrlKeysMapDown)||!e.ctrlKey&&!e.metaKey)return;this[this.ctrlKeysMapDown[e.keyCode]](e)}e.stopImmediatePropagation(),e.preventDefault(),e.keyCode>=33&&e.keyCode<=40?(this.inCompositionMode=!1,this.clearContextTop(),this.renderCursorOrSelection()):this.canvas&&this.canvas.requestRenderAll()}onKeyUp(e){!this.isEditing||this._copyDone||this.inCompositionMode?this._copyDone=!1:e.keyCode in this.ctrlKeysMapUp&&(e.ctrlKey||e.metaKey)&&(this[this.ctrlKeysMapUp[e.keyCode]](e),e.stopImmediatePropagation(),e.preventDefault(),this.canvas&&this.canvas.requestRenderAll())}onInput(e){const fromPaste=this.fromPaste;if(this.fromPaste=!1,e&&e.stopPropagation(),!this.isEditing)return;const updateAndFire=()=>{this.updateFromTextArea(),this.fire("changed"),this.canvas&&(this.canvas.fire("text:changed",{target:this}),this.canvas.requestRenderAll())};if(""===this.hiddenTextarea.value)return this.styles={},void updateAndFire();const nextText=this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText,charCount=this._text.length,nextCharCount=nextText.length,selectionStart=this.selectionStart,selectionEnd=this.selectionEnd,selection=selectionStart!==selectionEnd;let copiedStyle,removedText,removeFrom,removeTo,charDiff=nextCharCount-charCount;const textareaSelection=this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart,this.hiddenTextarea.selectionEnd,this.hiddenTextarea.value),backDelete=selectionStart>textareaSelection.selectionStart;selection?(removedText=this._text.slice(selectionStart,selectionEnd),charDiff+=selectionEnd-selectionStart):nextCharCount<charCount&&(removedText=backDelete?this._text.slice(selectionEnd+charDiff,selectionEnd):this._text.slice(selectionStart,selectionStart-charDiff));const insertedText=nextText.slice(textareaSelection.selectionEnd-charDiff,textareaSelection.selectionEnd);if(removedText&&removedText.length&&(insertedText.length&&(copiedStyle=this.getSelectionStyles(selectionStart,selectionStart+1,!1),copiedStyle=insertedText.map((()=>copiedStyle[0]))),selection?(removeFrom=selectionStart,removeTo=selectionEnd):backDelete?(removeFrom=selectionEnd-removedText.length,removeTo=selectionEnd):(removeFrom=selectionEnd,removeTo=selectionEnd+removedText.length),this.removeStyleFromTo(removeFrom,removeTo)),insertedText.length){const{copyPasteData}=getEnv();fromPaste&&insertedText.join("")===copyPasteData.copiedText&&!config.disableStyleCopyPaste&&(copiedStyle=copyPasteData.copiedTextStyle),this.insertNewStyleBlock(insertedText,selectionStart,copiedStyle)}updateAndFire()}onCompositionStart(){this.inCompositionMode=!0}onCompositionEnd(){this.inCompositionMode=!1}onCompositionUpdate(_ref3){let{target}=_ref3;const{selectionStart,selectionEnd}=target;this.compositionStart=selectionStart,this.compositionEnd=selectionEnd,this.updateTextareaPosition()}copy(){if(this.selectionStart===this.selectionEnd)return;const{copyPasteData}=getEnv();copyPasteData.copiedText=this.getSelectedText(),config.disableStyleCopyPaste?copyPasteData.copiedTextStyle=void 0:copyPasteData.copiedTextStyle=this.getSelectionStyles(this.selectionStart,this.selectionEnd,!0),this._copyDone=!0}paste(){this.fromPaste=!0}_getWidthBeforeCursor(lineIndex,charIndex){let bound,widthBeforeCursor=this._getLineLeftOffset(lineIndex);return charIndex>0&&(bound=this.__charBounds[lineIndex][charIndex-1],widthBeforeCursor+=bound.left+bound.width),widthBeforeCursor}getDownCursorOffset(e,isRight){const selectionProp=this._getSelectionForOffset(e,isRight),cursorLocation=this.get2DCursorLocation(selectionProp),lineIndex=cursorLocation.lineIndex;if(lineIndex===this._textLines.length-1||e.metaKey||34===e.keyCode)return this._text.length-selectionProp;const charIndex=cursorLocation.charIndex,widthBeforeCursor=this._getWidthBeforeCursor(lineIndex,charIndex),indexOnOtherLine=this._getIndexOnLine(lineIndex+1,widthBeforeCursor);return this._textLines[lineIndex].slice(charIndex).length+indexOnOtherLine+1+this.missingNewlineOffset(lineIndex)}_getSelectionForOffset(e,isRight){return e.shiftKey&&this.selectionStart!==this.selectionEnd&&isRight?this.selectionEnd:this.selectionStart}getUpCursorOffset(e,isRight){const selectionProp=this._getSelectionForOffset(e,isRight),cursorLocation=this.get2DCursorLocation(selectionProp),lineIndex=cursorLocation.lineIndex;if(0===lineIndex||e.metaKey||33===e.keyCode)return-selectionProp;const charIndex=cursorLocation.charIndex,widthBeforeCursor=this._getWidthBeforeCursor(lineIndex,charIndex),indexOnOtherLine=this._getIndexOnLine(lineIndex-1,widthBeforeCursor),textBeforeCursor=this._textLines[lineIndex].slice(0,charIndex),missingNewlineOffset=this.missingNewlineOffset(lineIndex-1);return-this._textLines[lineIndex-1].length+indexOnOtherLine-textBeforeCursor.length+(1-missingNewlineOffset)}_getIndexOnLine(lineIndex,width){const line=this._textLines[lineIndex];let charWidth,foundMatch,widthOfCharsOnLine=this._getLineLeftOffset(lineIndex),indexOnLine=0;for(let j=0,jlen=line.length;j<jlen;j++)if(charWidth=this.__charBounds[lineIndex][j].width,widthOfCharsOnLine+=charWidth,widthOfCharsOnLine>width){foundMatch=!0;const leftEdge=widthOfCharsOnLine-charWidth,rightEdge=widthOfCharsOnLine,offsetFromLeftEdge=Math.abs(leftEdge-width);indexOnLine=Math.abs(rightEdge-width)<offsetFromLeftEdge?j:j-1;break}return foundMatch||(indexOnLine=line.length-1),indexOnLine}moveCursorDown(e){this.selectionStart>=this._text.length&&this.selectionEnd>=this._text.length||this._moveCursorUpOrDown("Down",e)}moveCursorUp(e){0===this.selectionStart&&0===this.selectionEnd||this._moveCursorUpOrDown("Up",e)}_moveCursorUpOrDown(direction,e){const offset=this["get".concat(direction,"CursorOffset")](e,this._selectionDirection===RIGHT);if(e.shiftKey?this.moveCursorWithShift(offset):this.moveCursorWithoutShift(offset),0!==offset){const max=this.text.length;this.selectionStart=capValue(0,this.selectionStart,max),this.selectionEnd=capValue(0,this.selectionEnd,max),this.abortCursorAnimation(),this._currentCursorOpacity=1,this.initDelayedCursor(),this._fireSelectionChanged(),this._updateTextarea()}}moveCursorWithShift(offset){const newSelection=this._selectionDirection===LEFT?this.selectionStart+offset:this.selectionEnd+offset;return this.setSelectionStartEndWithShift(this.selectionStart,this.selectionEnd,newSelection),0!==offset}moveCursorWithoutShift(offset){return offset<0?(this.selectionStart+=offset,this.selectionEnd=this.selectionStart):(this.selectionEnd+=offset,this.selectionStart=this.selectionEnd),0!==offset}moveCursorLeft(e){0===this.selectionStart&&0===this.selectionEnd||this._moveCursorLeftOrRight("Left",e)}_move(e,prop,direction){let newValue;if(e.altKey)newValue=this["findWordBoundary".concat(direction)](this[prop]);else{if(!e.metaKey&&35!==e.keyCode&&36!==e.keyCode)return this[prop]+="Left"===direction?-1:1,!0;newValue=this["findLineBoundary".concat(direction)](this[prop])}return void 0!==newValue&&this[prop]!==newValue&&(this[prop]=newValue,!0)}_moveLeft(e,prop){return this._move(e,prop,"Left")}_moveRight(e,prop){return this._move(e,prop,"Right")}moveCursorLeftWithoutShift(e){let change=!0;return this._selectionDirection=LEFT,this.selectionEnd===this.selectionStart&&0!==this.selectionStart&&(change=this._moveLeft(e,"selectionStart")),this.selectionEnd=this.selectionStart,change}moveCursorLeftWithShift(e){return this._selectionDirection===RIGHT&&this.selectionStart!==this.selectionEnd?this._moveLeft(e,"selectionEnd"):0!==this.selectionStart?(this._selectionDirection=LEFT,this._moveLeft(e,"selectionStart")):void 0}moveCursorRight(e){this.selectionStart>=this._text.length&&this.selectionEnd>=this._text.length||this._moveCursorLeftOrRight("Right",e)}_moveCursorLeftOrRight(direction,e){const actionName="moveCursor".concat(direction).concat(e.shiftKey?"WithShift":"WithoutShift");this._currentCursorOpacity=1,this[actionName](e)&&(this.abortCursorAnimation(),this.initDelayedCursor(),this._fireSelectionChanged(),this._updateTextarea())}moveCursorRightWithShift(e){return this._selectionDirection===LEFT&&this.selectionStart!==this.selectionEnd?this._moveRight(e,"selectionStart"):this.selectionEnd!==this._text.length?(this._selectionDirection=RIGHT,this._moveRight(e,"selectionEnd")):void 0}moveCursorRightWithoutShift(e){let changed=!0;return this._selectionDirection=RIGHT,this.selectionStart===this.selectionEnd?(changed=this._moveRight(e,"selectionStart"),this.selectionEnd=this.selectionStart):this.selectionStart=this.selectionEnd,changed}}const notALeftClick=e=>!!e.button;class ITextClickBehavior extends ITextKeyBehavior{constructor(){super(...arguments),_defineProperty(this,"draggableTextDelegate",void 0)}initBehavior(){this.on("mousedown",this._mouseDownHandler),this.on("mousedown:before",this._mouseDownHandlerBefore),this.on("mouseup",this.mouseUpHandler),this.on("mousedblclick",this.doubleClickHandler),this.on("tripleclick",this.tripleClickHandler),this.__lastClickTime=+new Date,this.__lastLastClickTime=+new Date,this.__lastPointer={},this.on("mousedown",this.onMouseDown),this.draggableTextDelegate=new DraggableTextDelegate(this),super.initBehavior()}shouldStartDragging(){return this.draggableTextDelegate.isActive()}onDragStart(e){return this.draggableTextDelegate.onDragStart(e)}canDrop(e){return this.draggableTextDelegate.canDrop(e)}onMouseDown(options){if(!this.canvas)return;this.__newClickTime=+new Date;const newPointer=options.pointer;this.isTripleClick(newPointer)&&(this.fire("tripleclick",options),stopEvent(options.e)),this.__lastLastClickTime=this.__lastClickTime,this.__lastClickTime=this.__newClickTime,this.__lastPointer=newPointer,this.__lastSelected=this.selected&&!this.getActiveControl()}isTripleClick(newPointer){return this.__newClickTime-this.__lastClickTime<500&&this.__lastClickTime-this.__lastLastClickTime<500&&this.__lastPointer.x===newPointer.x&&this.__lastPointer.y===newPointer.y}doubleClickHandler(options){this.isEditing&&this.selectWord(this.getSelectionStartFromPointer(options.e))}tripleClickHandler(options){this.isEditing&&this.selectLine(this.getSelectionStartFromPointer(options.e))}_mouseDownHandler(_ref){let{e}=_ref;this.canvas&&this.editable&&!notALeftClick(e)&&!this.getActiveControl()&&(this.draggableTextDelegate.start(e)||(this.canvas.textEditingManager.register(this),this.selected&&(this.inCompositionMode=!1,this.setCursorByClick(e)),this.isEditing&&(this.__selectionStartOnMouseDown=this.selectionStart,this.selectionStart===this.selectionEnd&&this.abortCursorAnimation(),this.renderCursorOrSelection())))}_mouseDownHandlerBefore(_ref2){let{e}=_ref2;this.canvas&&this.editable&&!notALeftClick(e)&&(this.selected=this===this.canvas._activeObject)}mouseUpHandler(_ref3){let{e,transform}=_ref3;const didDrag=this.draggableTextDelegate.end(e);if(this.canvas){this.canvas.textEditingManager.unregister(this);const activeObject=this.canvas._activeObject;if(activeObject&&activeObject!==this)return}!this.editable||this.group&&!this.group.interactive||transform&&transform.actionPerformed||notALeftClick(e)||didDrag||(this.__lastSelected&&!this.getActiveControl()?(this.selected=!1,this.__lastSelected=!1,this.enterEditing(e),this.selectionStart===this.selectionEnd?this.initDelayedCursor(!0):this.renderCursorOrSelection()):this.selected=!0)}setCursorByClick(e){const newSelection=this.getSelectionStartFromPointer(e),start=this.selectionStart,end=this.selectionEnd;e.shiftKey?this.setSelectionStartEndWithShift(start,end,newSelection):(this.selectionStart=newSelection,this.selectionEnd=newSelection),this.isEditing&&(this._fireSelectionChanged(),this._updateTextarea())}getSelectionStartFromPointer(e){const mouseOffset=this.canvas.getScenePoint(e).transform(invertTransform(this.calcTransformMatrix())).add(new Point(-this._getLeftOffset(),-this._getTopOffset()));let height=0,charIndex=0,lineIndex=0;for(let i=0;i<this._textLines.length&&height<=mouseOffset.y;i++)height+=this.getHeightOfLine(i),lineIndex=i,i>0&&(charIndex+=this._textLines[i-1].length+this.missingNewlineOffset(i-1));let width=Math.abs(this._getLineLeftOffset(lineIndex));const charLength=this._textLines[lineIndex].length,chars=this.__charBounds[lineIndex];for(let j=0;j<charLength;j++){const widthAfter=width+chars[j].kernedWidth;if(mouseOffset.x<=widthAfter){Math.abs(mouseOffset.x-widthAfter)<=Math.abs(mouseOffset.x-width)&&charIndex++;break}width=widthAfter,charIndex++}return Math.min(this.flipX?charLength-charIndex:charIndex,this._text.length)}}const iTextDefaultValues={selectionStart:0,selectionEnd:0,selectionColor:"rgba(17,119,255,0.3)",isEditing:!1,editable:!0,editingBorderColor:"rgba(102,153,255,0.25)",cursorWidth:2,cursorColor:"",cursorDelay:1e3,cursorDuration:600,caching:!0,hiddenTextareaContainer:null,_selectionDirection:null,_reSpace:/\s|\r?\n/,inCompositionMode:!1,keysMap:{9:"exitEditing",27:"exitEditing",33:"moveCursorUp",34:"moveCursorDown",35:"moveCursorRight",36:"moveCursorLeft",37:"moveCursorLeft",38:"moveCursorUp",39:"moveCursorRight",40:"moveCursorDown"},keysMapRtl:{9:"exitEditing",27:"exitEditing",33:"moveCursorUp",34:"moveCursorDown",35:"moveCursorLeft",36:"moveCursorRight",37:"moveCursorRight",38:"moveCursorUp",39:"moveCursorLeft",40:"moveCursorDown"},ctrlKeysMapDown:{65:"selectAll"},ctrlKeysMapUp:{67:"copy",88:"cut"}};class IText extends ITextClickBehavior{static getDefaults(){return _objectSpread2(_objectSpread2({},super.getDefaults()),IText.ownDefaults)}get type(){const type=super.type;return"itext"===type?"i-text":type}constructor(text,options){super(text,options),this.initBehavior()}_set(key,value){return this.isEditing&&this._savedProps&&key in this._savedProps?(this._savedProps[key]=value,this):("canvas"===key&&(this.canvas instanceof Canvas&&this.canvas.textEditingManager.remove(this),value instanceof Canvas&&value.textEditingManager.add(this)),super._set(key,value))}setSelectionStart(index){index=Math.max(index,0),this._updateAndFire("selectionStart",index)}setSelectionEnd(index){index=Math.min(index,this.text.length),this._updateAndFire("selectionEnd",index)}_updateAndFire(property,index){this[property]!==index&&(this._fireSelectionChanged(),this[property]=index),this._updateTextarea()}_fireSelectionChanged(){this.fire("selection:changed"),this.canvas&&this.canvas.fire("text:selection:changed",{target:this})}initDimensions(){this.isEditing&&this.initDelayedCursor(),super.initDimensions()}getSelectionStyles(){let startIndex=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.selectionStart||0,endIndex=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selectionEnd,complete=arguments.length>2?arguments[2]:void 0;return super.getSelectionStyles(startIndex,endIndex,complete)}setSelectionStyles(styles){let startIndex=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.selectionStart||0,endIndex=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.selectionEnd;return super.setSelectionStyles(styles,startIndex,endIndex)}get2DCursorLocation(){let selectionStart=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.selectionStart,skipWrapping=arguments.length>1?arguments[1]:void 0;return super.get2DCursorLocation(selectionStart,skipWrapping)}render(ctx){super.render(ctx),this.cursorOffsetCache={},this.renderCursorOrSelection()}toCanvasElement(options){const isEditing=this.isEditing;this.isEditing=!1;const canvas=super.toCanvasElement(options);return this.isEditing=isEditing,canvas}renderCursorOrSelection(){if(!this.isEditing)return;const ctx=this.clearContextTop(!0);if(!ctx)return;const boundaries=this._getCursorBoundaries();this.selectionStart===this.selectionEnd?this.renderCursor(ctx,boundaries):this.renderSelection(ctx,boundaries),this.canvas.contextTopDirty=!0,ctx.restore()}_getCursorBoundaries(){let index=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.selectionStart,skipCaching=arguments.length>1?arguments[1]:void 0;const left=this._getLeftOffset(),top=this._getTopOffset(),offsets=this._getCursorBoundariesOffsets(index,skipCaching);return{left,top,leftOffset:offsets.left,topOffset:offsets.top}}_getCursorBoundariesOffsets(index,skipCaching){return skipCaching?this.__getCursorBoundariesOffsets(index):this.cursorOffsetCache&&"top"in this.cursorOffsetCache?this.cursorOffsetCache:this.cursorOffsetCache=this.__getCursorBoundariesOffsets(index)}__getCursorBoundariesOffsets(index){let topOffset=0,leftOffset=0;const{charIndex,lineIndex}=this.get2DCursorLocation(index);for(let i=0;i<lineIndex;i++)topOffset+=this.getHeightOfLine(i);const lineLeftOffset=this._getLineLeftOffset(lineIndex),bound=this.__charBounds[lineIndex][charIndex];bound&&(leftOffset=bound.left),0!==this.charSpacing&&charIndex===this._textLines[lineIndex].length&&(leftOffset-=this._getWidthOfCharSpacing());const boundaries={top:topOffset,left:lineLeftOffset+(leftOffset>0?leftOffset:0)};return"rtl"===this.direction&&(this.textAlign===RIGHT||this.textAlign===JUSTIFY||"justify-right"===this.textAlign?boundaries.left*=-1:this.textAlign===LEFT||"justify-left"===this.textAlign?boundaries.left=lineLeftOffset-(leftOffset>0?leftOffset:0):this.textAlign!==CENTER&&"justify-center"!==this.textAlign||(boundaries.left=lineLeftOffset-(leftOffset>0?leftOffset:0))),boundaries}renderCursorAt(selectionStart){const boundaries=this._getCursorBoundaries(selectionStart,!0);this._renderCursor(this.canvas.contextTop,boundaries,selectionStart)}renderCursor(ctx,boundaries){this._renderCursor(ctx,boundaries,this.selectionStart)}_renderCursor(ctx,boundaries,selectionStart){const cursorLocation=this.get2DCursorLocation(selectionStart),lineIndex=cursorLocation.lineIndex,charIndex=cursorLocation.charIndex>0?cursorLocation.charIndex-1:0,charHeight=this.getValueOfPropertyAt(lineIndex,charIndex,"fontSize"),multiplier=this.getObjectScaling().x*this.canvas.getZoom(),cursorWidth=this.cursorWidth/multiplier,dy=this.getValueOfPropertyAt(lineIndex,charIndex,"deltaY"),topOffset=boundaries.topOffset+(1-this._fontSizeFraction)*this.getHeightOfLine(lineIndex)/this.lineHeight-charHeight*(1-this._fontSizeFraction);this.inCompositionMode&&this.renderSelection(ctx,boundaries),ctx.fillStyle=this.cursorColor||this.getValueOfPropertyAt(lineIndex,charIndex,"fill"),ctx.globalAlpha=this._currentCursorOpacity,ctx.fillRect(boundaries.left+boundaries.leftOffset-cursorWidth/2,topOffset+boundaries.top+dy,cursorWidth,charHeight)}renderSelection(ctx,boundaries){const selection={selectionStart:this.inCompositionMode?this.hiddenTextarea.selectionStart:this.selectionStart,selectionEnd:this.inCompositionMode?this.hiddenTextarea.selectionEnd:this.selectionEnd};this._renderSelection(ctx,selection,boundaries)}renderDragSourceEffect(){const dragStartSelection=this.draggableTextDelegate.getDragStartSelection();this._renderSelection(this.canvas.contextTop,dragStartSelection,this._getCursorBoundaries(dragStartSelection.selectionStart,!0))}renderDropTargetEffect(e){const dragSelection=this.getSelectionStartFromPointer(e);this.renderCursorAt(dragSelection)}_renderSelection(ctx,selection,boundaries){const selectionStart=selection.selectionStart,selectionEnd=selection.selectionEnd,isJustify=this.textAlign.includes(JUSTIFY),start=this.get2DCursorLocation(selectionStart),end=this.get2DCursorLocation(selectionEnd),startLine=start.lineIndex,endLine=end.lineIndex,startChar=start.charIndex<0?0:start.charIndex,endChar=end.charIndex<0?0:end.charIndex;for(let i=startLine;i<=endLine;i++){const lineOffset=this._getLineLeftOffset(i)||0;let lineHeight=this.getHeightOfLine(i),realLineHeight=0,boxStart=0,boxEnd=0;if(i===startLine&&(boxStart=this.__charBounds[startLine][startChar].left),i>=startLine&&i<endLine)boxEnd=isJustify&&!this.isEndOfWrapping(i)?this.width:this.getLineWidth(i)||5;else if(i===endLine)if(0===endChar)boxEnd=this.__charBounds[endLine][endChar].left;else{const charSpacing=this._getWidthOfCharSpacing();boxEnd=this.__charBounds[endLine][endChar-1].left+this.__charBounds[endLine][endChar-1].width-charSpacing}realLineHeight=lineHeight,(this.lineHeight<1||i===endLine&&this.lineHeight>1)&&(lineHeight/=this.lineHeight);let drawStart=boundaries.left+lineOffset+boxStart,drawHeight=lineHeight,extraTop=0;const drawWidth=boxEnd-boxStart;this.inCompositionMode?(ctx.fillStyle=this.compositionColor||"black",drawHeight=1,extraTop=lineHeight):ctx.fillStyle=this.selectionColor,"rtl"===this.direction&&(this.textAlign===RIGHT||this.textAlign===JUSTIFY||"justify-right"===this.textAlign?drawStart=this.width-drawStart-drawWidth:this.textAlign===LEFT||"justify-left"===this.textAlign?drawStart=boundaries.left+lineOffset-boxEnd:this.textAlign!==CENTER&&"justify-center"!==this.textAlign||(drawStart=boundaries.left+lineOffset-boxEnd)),ctx.fillRect(drawStart,boundaries.top+boundaries.topOffset+extraTop,drawWidth,drawHeight),boundaries.topOffset+=realLineHeight}}getCurrentCharFontSize(){const cp=this._getCurrentCharIndex();return this.getValueOfPropertyAt(cp.l,cp.c,"fontSize")}getCurrentCharColor(){const cp=this._getCurrentCharIndex();return this.getValueOfPropertyAt(cp.l,cp.c,"fill")}_getCurrentCharIndex(){const cursorPosition=this.get2DCursorLocation(this.selectionStart,!0),charIndex=cursorPosition.charIndex>0?cursorPosition.charIndex-1:0;return{l:cursorPosition.lineIndex,c:charIndex}}dispose(){this._exitEditing(),this.draggableTextDelegate.dispose(),super.dispose()}}_defineProperty(IText,"ownDefaults",iTextDefaultValues),_defineProperty(IText,"type","IText"),classRegistry.setClass(IText),classRegistry.setClass(IText,"i-text");class Textbox extends IText{static getDefaults(){return _objectSpread2(_objectSpread2({},super.getDefaults()),{},{controls:createTextboxDefaultControls()},Textbox.ownDefaults)}initDimensions(){this.initialized&&(this.isEditing&&this.initDelayedCursor(),this._clearCache(),this.dynamicMinWidth=0,this._styleMap=this._generateStyleMap(this._splitText()),this.dynamicMinWidth>this.width&&this._set("width",this.dynamicMinWidth),this.textAlign.includes(JUSTIFY)&&this.enlargeSpaces(),this.height=this.calcTextHeight())}_generateStyleMap(textInfo){let realLineCount=0,realLineCharCount=0,charCount=0;const map={};for(let i=0;i<textInfo.graphemeLines.length;i++)"\n"===textInfo.graphemeText[charCount]&&i>0?(realLineCharCount=0,charCount++,realLineCount++):!this.splitByGrapheme&&this._reSpaceAndTab.test(textInfo.graphemeText[charCount])&&i>0&&(realLineCharCount++,charCount++),map[i]={line:realLineCount,offset:realLineCharCount},charCount+=textInfo.graphemeLines[i].length,realLineCharCount+=textInfo.graphemeLines[i].length;return map}styleHas(property,lineIndex){if(this._styleMap&&!this.isWrapping){const map=this._styleMap[lineIndex];map&&(lineIndex=map.line)}return super.styleHas(property,lineIndex)}isEmptyStyles(lineIndex){if(!this.styles)return!0;let nextOffset,offset=0,nextLineIndex=lineIndex+1,shouldLimit=!1;const map=this._styleMap[lineIndex],mapNextLine=this._styleMap[lineIndex+1];map&&(lineIndex=map.line,offset=map.offset),mapNextLine&&(nextLineIndex=mapNextLine.line,shouldLimit=nextLineIndex===lineIndex,nextOffset=mapNextLine.offset);const obj=void 0===lineIndex?this.styles:{line:this.styles[lineIndex]};for(const p1 in obj)for(const p2 in obj[p1]){const p2Number=parseInt(p2,10);if(p2Number>=offset&&(!shouldLimit||p2Number<nextOffset))for(const p3 in obj[p1][p2])return!1}return!0}_getStyleDeclaration(lineIndex,charIndex){if(this._styleMap&&!this.isWrapping){const map=this._styleMap[lineIndex];if(!map)return{};lineIndex=map.line,charIndex=map.offset+charIndex}return super._getStyleDeclaration(lineIndex,charIndex)}_setStyleDeclaration(lineIndex,charIndex,style){const map=this._styleMap[lineIndex];super._setStyleDeclaration(map.line,map.offset+charIndex,style)}_deleteStyleDeclaration(lineIndex,charIndex){const map=this._styleMap[lineIndex];super._deleteStyleDeclaration(map.line,map.offset+charIndex)}_getLineStyle(lineIndex){const map=this._styleMap[lineIndex];return!!this.styles[map.line]}_setLineStyle(lineIndex){const map=this._styleMap[lineIndex];super._setLineStyle(map.line)}_wrapText(lines,desiredWidth){this.isWrapping=!0;const data=this.getGraphemeDataForRender(lines),wrapped=[];for(let i=0;i<data.wordsData.length;i++)wrapped.push(...this._wrapLine(i,desiredWidth,data));return this.isWrapping=!1,wrapped}getGraphemeDataForRender(lines){const splitByGrapheme=this.splitByGrapheme,infix=splitByGrapheme?"":" ";let largestWordWidth=0;return{wordsData:lines.map(((line,lineIndex)=>{let offset=0;const wordsOrGraphemes=splitByGrapheme?this.graphemeSplit(line):this.wordSplit(line);return 0===wordsOrGraphemes.length?[{word:[],width:0}]:wordsOrGraphemes.map((word=>{const graphemeArray=splitByGrapheme?[word]:this.graphemeSplit(word),width=this._measureWord(graphemeArray,lineIndex,offset);return largestWordWidth=Math.max(width,largestWordWidth),offset+=graphemeArray.length+infix.length,{word:graphemeArray,width}}))})),largestWordWidth}}_measureWord(word,lineIndex){let prevGrapheme,charOffset=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,width=0;for(let i=0,len=word.length;i<len;i++){width+=this._getGraphemeBox(word[i],lineIndex,i+charOffset,prevGrapheme,true).kernedWidth,prevGrapheme=word[i]}return width}wordSplit(value){return value.split(this._wordJoiners)}_wrapLine(lineIndex,desiredWidth,_ref){let{largestWordWidth,wordsData}=_ref,reservedSpace=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const additionalSpace=this._getWidthOfCharSpacing(),splitByGrapheme=this.splitByGrapheme,graphemeLines=[],infix=splitByGrapheme?"":" ";let lineWidth=0,line=[],offset=0,infixWidth=0,lineJustStarted=!0;desiredWidth-=reservedSpace;const maxWidth=Math.max(desiredWidth,largestWordWidth,this.dynamicMinWidth),data=wordsData[lineIndex];let i;for(offset=0,i=0;i<data.length;i++){const{word,width:wordWidth}=data[i];offset+=word.length,lineWidth+=infixWidth+wordWidth-additionalSpace,lineWidth>maxWidth&&!lineJustStarted?(graphemeLines.push(line),line=[],lineWidth=wordWidth,lineJustStarted=!0):lineWidth+=additionalSpace,lineJustStarted||splitByGrapheme||line.push(infix),line=line.concat(word),infixWidth=splitByGrapheme?0:this._measureWord([infix],lineIndex,offset),offset++,lineJustStarted=!1}return i&&graphemeLines.push(line),largestWordWidth+reservedSpace>this.dynamicMinWidth&&(this.dynamicMinWidth=largestWordWidth-additionalSpace+reservedSpace),graphemeLines}isEndOfWrapping(lineIndex){return!this._styleMap[lineIndex+1]||this._styleMap[lineIndex+1].line!==this._styleMap[lineIndex].line}missingNewlineOffset(lineIndex,skipWrapping){return this.splitByGrapheme&&!skipWrapping?this.isEndOfWrapping(lineIndex)?1:0:1}_splitTextIntoLines(text){const newText=super._splitTextIntoLines(text),graphemeLines=this._wrapText(newText.lines,this.width),lines=new Array(graphemeLines.length);for(let i=0;i<graphemeLines.length;i++)lines[i]=graphemeLines[i].join("");return newText.lines=lines,newText.graphemeLines=graphemeLines,newText}getMinWidth(){return Math.max(this.minWidth,this.dynamicMinWidth)}_removeExtraneousStyles(){const linesToKeep=new Map;for(const prop in this._styleMap){const propNumber=parseInt(prop,10);if(this._textLines[propNumber]){const lineIndex=this._styleMap[prop].line;linesToKeep.set("".concat(lineIndex),!0)}}for(const prop in this.styles)linesToKeep.has(prop)||delete this.styles[prop]}toObject(){let propertiesToInclude=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return super.toObject(["minWidth","splitByGrapheme",...propertiesToInclude])}}_defineProperty(Textbox,"type","Textbox"),_defineProperty(Textbox,"textLayoutProperties",[...IText.textLayoutProperties,"width"]),_defineProperty(Textbox,"ownDefaults",{minWidth:20,dynamicMinWidth:2,lockScalingFlip:!0,noScaleCache:!1,_wordJoiners:/[ \t\r]/,splitByGrapheme:!1}),classRegistry.setClass(Textbox);class ClipPathLayout extends LayoutStrategy{shouldPerformLayout(context){return!!context.target.clipPath&&super.shouldPerformLayout(context)}shouldLayoutClipPath(){return!1}calcLayoutResult(context,objects){const{target}=context,{clipPath}=target;if(!clipPath||!this.shouldPerformLayout(context))return;const{width,height}=makeBoundingBoxFromPoints(getObjectBounds(target,clipPath)),size=new Point(width,height);if(clipPath.absolutePositioned){var _target$group;return{center:sendPointToPlane(clipPath.getRelativeCenterPoint(),void 0,null===(_target$group=target.group)||void 0===_target$group?void 0:_target$group.calcTransformMatrix()),size}}{const clipPathCenter=clipPath.getRelativeCenterPoint().transform(target.calcOwnMatrix(),!0);if(this.shouldPerformLayout(context)){const{center=new Point,correction=new Point}=this.calcBoundingBox(objects,context)||{};return{center:center.add(clipPathCenter),correction:correction.subtract(clipPathCenter),size}}return{center:target.getRelativeCenterPoint().add(clipPathCenter),size}}}}_defineProperty(ClipPathLayout,"type","clip-path"),classRegistry.setClass(ClipPathLayout);class FixedLayout extends LayoutStrategy{getInitialSize(_ref,_ref2){let{target}=_ref,{size}=_ref2;return new Point(target.width||size.x,target.height||size.y)}}_defineProperty(FixedLayout,"type","fixed"),classRegistry.setClass(FixedLayout);class ActiveSelection extends Group{static getDefaults(){return _objectSpread2(_objectSpread2({},super.getDefaults()),this.ownDefaults)}_shouldSetNestedCoords(){return!0}__objectSelectionMonitor(){}multiSelectAdd(){for(var _len=arguments.length,targets=new Array(_len),_key=0;_key<_len;_key++)targets[_key]=arguments[_key];"selection-order"===this.multiSelectionStacking?this.add(...targets):targets.forEach((target=>{const index=this._objects.findIndex((obj=>obj.isInFrontOf(target))),insertAt=-1===index?this.size():index;this.insertAt(insertAt,target)}))}enterGroup(object,removeParentTransform){object.parent&&object.parent===object.group?object.parent._exitGroup(object):object.group&&object.parent!==object.group&&object.group.remove(object),this._enterGroup(object,removeParentTransform)}exitGroup(object,removeParentTransform){this._exitGroup(object,removeParentTransform),object.parent&&object.parent._enterGroup(object,!0)}_onAfterObjectsChange(type,targets){super._onAfterObjectsChange(type,targets);const groups=new Set;targets.forEach((object=>{const{parent}=object;parent&&groups.add(parent)})),"removed"===type?groups.forEach((group=>{group._onAfterObjectsChange("added",targets)})):groups.forEach((group=>{group._set("dirty",!0)}))}onDeselect(){return this.removeAll(),!1}toString(){return"#<ActiveSelection: (".concat(this.complexity(),")>")}shouldCache(){return!1}isOnACache(){return!1}_renderControls(ctx,styleOverride,childrenOverride){ctx.save(),ctx.globalAlpha=this.isMoving?this.borderOpacityWhenMoving:1,super._renderControls(ctx,styleOverride);const options=_objectSpread2(_objectSpread2({hasControls:!1},childrenOverride),{},{forActiveSelection:!0});for(let i=0;i<this._objects.length;i++)this._objects[i]._renderControls(ctx,options);ctx.restore()}}_defineProperty(ActiveSelection,"type","ActiveSelection"),_defineProperty(ActiveSelection,"ownDefaults",{multiSelectionStacking:"canvas-stacking"}),classRegistry.setClass(ActiveSelection),classRegistry.setClass(ActiveSelection,"activeSelection");class Canvas2dFilterBackend{constructor(){_defineProperty(this,"resources",{})}applyFilters(filters,sourceElement,sourceWidth,sourceHeight,targetCanvas){const ctx=targetCanvas.getContext("2d");if(!ctx)return;ctx.drawImage(sourceElement,0,0,sourceWidth,sourceHeight);const pipelineState={sourceWidth,sourceHeight,imageData:ctx.getImageData(0,0,sourceWidth,sourceHeight),originalEl:sourceElement,originalImageData:ctx.getImageData(0,0,sourceWidth,sourceHeight),canvasEl:targetCanvas,ctx,filterBackend:this};filters.forEach((filter=>{filter.applyTo(pipelineState)}));const{imageData:imageDataPostFilter}=pipelineState;return imageDataPostFilter.width===sourceWidth&&imageDataPostFilter.height===sourceHeight||(targetCanvas.width=imageDataPostFilter.width,targetCanvas.height=imageDataPostFilter.height),ctx.putImageData(imageDataPostFilter,0,0),pipelineState}}class WebGLFilterBackend{constructor(){let{tileSize=config.textureSize}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};_defineProperty(this,"aPosition",new Float32Array([0,0,0,1,1,0,1,1])),_defineProperty(this,"resources",{}),this.tileSize=tileSize,this.setupGLContext(tileSize,tileSize),this.captureGPUInfo()}setupGLContext(width,height){this.dispose(),this.createWebGLCanvas(width,height)}createWebGLCanvas(width,height){const canvas=createCanvasElement();canvas.width=width,canvas.height=height;const gl=canvas.getContext("webgl",{alpha:!0,premultipliedAlpha:!1,depth:!1,stencil:!1,antialias:!1});gl&&(gl.clearColor(0,0,0,0),this.canvas=canvas,this.gl=gl)}applyFilters(filters,source,width,height,targetCanvas,cacheKey){const gl=this.gl,ctx=targetCanvas.getContext("2d");if(!gl||!ctx)return;let cachedTexture;cacheKey&&(cachedTexture=this.getCachedTexture(cacheKey,source));const pipelineState={originalWidth:source.width||source.originalWidth||0,originalHeight:source.height||source.originalHeight||0,sourceWidth:width,sourceHeight:height,destinationWidth:width,destinationHeight:height,context:gl,sourceTexture:this.createTexture(gl,width,height,cachedTexture?void 0:source),targetTexture:this.createTexture(gl,width,height),originalTexture:cachedTexture||this.createTexture(gl,width,height,cachedTexture?void 0:source),passes:filters.length,webgl:!0,aPosition:this.aPosition,programCache:this.programCache,pass:0,filterBackend:this,targetCanvas},tempFbo=gl.createFramebuffer();return gl.bindFramebuffer(gl.FRAMEBUFFER,tempFbo),filters.forEach((filter=>{filter&&filter.applyTo(pipelineState)})),function resizeCanvasIfNeeded(pipelineState){const targetCanvas=pipelineState.targetCanvas,width=targetCanvas.width,height=targetCanvas.height,dWidth=pipelineState.destinationWidth,dHeight=pipelineState.destinationHeight;width===dWidth&&height===dHeight||(targetCanvas.width=dWidth,targetCanvas.height=dHeight)}(pipelineState),this.copyGLTo2D(gl,pipelineState),gl.bindTexture(gl.TEXTURE_2D,null),gl.deleteTexture(pipelineState.sourceTexture),gl.deleteTexture(pipelineState.targetTexture),gl.deleteFramebuffer(tempFbo),ctx.setTransform(1,0,0,1,0,0),pipelineState}dispose(){this.canvas&&(this.canvas=null,this.gl=null),this.clearWebGLCaches()}clearWebGLCaches(){this.programCache={},this.textureCache={}}createTexture(gl,width,height,textureImageSource,filter){const{NEAREST,TEXTURE_2D,RGBA,UNSIGNED_BYTE,CLAMP_TO_EDGE,TEXTURE_MAG_FILTER,TEXTURE_MIN_FILTER,TEXTURE_WRAP_S,TEXTURE_WRAP_T}=gl,texture=gl.createTexture();return gl.bindTexture(TEXTURE_2D,texture),gl.texParameteri(TEXTURE_2D,TEXTURE_MAG_FILTER,filter||NEAREST),gl.texParameteri(TEXTURE_2D,TEXTURE_MIN_FILTER,filter||NEAREST),gl.texParameteri(TEXTURE_2D,TEXTURE_WRAP_S,CLAMP_TO_EDGE),gl.texParameteri(TEXTURE_2D,TEXTURE_WRAP_T,CLAMP_TO_EDGE),textureImageSource?gl.texImage2D(TEXTURE_2D,0,RGBA,RGBA,UNSIGNED_BYTE,textureImageSource):gl.texImage2D(TEXTURE_2D,0,RGBA,width,height,0,RGBA,UNSIGNED_BYTE,null),texture}getCachedTexture(uniqueId,textureImageSource,filter){const{textureCache}=this;if(textureCache[uniqueId])return textureCache[uniqueId];{const texture=this.createTexture(this.gl,textureImageSource.width,textureImageSource.height,textureImageSource,filter);return texture&&(textureCache[uniqueId]=texture),texture}}evictCachesForKey(cacheKey){this.textureCache[cacheKey]&&(this.gl.deleteTexture(this.textureCache[cacheKey]),delete this.textureCache[cacheKey])}copyGLTo2D(gl,pipelineState){const glCanvas=gl.canvas,targetCanvas=pipelineState.targetCanvas,ctx=targetCanvas.getContext("2d");if(!ctx)return;ctx.translate(0,targetCanvas.height),ctx.scale(1,-1);const sourceY=glCanvas.height-targetCanvas.height;ctx.drawImage(glCanvas,0,sourceY,targetCanvas.width,targetCanvas.height,0,0,targetCanvas.width,targetCanvas.height)}copyGLTo2DPutImageData(gl,pipelineState){const ctx=pipelineState.targetCanvas.getContext("2d"),dWidth=pipelineState.destinationWidth,dHeight=pipelineState.destinationHeight,numBytes=dWidth*dHeight*4;if(!ctx)return;const u8=new Uint8Array(this.imageBuffer,0,numBytes),u8Clamped=new Uint8ClampedArray(this.imageBuffer,0,numBytes);gl.readPixels(0,0,dWidth,dHeight,gl.RGBA,gl.UNSIGNED_BYTE,u8);const imgData=new ImageData(u8Clamped,dWidth,dHeight);ctx.putImageData(imgData,0,0)}captureGPUInfo(){if(this.gpuInfo)return this.gpuInfo;const gl=this.gl,gpuInfo={renderer:"",vendor:""};if(!gl)return gpuInfo;const ext=gl.getExtension("WEBGL_debug_renderer_info");if(ext){const renderer=gl.getParameter(ext.UNMASKED_RENDERER_WEBGL),vendor=gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);renderer&&(gpuInfo.renderer=renderer.toLowerCase()),vendor&&(gpuInfo.vendor=vendor.toLowerCase())}return this.gpuInfo=gpuInfo,gpuInfo}}let filterBackend;function getFilterBackend(){return!filterBackend&&(!(arguments.length>0&&void 0!==arguments[0])||arguments[0])&&(filterBackend=function initFilterBackend(){const{WebGLProbe}=getEnv();return WebGLProbe.queryWebGL(createCanvasElement()),config.enableGLFiltering&&WebGLProbe.isSupported(config.textureSize)?new WebGLFilterBackend({tileSize:config.textureSize}):new Canvas2dFilterBackend}()),filterBackend}const _excluded$5=["filters","resizeFilter","src","crossOrigin","type"],IMAGE_PROPS=["cropX","cropY"];class FabricImage extends FabricObject{static getDefaults(){return _objectSpread2(_objectSpread2({},super.getDefaults()),FabricImage.ownDefaults)}constructor(arg0){let options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(_objectSpread2({filters:[]},options)),_defineProperty(this,"_lastScaleX",1),_defineProperty(this,"_lastScaleY",1),_defineProperty(this,"_filterScalingX",1),_defineProperty(this,"_filterScalingY",1),this.cacheKey="texture".concat(uid()),this.setElement("string"==typeof arg0?(this.canvas&&getDocumentFromElement(this.canvas.getElement())||getFabricDocument()).getElementById(arg0):arg0,options)}getElement(){return this._element}setElement(element){let size=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.removeTexture(this.cacheKey),this.removeTexture("".concat(this.cacheKey,"_filtered")),this._element=element,this._originalElement=element,this._setWidthHeight(size),element.classList.add(FabricImage.CSS_CANVAS),0!==this.filters.length&&this.applyFilters(),this.resizeFilter&&this.applyResizeFilters()}removeTexture(key){const backend=getFilterBackend(!1);backend instanceof WebGLFilterBackend&&backend.evictCachesForKey(key)}dispose(){super.dispose(),this.removeTexture(this.cacheKey),this.removeTexture("".concat(this.cacheKey,"_filtered")),this._cacheContext=null,["_originalElement","_element","_filteredEl","_cacheCanvas"].forEach((elementKey=>{const el=this[elementKey];el&&getEnv().dispose(el),this[elementKey]=void 0}))}getCrossOrigin(){return this._originalElement&&(this._originalElement.crossOrigin||null)}getOriginalSize(){const element=this.getElement();return element?{width:element.naturalWidth||element.width,height:element.naturalHeight||element.height}:{width:0,height:0}}_stroke(ctx){if(!this.stroke||0===this.strokeWidth)return;const w=this.width/2,h=this.height/2;ctx.beginPath(),ctx.moveTo(-w,-h),ctx.lineTo(w,-h),ctx.lineTo(w,h),ctx.lineTo(-w,h),ctx.lineTo(-w,-h),ctx.closePath()}toObject(){let propertiesToInclude=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];const filters=[];return this.filters.forEach((filterObj=>{filterObj&&filters.push(filterObj.toObject())})),_objectSpread2(_objectSpread2({},super.toObject([...IMAGE_PROPS,...propertiesToInclude])),{},{src:this.getSrc(),crossOrigin:this.getCrossOrigin(),filters},this.resizeFilter?{resizeFilter:this.resizeFilter.toObject()}:{})}hasCrop(){return!!this.cropX||!!this.cropY||this.width<this._element.width||this.height<this._element.height}_toSVG(){const imageMarkup=[],element=this._element,x=-this.width/2,y=-this.height/2;let svgString=[],strokeSvg=[],clipPath="",imageRendering="";if(!element)return[];if(this.hasCrop()){const clipPathId=uid();svgString.push('<clipPath id="imageCrop_'+clipPathId+'">\n','\t<rect x="'+x+'" y="'+y+'" width="'+this.width+'" height="'+this.height+'" />\n',"</clipPath>\n"),clipPath=' clip-path="url(#imageCrop_'+clipPathId+')" '}if(this.imageSmoothing||(imageRendering=' image-rendering="optimizeSpeed"'),imageMarkup.push("\t<image ","COMMON_PARTS",'xlink:href="'.concat(this.getSvgSrc(!0),'" x="').concat(x-this.cropX,'" y="').concat(y-this.cropY,'" width="').concat(element.width||element.naturalWidth,'" height="').concat(element.height||element.naturalHeight,'"').concat(imageRendering).concat(clipPath,"></image>\n")),this.stroke||this.strokeDashArray){const origFill=this.fill;this.fill=null,strokeSvg=['\t<rect x="'.concat(x,'" y="').concat(y,'" width="').concat(this.width,'" height="').concat(this.height,'" styles="').concat(this.getSvgStyles(),'" />\n')],this.fill=origFill}return svgString="fill"!==this.paintFirst?svgString.concat(strokeSvg,imageMarkup):svgString.concat(imageMarkup,strokeSvg),svgString}getSrc(filtered){const element=filtered?this._element:this._originalElement;return element?element.toDataURL?element.toDataURL():this.srcFromAttribute?element.getAttribute("src")||"":element.src:this.src||""}getSvgSrc(filtered){return this.getSrc(filtered)}setSrc(src){let{crossOrigin,signal}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return loadImage(src,{crossOrigin,signal}).then((img=>{void 0!==crossOrigin&&this.set({crossOrigin}),this.setElement(img)}))}toString(){return'#<Image: { src: "'.concat(this.getSrc(),'" }>')}applyResizeFilters(){const filter=this.resizeFilter,minimumScale=this.minimumScaleTrigger,objectScale=this.getTotalObjectScaling(),scaleX=objectScale.x,scaleY=objectScale.y,elementToFilter=this._filteredEl||this._originalElement;if(this.group&&this.set("dirty",!0),!filter||scaleX>minimumScale&&scaleY>minimumScale)return this._element=elementToFilter,this._filterScalingX=1,this._filterScalingY=1,this._lastScaleX=scaleX,void(this._lastScaleY=scaleY);const canvasEl=createCanvasElement(),sourceWidth=elementToFilter.width,sourceHeight=elementToFilter.height;canvasEl.width=sourceWidth,canvasEl.height=sourceHeight,this._element=canvasEl,this._lastScaleX=filter.scaleX=scaleX,this._lastScaleY=filter.scaleY=scaleY,getFilterBackend().applyFilters([filter],elementToFilter,sourceWidth,sourceHeight,this._element),this._filterScalingX=canvasEl.width/this._originalElement.width,this._filterScalingY=canvasEl.height/this._originalElement.height}applyFilters(){let filters=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.filters||[];if(filters=filters.filter((filter=>filter&&!filter.isNeutralState())),this.set("dirty",!0),this.removeTexture("".concat(this.cacheKey,"_filtered")),0===filters.length)return this._element=this._originalElement,this._filteredEl=void 0,this._filterScalingX=1,void(this._filterScalingY=1);const imgElement=this._originalElement,sourceWidth=imgElement.naturalWidth||imgElement.width,sourceHeight=imgElement.naturalHeight||imgElement.height;if(this._element===this._originalElement){const canvasEl=createCanvasElement();canvasEl.width=sourceWidth,canvasEl.height=sourceHeight,this._element=canvasEl,this._filteredEl=canvasEl}else this._filteredEl&&(this._element=this._filteredEl,this._filteredEl.getContext("2d").clearRect(0,0,sourceWidth,sourceHeight),this._lastScaleX=1,this._lastScaleY=1);getFilterBackend().applyFilters(filters,this._originalElement,sourceWidth,sourceHeight,this._element),this._originalElement.width===this._element.width&&this._originalElement.height===this._element.height||(this._filterScalingX=this._element.width/this._originalElement.width,this._filterScalingY=this._element.height/this._originalElement.height)}_render(ctx){ctx.imageSmoothingEnabled=this.imageSmoothing,!0!==this.isMoving&&this.resizeFilter&&this._needsResize()&&this.applyResizeFilters(),this._stroke(ctx),this._renderPaintInOrder(ctx)}drawCacheOnCanvas(ctx){ctx.imageSmoothingEnabled=this.imageSmoothing,super.drawCacheOnCanvas(ctx)}shouldCache(){return this.needsItsOwnCache()}_renderFill(ctx){const elementToDraw=this._element;if(!elementToDraw)return;const scaleX=this._filterScalingX,scaleY=this._filterScalingY,w=this.width,h=this.height,cropX=Math.max(this.cropX,0),cropY=Math.max(this.cropY,0),elWidth=elementToDraw.naturalWidth||elementToDraw.width,elHeight=elementToDraw.naturalHeight||elementToDraw.height,sX=cropX*scaleX,sY=cropY*scaleY,sW=Math.min(w*scaleX,elWidth-sX),sH=Math.min(h*scaleY,elHeight-sY),x=-w/2,y=-h/2,maxDestW=Math.min(w,elWidth/scaleX-cropX),maxDestH=Math.min(h,elHeight/scaleY-cropY);elementToDraw&&ctx.drawImage(elementToDraw,sX,sY,sW,sH,x,y,maxDestW,maxDestH)}_needsResize(){const scale=this.getTotalObjectScaling();return scale.x!==this._lastScaleX||scale.y!==this._lastScaleY}_resetWidthHeight(){this.set(this.getOriginalSize())}_setWidthHeight(){let{width,height}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const size=this.getOriginalSize();this.width=width||size.width,this.height=height||size.height}parsePreserveAspectRatioAttribute(){const pAR=parsePreserveAspectRatioAttribute(this.preserveAspectRatio||""),pWidth=this.width,pHeight=this.height,parsedAttributes={width:pWidth,height:pHeight};let offset,rWidth=this._element.width,rHeight=this._element.height,scaleX=1,scaleY=1,offsetLeft=0,offsetTop=0,cropX=0,cropY=0;return!pAR||pAR.alignX===NONE&&pAR.alignY===NONE?(scaleX=pWidth/rWidth,scaleY=pHeight/rHeight):("meet"===pAR.meetOrSlice&&(scaleX=scaleY=findScaleToFit(this._element,parsedAttributes),offset=(pWidth-rWidth*scaleX)/2,"Min"===pAR.alignX&&(offsetLeft=-offset),"Max"===pAR.alignX&&(offsetLeft=offset),offset=(pHeight-rHeight*scaleY)/2,"Min"===pAR.alignY&&(offsetTop=-offset),"Max"===pAR.alignY&&(offsetTop=offset)),"slice"===pAR.meetOrSlice&&(scaleX=scaleY=findScaleToCover(this._element,parsedAttributes),offset=rWidth-pWidth/scaleX,"Mid"===pAR.alignX&&(cropX=offset/2),"Max"===pAR.alignX&&(cropX=offset),offset=rHeight-pHeight/scaleY,"Mid"===pAR.alignY&&(cropY=offset/2),"Max"===pAR.alignY&&(cropY=offset),rWidth=pWidth/scaleX,rHeight=pHeight/scaleY)),{width:rWidth,height:rHeight,scaleX,scaleY,offsetLeft,offsetTop,cropX,cropY}}static fromObject(_ref){let{filters:f,resizeFilter:rf,src,crossOrigin,type}=_ref,object=_objectWithoutProperties(_ref,_excluded$5),options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Promise.all([loadImage(src,_objectSpread2(_objectSpread2({},options),{},{crossOrigin})),f&&enlivenObjects(f,options),rf&&enlivenObjects([rf],options),enlivenObjectEnlivables(object,options)]).then((_ref2=>{let[el,filters=[],[resizeFilter]=[],hydratedProps={}]=_ref2;return new this(el,_objectSpread2(_objectSpread2({},object),{},{src,filters,resizeFilter},hydratedProps))}))}static fromURL(url){let{crossOrigin=null,signal}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},imageOptions=arguments.length>2?arguments[2]:void 0;return loadImage(url,{crossOrigin,signal}).then((img=>new this(img,imageOptions)))}static async fromElement(element){let options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},cssRules=arguments.length>2?arguments[2]:void 0;const parsedAttributes=parseAttributes(element,this.ATTRIBUTE_NAMES,cssRules);return this.fromURL(parsedAttributes["xlink:href"],options,parsedAttributes).catch((err=>(log("log","Unable to parse Image",err),null)))}}_defineProperty(FabricImage,"type","Image"),_defineProperty(FabricImage,"cacheProperties",[...cacheProperties,...IMAGE_PROPS]),_defineProperty(FabricImage,"ownDefaults",{strokeWidth:0,srcFromAttribute:!1,minimumScaleTrigger:.5,cropX:0,cropY:0,imageSmoothing:!0}),_defineProperty(FabricImage,"CSS_CANVAS","canvas-img"),_defineProperty(FabricImage,"ATTRIBUTE_NAMES",[...SHARED_ATTRIBUTES,"x","y","width","height","preserveAspectRatio","xlink:href","crossOrigin","image-rendering"]),classRegistry.setClass(FabricImage),classRegistry.setSVGClass(FabricImage);getSvgRegex(["pattern","defs","symbol","metadata","clipPath","mask","desc"]);const createPolyPositionHandler=pointIndex=>function(dim,finalMatrix,polyObject){const{points,pathOffset}=polyObject;return new Point(points[pointIndex]).subtract(pathOffset).transform(multiplyTransformMatrices(polyObject.getViewportTransform(),polyObject.calcTransformMatrix()))},polyActionHandler=(eventData,transform,x,y)=>{const{target,pointIndex}=transform,poly=target,mouseLocalPosition=sendPointToPlane(new Point(x,y),void 0,poly.calcOwnMatrix());return poly.points[pointIndex]=mouseLocalPosition.add(poly.pathOffset),poly.setDimensions(),!0},factoryPolyActionHandler=(pointIndex,fn)=>function(eventData,transform,x,y){const poly=transform.target,anchorPoint=new Point(poly.points[(pointIndex>0?pointIndex:poly.points.length)-1]),anchorPointInParentPlane=anchorPoint.subtract(poly.pathOffset).transform(poly.calcOwnMatrix()),actionPerformed=fn(eventData,_objectSpread2(_objectSpread2({},transform),{},{pointIndex}),x,y),diff=anchorPoint.subtract(poly.pathOffset).transform(poly.calcOwnMatrix()).subtract(anchorPointInParentPlane);return poly.left-=diff.x,poly.top-=diff.y,actionPerformed},createPolyActionHandler=pointIndex=>wrapWithFireEvent("modifyPoly",factoryPolyActionHandler(pointIndex,polyActionHandler));var index=Object.freeze({__proto__:null,changeWidth,createObjectDefaultControls,createPolyActionHandler,createPolyControls:function createPolyControls(arg0){let options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const controls={};for(let idx=0;idx<("number"==typeof arg0?arg0:arg0.points.length);idx++)controls["p".concat(idx)]=new Control(_objectSpread2({actionName:"modifyPoly",positionHandler:createPolyPositionHandler(idx),actionHandler:createPolyActionHandler(idx)},options));return controls},createPolyPositionHandler,createResizeControls,createTextboxDefaultControls,dragHandler,factoryPolyActionHandler,getLocalPoint,polyActionHandler,renderCircleControl,renderSquareControl,rotationStyleHandler,rotationWithSnapping,scaleCursorStyleHandler,scaleOrSkewActionName,scaleSkewCursorStyleHandler,scalingEqually,scalingX,scalingXOrSkewingY,scalingY,scalingYOrSkewingX,skewCursorStyleHandler,skewHandlerX,skewHandlerY,wrapWithFireEvent,wrapWithFixedAnchor});const isWebGLPipelineState=options=>void 0!==options.webgl,identityFragmentShader="\n    ".concat("precision highp float",";\n    varying vec2 vTexCoord;\n    uniform sampler2D uTexture;\n    void main() {\n      gl_FragColor = texture2D(uTexture, vTexCoord);\n    }"),_excluded$4=["type"],_excluded2=["type"];class BaseFilter{get type(){return this.constructor.type}constructor(){let options=_objectWithoutProperties(arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},_excluded$4);_defineProperty(this,"vertexSource","\n    attribute vec2 aPosition;\n    varying vec2 vTexCoord;\n    void main() {\n      vTexCoord = aPosition;\n      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n    }"),Object.assign(this,this.constructor.defaults,options)}getFragmentSource(){return identityFragmentShader}createProgram(gl){let fragmentSource=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.getFragmentSource(),vertexSource=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.vertexSource;const{WebGLProbe:{GLPrecision="highp"}}=getEnv();"highp"!==GLPrecision&&(fragmentSource=fragmentSource.replace(new RegExp("precision highp float","g"),"precision highp float".replace("highp",GLPrecision)));const vertexShader=gl.createShader(gl.VERTEX_SHADER),fragmentShader=gl.createShader(gl.FRAGMENT_SHADER),program=gl.createProgram();if(!vertexShader||!fragmentShader||!program)throw new FabricError("Vertex, fragment shader or program creation error");if(gl.shaderSource(vertexShader,vertexSource),gl.compileShader(vertexShader),!gl.getShaderParameter(vertexShader,gl.COMPILE_STATUS))throw new FabricError("Vertex shader compile error for ".concat(this.type,": ").concat(gl.getShaderInfoLog(vertexShader)));if(gl.shaderSource(fragmentShader,fragmentSource),gl.compileShader(fragmentShader),!gl.getShaderParameter(fragmentShader,gl.COMPILE_STATUS))throw new FabricError("Fragment shader compile error for ".concat(this.type,": ").concat(gl.getShaderInfoLog(fragmentShader)));if(gl.attachShader(program,vertexShader),gl.attachShader(program,fragmentShader),gl.linkProgram(program),!gl.getProgramParameter(program,gl.LINK_STATUS))throw new FabricError('Shader link error for "'.concat(this.type,'" ').concat(gl.getProgramInfoLog(program)));const uniformLocations=this.getUniformLocations(gl,program)||{};return uniformLocations.uStepW=gl.getUniformLocation(program,"uStepW"),uniformLocations.uStepH=gl.getUniformLocation(program,"uStepH"),{program,attributeLocations:this.getAttributeLocations(gl,program),uniformLocations}}getAttributeLocations(gl,program){return{aPosition:gl.getAttribLocation(program,"aPosition")}}getUniformLocations(gl,program){return{}}sendAttributeData(gl,attributeLocations,aPositionData){const attributeLocation=attributeLocations.aPosition,buffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,buffer),gl.enableVertexAttribArray(attributeLocation),gl.vertexAttribPointer(attributeLocation,2,gl.FLOAT,!1,0,0),gl.bufferData(gl.ARRAY_BUFFER,aPositionData,gl.STATIC_DRAW)}_setupFrameBuffer(options){const gl=options.context;if(options.passes>1){const width=options.destinationWidth,height=options.destinationHeight;options.sourceWidth===width&&options.sourceHeight===height||(gl.deleteTexture(options.targetTexture),options.targetTexture=options.filterBackend.createTexture(gl,width,height)),gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,options.targetTexture,0)}else gl.bindFramebuffer(gl.FRAMEBUFFER,null),gl.finish()}_swapTextures(options){options.passes--,options.pass++;const temp=options.targetTexture;options.targetTexture=options.sourceTexture,options.sourceTexture=temp}isNeutralState(options){const main=this.mainParameter,defaultValue=this.constructor.defaults[main];if(main){const thisValue=this[main];return Array.isArray(defaultValue)&&Array.isArray(thisValue)?defaultValue.every(((value,i)=>value===thisValue[i])):defaultValue===thisValue}return!1}applyTo(options){isWebGLPipelineState(options)?(this._setupFrameBuffer(options),this.applyToWebGL(options),this._swapTextures(options)):this.applyTo2d(options)}applyTo2d(options){}getCacheKey(){return this.type}retrieveShader(options){const key=this.getCacheKey();return options.programCache[key]||(options.programCache[key]=this.createProgram(options.context)),options.programCache[key]}applyToWebGL(options){const gl=options.context,shader=this.retrieveShader(options);0===options.pass&&options.originalTexture?gl.bindTexture(gl.TEXTURE_2D,options.originalTexture):gl.bindTexture(gl.TEXTURE_2D,options.sourceTexture),gl.useProgram(shader.program),this.sendAttributeData(gl,shader.attributeLocations,options.aPosition),gl.uniform1f(shader.uniformLocations.uStepW,1/options.sourceWidth),gl.uniform1f(shader.uniformLocations.uStepH,1/options.sourceHeight),this.sendUniformData(gl,shader.uniformLocations),gl.viewport(0,0,options.destinationWidth,options.destinationHeight),gl.drawArrays(gl.TRIANGLE_STRIP,0,4)}bindAdditionalTexture(gl,texture,textureUnit){gl.activeTexture(textureUnit),gl.bindTexture(gl.TEXTURE_2D,texture),gl.activeTexture(gl.TEXTURE0)}unbindAdditionalTexture(gl,textureUnit){gl.activeTexture(textureUnit),gl.bindTexture(gl.TEXTURE_2D,null),gl.activeTexture(gl.TEXTURE0)}getMainParameter(){return this.mainParameter?this[this.mainParameter]:void 0}setMainParameter(value){this.mainParameter&&(this[this.mainParameter]=value)}sendUniformData(gl,uniformLocations){}createHelpLayer(options){if(!options.helpLayer){const helpLayer=createCanvasElement();helpLayer.width=options.sourceWidth,helpLayer.height=options.sourceHeight,options.helpLayer=helpLayer}}toObject(){const mainP=this.mainParameter;return _objectSpread2({type:this.type},mainP?{[mainP]:this[mainP]}:{})}toJSON(){return this.toObject()}static async fromObject(_ref2,options){return new this(_objectWithoutProperties(_ref2,_excluded2))}}_defineProperty(BaseFilter,"type","BaseFilter");const blendColorFragmentSource={multiply:"gl_FragColor.rgb *= uColor.rgb;\n",screen:"gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\n",add:"gl_FragColor.rgb += uColor.rgb;\n",difference:"gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n",subtract:"gl_FragColor.rgb -= uColor.rgb;\n",lighten:"gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n",darken:"gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n",exclusion:"gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n",overlay:"\n    if (uColor.r < 0.5) {\n      gl_FragColor.r *= 2.0 * uColor.r;\n    } else {\n      gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n    }\n    if (uColor.g < 0.5) {\n      gl_FragColor.g *= 2.0 * uColor.g;\n    } else {\n      gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n    }\n    if (uColor.b < 0.5) {\n      gl_FragColor.b *= 2.0 * uColor.b;\n    } else {\n      gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n    }\n    ",tint:"\n    gl_FragColor.rgb *= (1.0 - uColor.a);\n    gl_FragColor.rgb += uColor.rgb;\n    "};class BlendColor extends BaseFilter{getCacheKey(){return"".concat(this.type,"_").concat(this.mode)}getFragmentSource(){return"\n      precision highp float;\n      uniform sampler2D uTexture;\n      uniform vec4 uColor;\n      varying vec2 vTexCoord;\n      void main() {\n        vec4 color = texture2D(uTexture, vTexCoord);\n        gl_FragColor = color;\n        if (color.a > 0.0) {\n          ".concat(blendColorFragmentSource[this.mode],"\n        }\n      }\n      ")}applyTo2d(_ref){let{imageData:{data}}=_ref;const source=new Color(this.color).getSource(),tr=source[0]*this.alpha,tg=source[1]*this.alpha,tb=source[2]*this.alpha,alpha1=1-this.alpha;for(let i=0;i<data.length;i+=4){const r=data[i],g=data[i+1],b=data[i+2];switch(this.mode){case"multiply":data[i]=r*tr/255,data[i+1]=g*tg/255,data[i+2]=b*tb/255;break;case"screen":data[i]=255-(255-r)*(255-tr)/255,data[i+1]=255-(255-g)*(255-tg)/255,data[i+2]=255-(255-b)*(255-tb)/255;break;case"add":data[i]=r+tr,data[i+1]=g+tg,data[i+2]=b+tb;break;case"difference":data[i]=Math.abs(r-tr),data[i+1]=Math.abs(g-tg),data[i+2]=Math.abs(b-tb);break;case"subtract":data[i]=r-tr,data[i+1]=g-tg,data[i+2]=b-tb;break;case"darken":data[i]=Math.min(r,tr),data[i+1]=Math.min(g,tg),data[i+2]=Math.min(b,tb);break;case"lighten":data[i]=Math.max(r,tr),data[i+1]=Math.max(g,tg),data[i+2]=Math.max(b,tb);break;case"overlay":data[i]=tr<128?2*r*tr/255:255-2*(255-r)*(255-tr)/255,data[i+1]=tg<128?2*g*tg/255:255-2*(255-g)*(255-tg)/255,data[i+2]=tb<128?2*b*tb/255:255-2*(255-b)*(255-tb)/255;break;case"exclusion":data[i]=tr+r-2*tr*r/255,data[i+1]=tg+g-2*tg*g/255,data[i+2]=tb+b-2*tb*b/255;break;case"tint":data[i]=tr+r*alpha1,data[i+1]=tg+g*alpha1,data[i+2]=tb+b*alpha1}}}getUniformLocations(gl,program){return{uColor:gl.getUniformLocation(program,"uColor")}}sendUniformData(gl,uniformLocations){const source=new Color(this.color).getSource();source[0]=this.alpha*source[0]/255,source[1]=this.alpha*source[1]/255,source[2]=this.alpha*source[2]/255,source[3]=this.alpha,gl.uniform4fv(uniformLocations.uColor,source)}toObject(){return{type:this.type,color:this.color,mode:this.mode,alpha:this.alpha}}}_defineProperty(BlendColor,"defaults",{color:"#F95C63",mode:"multiply",alpha:1}),_defineProperty(BlendColor,"type","BlendColor"),classRegistry.setClass(BlendColor);const fragmentSource$c={multiply:"\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform sampler2D uImage;\n    uniform vec4 uColor;\n    varying vec2 vTexCoord;\n    varying vec2 vTexCoord2;\n    void main() {\n      vec4 color = texture2D(uTexture, vTexCoord);\n      vec4 color2 = texture2D(uImage, vTexCoord2);\n      color.rgba *= color2.rgba;\n      gl_FragColor = color;\n    }\n    ",mask:"\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform sampler2D uImage;\n    uniform vec4 uColor;\n    varying vec2 vTexCoord;\n    varying vec2 vTexCoord2;\n    void main() {\n      vec4 color = texture2D(uTexture, vTexCoord);\n      vec4 color2 = texture2D(uImage, vTexCoord2);\n      color.a = color2.a;\n      gl_FragColor = color;\n    }\n    "},_excluded$3=["type","image"];class BlendImage extends BaseFilter{getCacheKey(){return"".concat(this.type,"_").concat(this.mode)}getFragmentSource(){return fragmentSource$c[this.mode]}applyToWebGL(options){const gl=options.context,texture=this.createTexture(options.filterBackend,this.image);this.bindAdditionalTexture(gl,texture,gl.TEXTURE1),super.applyToWebGL(options),this.unbindAdditionalTexture(gl,gl.TEXTURE1)}createTexture(backend,image){return backend.getCachedTexture(image.cacheKey,image.getElement())}calculateMatrix(){const image=this.image,{width,height}=image.getElement();return[1/image.scaleX,0,0,0,1/image.scaleY,0,-image.left/width,-image.top/height,1]}applyTo2d(_ref){let{imageData:{data,width,height},filterBackend:{resources}}=_ref;const image=this.image;resources.blendImage||(resources.blendImage=createCanvasElement());const canvas1=resources.blendImage,context=canvas1.getContext("2d");canvas1.width!==width||canvas1.height!==height?(canvas1.width=width,canvas1.height=height):context.clearRect(0,0,width,height),context.setTransform(image.scaleX,0,0,image.scaleY,image.left,image.top),context.drawImage(image.getElement(),0,0,width,height);const blendData=context.getImageData(0,0,width,height).data;for(let i=0;i<data.length;i+=4){const r=data[i],g=data[i+1],b=data[i+2],a=data[i+3],tr=blendData[i],tg=blendData[i+1],tb=blendData[i+2],ta=blendData[i+3];switch(this.mode){case"multiply":data[i]=r*tr/255,data[i+1]=g*tg/255,data[i+2]=b*tb/255,data[i+3]=a*ta/255;break;case"mask":data[i+3]=ta}}}getUniformLocations(gl,program){return{uTransformMatrix:gl.getUniformLocation(program,"uTransformMatrix"),uImage:gl.getUniformLocation(program,"uImage")}}sendUniformData(gl,uniformLocations){const matrix=this.calculateMatrix();gl.uniform1i(uniformLocations.uImage,1),gl.uniformMatrix3fv(uniformLocations.uTransformMatrix,!1,matrix)}toObject(){return{type:this.type,image:this.image&&this.image.toObject(),mode:this.mode,alpha:this.alpha}}static fromObject(_ref2,options){let{type,image}=_ref2,filterOptions=_objectWithoutProperties(_ref2,_excluded$3);return FabricImage.fromObject(image,options).then((enlivedImage=>new this(_objectSpread2(_objectSpread2({},filterOptions),{},{image:enlivedImage}))))}}_defineProperty(BlendImage,"type","BlendImage"),_defineProperty(BlendImage,"defaults",{mode:"multiply",alpha:1,vertexSource:"\n    attribute vec2 aPosition;\n    varying vec2 vTexCoord;\n    varying vec2 vTexCoord2;\n    uniform mat3 uTransformMatrix;\n    void main() {\n      vTexCoord = aPosition;\n      vTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\n      gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n    }\n    "}),classRegistry.setClass(BlendImage);class Blur extends BaseFilter{getFragmentSource(){return"\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform vec2 uDelta;\n    varying vec2 vTexCoord;\n    const float nSamples = 15.0;\n    vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\n    float random(vec3 scale) {\n      /* use the fragment position for a different seed per-pixel */\n      return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n    }\n    void main() {\n      vec4 color = vec4(0.0);\n      float total = 0.0;\n      float offset = random(v3offset);\n      for (float t = -nSamples; t <= nSamples; t++) {\n        float percent = (t + offset - 0.5) / nSamples;\n        float weight = 1.0 - abs(percent);\n        color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\n        total += weight;\n      }\n      gl_FragColor = color / total;\n    }\n  "}applyTo(options){isWebGLPipelineState(options)?(this.aspectRatio=options.sourceWidth/options.sourceHeight,options.passes++,this._setupFrameBuffer(options),this.horizontal=!0,this.applyToWebGL(options),this._swapTextures(options),this._setupFrameBuffer(options),this.horizontal=!1,this.applyToWebGL(options),this._swapTextures(options)):this.applyTo2d(options)}applyTo2d(options){options.imageData=this.simpleBlur(options)}simpleBlur(_ref){let{ctx,imageData,filterBackend:{resources}}=_ref;const{width,height}=imageData;resources.blurLayer1||(resources.blurLayer1=createCanvasElement(),resources.blurLayer2=createCanvasElement());const canvas1=resources.blurLayer1,canvas2=resources.blurLayer2;canvas1.width===width&&canvas1.height===height||(canvas2.width=canvas1.width=width,canvas2.height=canvas1.height=height);const ctx1=canvas1.getContext("2d"),ctx2=canvas2.getContext("2d"),blur=.06*this.blur*.5;let random,percent,j,i;for(ctx1.putImageData(imageData,0,0),ctx2.clearRect(0,0,width,height),i=-15;i<=15;i++)random=(Math.random()-.5)/4,percent=i/15,j=blur*percent*width+random,ctx2.globalAlpha=1-Math.abs(percent),ctx2.drawImage(canvas1,j,random),ctx1.drawImage(canvas2,0,0),ctx2.globalAlpha=1,ctx2.clearRect(0,0,canvas2.width,canvas2.height);for(i=-15;i<=15;i++)random=(Math.random()-.5)/4,percent=i/15,j=blur*percent*height+random,ctx2.globalAlpha=1-Math.abs(percent),ctx2.drawImage(canvas1,random,j),ctx1.drawImage(canvas2,0,0),ctx2.globalAlpha=1,ctx2.clearRect(0,0,canvas2.width,canvas2.height);ctx.drawImage(canvas1,0,0);const newImageData=ctx.getImageData(0,0,canvas1.width,canvas1.height);return ctx1.globalAlpha=1,ctx1.clearRect(0,0,canvas1.width,canvas1.height),newImageData}getUniformLocations(gl,program){return{delta:gl.getUniformLocation(program,"uDelta")}}sendUniformData(gl,uniformLocations){const delta=this.chooseRightDelta();gl.uniform2fv(uniformLocations.delta,delta)}chooseRightDelta(){let blurScale=1;const delta=[0,0];this.horizontal?this.aspectRatio>1&&(blurScale=1/this.aspectRatio):this.aspectRatio<1&&(blurScale=this.aspectRatio);const blur=blurScale*this.blur*.12;return this.horizontal?delta[0]=blur:delta[1]=blur,delta}}_defineProperty(Blur,"type","Blur"),_defineProperty(Blur,"defaults",{blur:0,mainParameter:"blur"}),classRegistry.setClass(Blur);class Brightness extends BaseFilter{getFragmentSource(){return"\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uBrightness;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    color.rgb += uBrightness;\n    gl_FragColor = color;\n  }\n"}applyTo2d(_ref){let{imageData:{data}}=_ref;if(0===this.brightness)return;const brightness=Math.round(255*this.brightness);for(let i=0;i<data.length;i+=4)data[i]=data[i]+brightness,data[i+1]=data[i+1]+brightness,data[i+2]=data[i+2]+brightness}getUniformLocations(gl,program){return{uBrightness:gl.getUniformLocation(program,"uBrightness")}}sendUniformData(gl,uniformLocations){gl.uniform1f(uniformLocations.uBrightness,this.brightness)}}_defineProperty(Brightness,"type","Brightness"),_defineProperty(Brightness,"defaults",{brightness:0,mainParameter:"brightness"}),classRegistry.setClass(Brightness);const _excluded$2=["matrix"],colorMatrixDefaultValues={matrix:[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],mainParameter:"matrix",colorsOnly:!0};class ColorMatrix extends BaseFilter{setOptions(_ref){let{matrix}=_ref,options=_objectWithoutProperties(_ref,_excluded$2);matrix&&(this.matrix=[...matrix]),Object.assign(this,options)}getFragmentSource(){return"\n  precision highp float;\n  uniform sampler2D uTexture;\n  varying vec2 vTexCoord;\n  uniform mat4 uColorMatrix;\n  uniform vec4 uConstants;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    color *= uColorMatrix;\n    color += uConstants;\n    gl_FragColor = color;\n  }"}applyTo2d(options){const data=options.imageData.data,m=this.matrix,colorsOnly=this.colorsOnly;for(let i=0;i<data.length;i+=4){const r=data[i],g=data[i+1],b=data[i+2];if(colorsOnly)data[i]=r*m[0]+g*m[1]+b*m[2]+255*m[4],data[i+1]=r*m[5]+g*m[6]+b*m[7]+255*m[9],data[i+2]=r*m[10]+g*m[11]+b*m[12]+255*m[14];else{const a=data[i+3];data[i]=r*m[0]+g*m[1]+b*m[2]+a*m[3]+255*m[4],data[i+1]=r*m[5]+g*m[6]+b*m[7]+a*m[8]+255*m[9],data[i+2]=r*m[10]+g*m[11]+b*m[12]+a*m[13]+255*m[14],data[i+3]=r*m[15]+g*m[16]+b*m[17]+a*m[18]+255*m[19]}}}getUniformLocations(gl,program){return{uColorMatrix:gl.getUniformLocation(program,"uColorMatrix"),uConstants:gl.getUniformLocation(program,"uConstants")}}sendUniformData(gl,uniformLocations){const m=this.matrix,matrix=[m[0],m[1],m[2],m[3],m[5],m[6],m[7],m[8],m[10],m[11],m[12],m[13],m[15],m[16],m[17],m[18]],constants=[m[4],m[9],m[14],m[19]];gl.uniformMatrix4fv(uniformLocations.uColorMatrix,!1,matrix),gl.uniform4fv(uniformLocations.uConstants,constants)}}function createColorMatrixFilter(key,matrix){var _class;const newClass=(_defineProperty(_class=class newClass extends ColorMatrix{},"type",key),_defineProperty(_class,"defaults",_objectSpread2(_objectSpread2({},colorMatrixDefaultValues),{},{mainParameter:void 0,matrix})),_class);return classRegistry.setClass(newClass,key),newClass}_defineProperty(ColorMatrix,"type","ColorMatrix"),_defineProperty(ColorMatrix,"defaults",colorMatrixDefaultValues),classRegistry.setClass(ColorMatrix);createColorMatrixFilter("Brownie",[.5997,.34553,-.27082,0,.186,-.0377,.86095,.15059,0,-.1449,.24113,-.07441,.44972,0,-.02965,0,0,0,1,0]),createColorMatrixFilter("Vintage",[.62793,.32021,-.03965,0,.03784,.02578,.64411,.03259,0,.02926,.0466,-.08512,.52416,0,.02023,0,0,0,1,0]),createColorMatrixFilter("Kodachrome",[1.12855,-.39673,-.03992,0,.24991,-.16404,1.08352,-.05498,0,.09698,-.16786,-.56034,1.60148,0,.13972,0,0,0,1,0]),createColorMatrixFilter("Technicolor",[1.91252,-.85453,-.09155,0,.04624,-.30878,1.76589,-.10601,0,-.27589,-.2311,-.75018,1.84759,0,.12137,0,0,0,1,0]),createColorMatrixFilter("Polaroid",[1.438,-.062,-.062,0,0,-.122,1.378,-.122,0,0,-.016,-.016,1.483,0,0,0,0,0,1,0]),createColorMatrixFilter("Sepia",[.393,.769,.189,0,0,.349,.686,.168,0,0,.272,.534,.131,0,0,0,0,0,1,0]),createColorMatrixFilter("BlackWhite",[1.5,1.5,1.5,0,-1,1.5,1.5,1.5,0,-1,1.5,1.5,1.5,0,-1,0,0,0,1,0]);const _excluded$1=["subFilters"];class Composed extends BaseFilter{constructor(){let _ref=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{subFilters=[]}=_ref;super(_objectWithoutProperties(_ref,_excluded$1)),this.subFilters=subFilters}applyTo(options){isWebGLPipelineState(options)&&(options.passes+=this.subFilters.length-1),this.subFilters.forEach((filter=>{filter.applyTo(options)}))}toObject(){return _objectSpread2(_objectSpread2({},super.toObject()),{},{subFilters:this.subFilters.map((filter=>filter.toObject()))})}isNeutralState(){return!this.subFilters.some((filter=>!filter.isNeutralState()))}static fromObject(object,options){return Promise.all((object.subFilters||[]).map((filter=>classRegistry.getClass(filter.type).fromObject(filter,options)))).then((enlivedFilters=>new this({subFilters:enlivedFilters})))}}_defineProperty(Composed,"type","Composed"),classRegistry.setClass(Composed);class Contrast extends BaseFilter{getFragmentSource(){return"\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uContrast;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\n    color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\n    gl_FragColor = color;\n  }"}applyTo2d(_ref){let{imageData:{data}}=_ref;if(0===this.contrast)return;const contrast=Math.floor(255*this.contrast),contrastF=259*(contrast+255)/(255*(259-contrast));for(let i=0;i<data.length;i+=4)data[i]=contrastF*(data[i]-128)+128,data[i+1]=contrastF*(data[i+1]-128)+128,data[i+2]=contrastF*(data[i+2]-128)+128}getUniformLocations(gl,program){return{uContrast:gl.getUniformLocation(program,"uContrast")}}sendUniformData(gl,uniformLocations){gl.uniform1f(uniformLocations.uContrast,this.contrast)}}_defineProperty(Contrast,"type","Contrast"),_defineProperty(Contrast,"defaults",{contrast:0,mainParameter:"contrast"}),classRegistry.setClass(Contrast);const fragmentSource$7={Convolute_3_1:"\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[9];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 0);\n      for (float h = 0.0; h < 3.0; h+=1.0) {\n        for (float w = 0.0; w < 3.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\n          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n        }\n      }\n      gl_FragColor = color;\n    }\n    ",Convolute_3_0:"\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[9];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 1);\n      for (float h = 0.0; h < 3.0; h+=1.0) {\n        for (float w = 0.0; w < 3.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\n          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n        }\n      }\n      float alpha = texture2D(uTexture, vTexCoord).a;\n      gl_FragColor = color;\n      gl_FragColor.a = alpha;\n    }\n    ",Convolute_5_1:"\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[25];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 0);\n      for (float h = 0.0; h < 5.0; h+=1.0) {\n        for (float w = 0.0; w < 5.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n        }\n      }\n      gl_FragColor = color;\n    }\n    ",Convolute_5_0:"\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[25];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 1);\n      for (float h = 0.0; h < 5.0; h+=1.0) {\n        for (float w = 0.0; w < 5.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n        }\n      }\n      float alpha = texture2D(uTexture, vTexCoord).a;\n      gl_FragColor = color;\n      gl_FragColor.a = alpha;\n    }\n    ",Convolute_7_1:"\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[49];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 0);\n      for (float h = 0.0; h < 7.0; h+=1.0) {\n        for (float w = 0.0; w < 7.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n        }\n      }\n      gl_FragColor = color;\n    }\n    ",Convolute_7_0:"\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[49];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 1);\n      for (float h = 0.0; h < 7.0; h+=1.0) {\n        for (float w = 0.0; w < 7.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n        }\n      }\n      float alpha = texture2D(uTexture, vTexCoord).a;\n      gl_FragColor = color;\n      gl_FragColor.a = alpha;\n    }\n    ",Convolute_9_1:"\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[81];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 0);\n      for (float h = 0.0; h < 9.0; h+=1.0) {\n        for (float w = 0.0; w < 9.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n          color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n        }\n      }\n      gl_FragColor = color;\n    }\n    ",Convolute_9_0:"\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform float uMatrix[81];\n    uniform float uStepW;\n    uniform float uStepH;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = vec4(0, 0, 0, 1);\n      for (float h = 0.0; h < 9.0; h+=1.0) {\n        for (float w = 0.0; w < 9.0; w+=1.0) {\n          vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n          color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n        }\n      }\n      float alpha = texture2D(uTexture, vTexCoord).a;\n      gl_FragColor = color;\n      gl_FragColor.a = alpha;\n    }\n    "};class Convolute extends BaseFilter{getCacheKey(){return"".concat(this.type,"_").concat(Math.sqrt(this.matrix.length),"_").concat(this.opaque?1:0)}getFragmentSource(){return fragmentSource$7[this.getCacheKey()]}applyTo2d(options){const imageData=options.imageData,data=imageData.data,weights=this.matrix,side=Math.round(Math.sqrt(weights.length)),halfSide=Math.floor(side/2),sw=imageData.width,sh=imageData.height,output=options.ctx.createImageData(sw,sh),dst=output.data,alphaFac=this.opaque?1:0;let r,g,b,a,dstOff,scx,scy,srcOff,wt,x,y,cx,cy;for(y=0;y<sh;y++)for(x=0;x<sw;x++){for(dstOff=4*(y*sw+x),r=0,g=0,b=0,a=0,cy=0;cy<side;cy++)for(cx=0;cx<side;cx++)scy=y+cy-halfSide,scx=x+cx-halfSide,scy<0||scy>=sh||scx<0||scx>=sw||(srcOff=4*(scy*sw+scx),wt=weights[cy*side+cx],r+=data[srcOff]*wt,g+=data[srcOff+1]*wt,b+=data[srcOff+2]*wt,alphaFac||(a+=data[srcOff+3]*wt));dst[dstOff]=r,dst[dstOff+1]=g,dst[dstOff+2]=b,dst[dstOff+3]=alphaFac?data[dstOff+3]:a}options.imageData=output}getUniformLocations(gl,program){return{uMatrix:gl.getUniformLocation(program,"uMatrix"),uOpaque:gl.getUniformLocation(program,"uOpaque"),uHalfSize:gl.getUniformLocation(program,"uHalfSize"),uSize:gl.getUniformLocation(program,"uSize")}}sendUniformData(gl,uniformLocations){gl.uniform1fv(uniformLocations.uMatrix,this.matrix)}toObject(){return _objectSpread2(_objectSpread2({},super.toObject()),{},{opaque:this.opaque,matrix:[...this.matrix]})}}_defineProperty(Convolute,"type","Convolute"),_defineProperty(Convolute,"defaults",{opaque:!1,matrix:[0,0,0,0,1,0,0,0,0]}),classRegistry.setClass(Convolute);const _excluded=["gamma"];class Gamma extends BaseFilter{getFragmentSource(){return"\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform vec3 uGamma;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    vec3 correction = (1.0 / uGamma);\n    color.r = pow(color.r, correction.r);\n    color.g = pow(color.g, correction.g);\n    color.b = pow(color.b, correction.b);\n    gl_FragColor = color;\n    gl_FragColor.rgb *= color.a;\n  }\n"}constructor(){let _ref=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{gamma=[1,1,1]}=_ref;super(_objectWithoutProperties(_ref,_excluded)),this.gamma=gamma}applyTo2d(_ref2){let{imageData:{data}}=_ref2;const gamma=this.gamma,rInv=1/gamma[0],gInv=1/gamma[1],bInv=1/gamma[2];this.rgbValues||(this.rgbValues={r:new Uint8Array(256),g:new Uint8Array(256),b:new Uint8Array(256)});const rgb=this.rgbValues;for(let i=0;i<256;i++)rgb.r[i]=255*Math.pow(i/255,rInv),rgb.g[i]=255*Math.pow(i/255,gInv),rgb.b[i]=255*Math.pow(i/255,bInv);for(let i=0;i<data.length;i+=4)data[i]=rgb.r[data[i]],data[i+1]=rgb.g[data[i+1]],data[i+2]=rgb.b[data[i+2]]}getUniformLocations(gl,program){return{uGamma:gl.getUniformLocation(program,"uGamma")}}sendUniformData(gl,uniformLocations){gl.uniform3fv(uniformLocations.uGamma,this.gamma)}}_defineProperty(Gamma,"type","Gamma"),_defineProperty(Gamma,"defaults",{mainParameter:"gamma",gamma:[1,1,1]}),classRegistry.setClass(Gamma);const fragmentSource$5={average:"\n    precision highp float;\n    uniform sampler2D uTexture;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 color = texture2D(uTexture, vTexCoord);\n      float average = (color.r + color.b + color.g) / 3.0;\n      gl_FragColor = vec4(average, average, average, color.a);\n    }\n    ",lightness:"\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform int uMode;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 col = texture2D(uTexture, vTexCoord);\n      float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\n      gl_FragColor = vec4(average, average, average, col.a);\n    }\n    ",luminosity:"\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform int uMode;\n    varying vec2 vTexCoord;\n    void main() {\n      vec4 col = texture2D(uTexture, vTexCoord);\n      float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\n      gl_FragColor = vec4(average, average, average, col.a);\n    }\n    "};class Grayscale extends BaseFilter{applyTo2d(_ref){let{imageData:{data}}=_ref;for(let value,i=0;i<data.length;i+=4){switch(this.mode){case"average":value=(data[i]+data[i+1]+data[i+2])/3;break;case"lightness":value=(Math.min(data[i],data[i+1],data[i+2])+Math.max(data[i],data[i+1],data[i+2]))/2;break;case"luminosity":value=.21*data[i]+.72*data[i+1]+.07*data[i+2]}data[i]=value,data[i+1]=value,data[i+2]=value}}getCacheKey(){return"".concat(this.type,"_").concat(this.mode)}getFragmentSource(){return fragmentSource$5[this.mode]}getUniformLocations(gl,program){return{uMode:gl.getUniformLocation(program,"uMode")}}sendUniformData(gl,uniformLocations){gl.uniform1i(uniformLocations.uMode,1)}isNeutralState(){return!1}}_defineProperty(Grayscale,"type","Grayscale"),_defineProperty(Grayscale,"defaults",{mode:"average",mainParameter:"mode"}),classRegistry.setClass(Grayscale);class HueRotation extends ColorMatrix{calculateMatrix(){const rad=this.rotation*Math.PI,cosine=cos(rad),sine=sin(rad),aThird=1/3,aThirdSqtSin=Math.sqrt(aThird)*sine,OneMinusCos=1-cosine;this.matrix=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],this.matrix[0]=cosine+OneMinusCos/3,this.matrix[1]=aThird*OneMinusCos-aThirdSqtSin,this.matrix[2]=aThird*OneMinusCos+aThirdSqtSin,this.matrix[5]=aThird*OneMinusCos+aThirdSqtSin,this.matrix[6]=cosine+aThird*OneMinusCos,this.matrix[7]=aThird*OneMinusCos-aThirdSqtSin,this.matrix[10]=aThird*OneMinusCos-aThirdSqtSin,this.matrix[11]=aThird*OneMinusCos+aThirdSqtSin,this.matrix[12]=cosine+aThird*OneMinusCos}isNeutralState(){return this.calculateMatrix(),super.isNeutralState()}applyTo(options){this.calculateMatrix(),super.applyTo(options)}}_defineProperty(HueRotation,"type","HueRotation"),_defineProperty(HueRotation,"defaults",{rotation:0,mainParameter:"rotation"}),classRegistry.setClass(HueRotation);class Invert extends BaseFilter{applyTo2d(_ref){let{imageData:{data}}=_ref;for(let i=0;i<data.length;i+=4)data[i]=255-data[i],data[i+1]=255-data[i+1],data[i+2]=255-data[i+2],this.alpha&&(data[i+3]=255-data[i+3])}getFragmentSource(){return"\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform int uInvert;\n  uniform int uAlpha;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    if (uInvert == 1) {\n      if (uAlpha == 1) {\n        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,1.0 -color.a);\n      } else {\n        gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n      }\n    } else {\n      gl_FragColor = color;\n    }\n  }\n"}isNeutralState(){return!this.invert}getUniformLocations(gl,program){return{uInvert:gl.getUniformLocation(program,"uInvert"),uAlpha:gl.getUniformLocation(program,"uAlpha")}}sendUniformData(gl,uniformLocations){gl.uniform1i(uniformLocations.uInvert,Number(this.invert)),gl.uniform1i(uniformLocations.uAlpha,Number(this.alpha))}}_defineProperty(Invert,"type","Invert"),_defineProperty(Invert,"defaults",{alpha:!1,invert:!0,mainParameter:"invert"}),classRegistry.setClass(Invert);class Noise extends BaseFilter{getFragmentSource(){return"\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uStepH;\n  uniform float uNoise;\n  uniform float uSeed;\n  varying vec2 vTexCoord;\n  float rand(vec2 co, float seed, float vScale) {\n    return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n  }\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\n    gl_FragColor = color;\n  }\n"}applyTo2d(_ref){let{imageData:{data}}=_ref;if(0===this.noise)return;const noise=this.noise;for(let i=0;i<data.length;i+=4){const rand=(.5-Math.random())*noise;data[i]+=rand,data[i+1]+=rand,data[i+2]+=rand}}getUniformLocations(gl,program){return{uNoise:gl.getUniformLocation(program,"uNoise"),uSeed:gl.getUniformLocation(program,"uSeed")}}sendUniformData(gl,uniformLocations){gl.uniform1f(uniformLocations.uNoise,this.noise/255),gl.uniform1f(uniformLocations.uSeed,Math.random())}toObject(){return _objectSpread2(_objectSpread2({},super.toObject()),{},{noise:this.noise})}}_defineProperty(Noise,"type","Noise"),_defineProperty(Noise,"defaults",{mainParameter:"noise",noise:0}),classRegistry.setClass(Noise);class Pixelate extends BaseFilter{applyTo2d(_ref){let{imageData:{data,width,height}}=_ref;for(let i=0;i<height;i+=this.blocksize)for(let j=0;j<width;j+=this.blocksize){const index=4*i*width+4*j,r=data[index],g=data[index+1],b=data[index+2],a=data[index+3];for(let _i=i;_i<Math.min(i+this.blocksize,height);_i++)for(let _j=j;_j<Math.min(j+this.blocksize,width);_j++){const index=4*_i*width+4*_j;data[index]=r,data[index+1]=g,data[index+2]=b,data[index+3]=a}}}isNeutralState(){return 1===this.blocksize}getFragmentSource(){return"\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uBlocksize;\n  uniform float uStepW;\n  uniform float uStepH;\n  varying vec2 vTexCoord;\n  void main() {\n    float blockW = uBlocksize * uStepW;\n    float blockH = uBlocksize * uStepW;\n    int posX = int(vTexCoord.x / blockW);\n    int posY = int(vTexCoord.y / blockH);\n    float fposX = float(posX);\n    float fposY = float(posY);\n    vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\n    vec4 color = texture2D(uTexture, squareCoords);\n    gl_FragColor = color;\n  }\n"}getUniformLocations(gl,program){return{uBlocksize:gl.getUniformLocation(program,"uBlocksize"),uStepW:gl.getUniformLocation(program,"uStepW"),uStepH:gl.getUniformLocation(program,"uStepH")}}sendUniformData(gl,uniformLocations){gl.uniform1f(uniformLocations.uBlocksize,this.blocksize)}}_defineProperty(Pixelate,"type","Pixelate"),_defineProperty(Pixelate,"defaults",{blocksize:4,mainParameter:"blocksize"}),classRegistry.setClass(Pixelate);class RemoveColor extends BaseFilter{getFragmentShader(){return"\nprecision highp float;\nuniform sampler2D uTexture;\nuniform vec4 uLow;\nuniform vec4 uHigh;\nvarying vec2 vTexCoord;\nvoid main() {\n  gl_FragColor = texture2D(uTexture, vTexCoord);\n  if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\n    gl_FragColor.a = 0.0;\n  }\n}\n"}applyTo2d(_ref){let{imageData:{data}}=_ref;const distance=255*this.distance,source=new Color(this.color).getSource(),lowC=[source[0]-distance,source[1]-distance,source[2]-distance],highC=[source[0]+distance,source[1]+distance,source[2]+distance];for(let i=0;i<data.length;i+=4){const r=data[i],g=data[i+1],b=data[i+2];r>lowC[0]&&g>lowC[1]&&b>lowC[2]&&r<highC[0]&&g<highC[1]&&b<highC[2]&&(data[i+3]=0)}}getUniformLocations(gl,program){return{uLow:gl.getUniformLocation(program,"uLow"),uHigh:gl.getUniformLocation(program,"uHigh")}}sendUniformData(gl,uniformLocations){const source=new Color(this.color).getSource(),distance=this.distance,lowC=[0+source[0]/255-distance,0+source[1]/255-distance,0+source[2]/255-distance,1],highC=[source[0]/255+distance,source[1]/255+distance,source[2]/255+distance,1];gl.uniform4fv(uniformLocations.uLow,lowC),gl.uniform4fv(uniformLocations.uHigh,highC)}toObject(){return _objectSpread2(_objectSpread2({},super.toObject()),{},{color:this.color,distance:this.distance})}}_defineProperty(RemoveColor,"type","RemoveColor"),_defineProperty(RemoveColor,"defaults",{color:"#FFFFFF",distance:.02,useAlpha:!1}),classRegistry.setClass(RemoveColor);class Resize extends BaseFilter{getUniformLocations(gl,program){return{uDelta:gl.getUniformLocation(program,"uDelta"),uTaps:gl.getUniformLocation(program,"uTaps")}}sendUniformData(gl,uniformLocations){gl.uniform2fv(uniformLocations.uDelta,this.horizontal?[1/this.width,0]:[0,1/this.height]),gl.uniform1fv(uniformLocations.uTaps,this.taps)}getFilterWindow(){const scale=this.tempScale;return Math.ceil(this.lanczosLobes/scale)}getCacheKey(){const filterWindow=this.getFilterWindow();return"".concat(this.type,"_").concat(filterWindow)}getFragmentSource(){const filterWindow=this.getFilterWindow();return this.generateShader(filterWindow)}getTaps(){const lobeFunction=this.lanczosCreate(this.lanczosLobes),scale=this.tempScale,filterWindow=this.getFilterWindow(),taps=new Array(filterWindow);for(let i=1;i<=filterWindow;i++)taps[i-1]=lobeFunction(i*scale);return taps}generateShader(filterWindow){const offsets=new Array(filterWindow);for(let i=1;i<=filterWindow;i++)offsets[i-1]="".concat(i,".0 * uDelta");return"\n      ".concat(this.fragmentSourceTOP,"\n      uniform float uTaps[").concat(filterWindow,"];\n      void main() {\n        vec4 color = texture2D(uTexture, vTexCoord);\n        float sum = 1.0;\n        ").concat(offsets.map(((offset,i)=>"\n              color += texture2D(uTexture, vTexCoord + ".concat(offset,") * uTaps[").concat(i,"] + texture2D(uTexture, vTexCoord - ").concat(offset,") * uTaps[").concat(i,"];\n              sum += 2.0 * uTaps[").concat(i,"];\n            "))).join("\n"),"\n        gl_FragColor = color / sum;\n      }\n    ")}applyToForWebgl(options){options.passes++,this.width=options.sourceWidth,this.horizontal=!0,this.dW=Math.round(this.width*this.scaleX),this.dH=options.sourceHeight,this.tempScale=this.dW/this.width,this.taps=this.getTaps(),options.destinationWidth=this.dW,super.applyTo(options),options.sourceWidth=options.destinationWidth,this.height=options.sourceHeight,this.horizontal=!1,this.dH=Math.round(this.height*this.scaleY),this.tempScale=this.dH/this.height,this.taps=this.getTaps(),options.destinationHeight=this.dH,super.applyTo(options),options.sourceHeight=options.destinationHeight}applyTo(options){isWebGLPipelineState(options)?this.applyToForWebgl(options):this.applyTo2d(options)}isNeutralState(){return 1===this.scaleX&&1===this.scaleY}lanczosCreate(lobes){return x=>{if(x>=lobes||x<=-lobes)return 0;if(x<1.1920929e-7&&x>-1.1920929e-7)return 1;const xx=(x*=Math.PI)/lobes;return Math.sin(x)/x*Math.sin(xx)/xx}}applyTo2d(options){const imageData=options.imageData,scaleX=this.scaleX,scaleY=this.scaleY;this.rcpScaleX=1/scaleX,this.rcpScaleY=1/scaleY;const oW=imageData.width,oH=imageData.height,dW=Math.round(oW*scaleX),dH=Math.round(oH*scaleY);let newData;newData="sliceHack"===this.resizeType?this.sliceByTwo(options,oW,oH,dW,dH):"hermite"===this.resizeType?this.hermiteFastResize(options,oW,oH,dW,dH):"bilinear"===this.resizeType?this.bilinearFiltering(options,oW,oH,dW,dH):"lanczos"===this.resizeType?this.lanczosResize(options,oW,oH,dW,dH):new ImageData(dW,dH),options.imageData=newData}sliceByTwo(options,oW,oH,dW,dH){const imageData=options.imageData;let doneW=!1,doneH=!1,stepW=.5*oW,stepH=.5*oH;const resources=options.filterBackend.resources;let sX=0,sY=0;const dX=oW;let dY=0;resources.sliceByTwo||(resources.sliceByTwo=createCanvasElement());const tmpCanvas=resources.sliceByTwo;(tmpCanvas.width<1.5*oW||tmpCanvas.height<oH)&&(tmpCanvas.width=1.5*oW,tmpCanvas.height=oH);const ctx=tmpCanvas.getContext("2d");for(ctx.clearRect(0,0,1.5*oW,oH),ctx.putImageData(imageData,0,0),dW=Math.floor(dW),dH=Math.floor(dH);!doneW||!doneH;)oW=stepW,oH=stepH,dW<Math.floor(.5*stepW)?stepW=Math.floor(.5*stepW):(stepW=dW,doneW=!0),dH<Math.floor(.5*stepH)?stepH=Math.floor(.5*stepH):(stepH=dH,doneH=!0),ctx.drawImage(tmpCanvas,sX,sY,oW,oH,dX,dY,stepW,stepH),sX=dX,sY=dY,dY+=stepH;return ctx.getImageData(sX,sY,dW,dH)}lanczosResize(options,oW,oH,dW,dH){const srcData=options.imageData.data,destImg=options.ctx.createImageData(dW,dH),destData=destImg.data,lanczos=this.lanczosCreate(this.lanczosLobes),ratioX=this.rcpScaleX,ratioY=this.rcpScaleY,rcpRatioX=2/this.rcpScaleX,rcpRatioY=2/this.rcpScaleY,range2X=Math.ceil(ratioX*this.lanczosLobes/2),range2Y=Math.ceil(ratioY*this.lanczosLobes/2),cacheLanc={},center={x:0,y:0},icenter={x:0,y:0};return function process(u){let v,i,weight,idx,a,red,green,blue,alpha,fX,fY;for(center.x=(u+.5)*ratioX,icenter.x=Math.floor(center.x),v=0;v<dH;v++){for(center.y=(v+.5)*ratioY,icenter.y=Math.floor(center.y),a=0,red=0,green=0,blue=0,alpha=0,i=icenter.x-range2X;i<=icenter.x+range2X;i++)if(!(i<0||i>=oW)){fX=Math.floor(1e3*Math.abs(i-center.x)),cacheLanc[fX]||(cacheLanc[fX]={});for(let j=icenter.y-range2Y;j<=icenter.y+range2Y;j++)j<0||j>=oH||(fY=Math.floor(1e3*Math.abs(j-center.y)),cacheLanc[fX][fY]||(cacheLanc[fX][fY]=lanczos(Math.sqrt(Math.pow(fX*rcpRatioX,2)+Math.pow(fY*rcpRatioY,2))/1e3)),weight=cacheLanc[fX][fY],weight>0&&(idx=4*(j*oW+i),a+=weight,red+=weight*srcData[idx],green+=weight*srcData[idx+1],blue+=weight*srcData[idx+2],alpha+=weight*srcData[idx+3]))}idx=4*(v*dW+u),destData[idx]=red/a,destData[idx+1]=green/a,destData[idx+2]=blue/a,destData[idx+3]=alpha/a}return++u<dW?process(u):destImg}(0)}bilinearFiltering(options,oW,oH,dW,dH){let a,b,c,d,x,y,i,j,xDiff,yDiff,chnl,color,origPix,offset=0;const ratioX=this.rcpScaleX,ratioY=this.rcpScaleY,w4=4*(oW-1),pixels=options.imageData.data,destImage=options.ctx.createImageData(dW,dH),destPixels=destImage.data;for(i=0;i<dH;i++)for(j=0;j<dW;j++)for(x=Math.floor(ratioX*j),y=Math.floor(ratioY*i),xDiff=ratioX*j-x,yDiff=ratioY*i-y,origPix=4*(y*oW+x),chnl=0;chnl<4;chnl++)a=pixels[origPix+chnl],b=pixels[origPix+4+chnl],c=pixels[origPix+w4+chnl],d=pixels[origPix+w4+4+chnl],color=a*(1-xDiff)*(1-yDiff)+b*xDiff*(1-yDiff)+c*yDiff*(1-xDiff)+d*xDiff*yDiff,destPixels[offset++]=color;return destImage}hermiteFastResize(options,oW,oH,dW,dH){const ratioW=this.rcpScaleX,ratioH=this.rcpScaleY,ratioWHalf=Math.ceil(ratioW/2),ratioHHalf=Math.ceil(ratioH/2),data=options.imageData.data,img2=options.ctx.createImageData(dW,dH),data2=img2.data;for(let j=0;j<dH;j++)for(let i=0;i<dW;i++){const x2=4*(i+j*dW);let weight=0,weights=0,weightsAlpha=0,gxR=0,gxG=0,gxB=0,gxA=0;const centerY=(j+.5)*ratioH;for(let yy=Math.floor(j*ratioH);yy<(j+1)*ratioH;yy++){const dy=Math.abs(centerY-(yy+.5))/ratioHHalf,centerX=(i+.5)*ratioW,w0=dy*dy;for(let xx=Math.floor(i*ratioW);xx<(i+1)*ratioW;xx++){let dx=Math.abs(centerX-(xx+.5))/ratioWHalf;const w=Math.sqrt(w0+dx*dx);w>1&&w<-1||(weight=2*w*w*w-3*w*w+1,weight>0&&(dx=4*(xx+yy*oW),gxA+=weight*data[dx+3],weightsAlpha+=weight,data[dx+3]<255&&(weight=weight*data[dx+3]/250),gxR+=weight*data[dx],gxG+=weight*data[dx+1],gxB+=weight*data[dx+2],weights+=weight))}}data2[x2]=gxR/weights,data2[x2+1]=gxG/weights,data2[x2+2]=gxB/weights,data2[x2+3]=gxA/weightsAlpha}return img2}toObject(){return{type:this.type,scaleX:this.scaleX,scaleY:this.scaleY,resizeType:this.resizeType,lanczosLobes:this.lanczosLobes}}}_defineProperty(Resize,"type","Resize"),_defineProperty(Resize,"defaults",{resizeType:"hermite",scaleX:1,scaleY:1,lanczosLobes:3,fragmentSourceTOP:"\n    precision highp float;\n    uniform sampler2D uTexture;\n    uniform vec2 uDelta;\n    varying vec2 vTexCoord;\n  "}),classRegistry.setClass(Resize);class Saturation extends BaseFilter{getFragmentSource(){return"\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uSaturation;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    float rgMax = max(color.r, color.g);\n    float rgbMax = max(rgMax, color.b);\n    color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\n    color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\n    color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\n    gl_FragColor = color;\n  }\n"}applyTo2d(_ref){let{imageData:{data}}=_ref;if(0===this.saturation)return;const adjust=-this.saturation;for(let i=0;i<data.length;i+=4){const max=Math.max(data[i],data[i+1],data[i+2]);data[i]+=max!==data[i]?(max-data[i])*adjust:0,data[i+1]+=max!==data[i+1]?(max-data[i+1])*adjust:0,data[i+2]+=max!==data[i+2]?(max-data[i+2])*adjust:0}}getUniformLocations(gl,program){return{uSaturation:gl.getUniformLocation(program,"uSaturation")}}sendUniformData(gl,uniformLocations){gl.uniform1f(uniformLocations.uSaturation,-this.saturation)}}_defineProperty(Saturation,"type","Saturation"),_defineProperty(Saturation,"defaults",{saturation:0,mainParameter:"saturation"}),classRegistry.setClass(Saturation);class Vibrance extends BaseFilter{getFragmentSource(){return"\n  precision highp float;\n  uniform sampler2D uTexture;\n  uniform float uVibrance;\n  varying vec2 vTexCoord;\n  void main() {\n    vec4 color = texture2D(uTexture, vTexCoord);\n    float max = max(color.r, max(color.g, color.b));\n    float avg = (color.r + color.g + color.b) / 3.0;\n    float amt = (abs(max - avg) * 2.0) * uVibrance;\n    color.r += max != color.r ? (max - color.r) * amt : 0.00;\n    color.g += max != color.g ? (max - color.g) * amt : 0.00;\n    color.b += max != color.b ? (max - color.b) * amt : 0.00;\n    gl_FragColor = color;\n  }\n"}applyTo2d(_ref){let{imageData:{data}}=_ref;if(0===this.vibrance)return;const adjust=-this.vibrance;for(let i=0;i<data.length;i+=4){const max=Math.max(data[i],data[i+1],data[i+2]),avg=(data[i]+data[i+1]+data[i+2])/3,amt=2*Math.abs(max-avg)/255*adjust;data[i]+=max!==data[i]?(max-data[i])*amt:0,data[i+1]+=max!==data[i+1]?(max-data[i+1])*amt:0,data[i+2]+=max!==data[i+2]?(max-data[i+2])*amt:0}}getUniformLocations(gl,program){return{uVibrance:gl.getUniformLocation(program,"uVibrance")}}sendUniformData(gl,uniformLocations){gl.uniform1f(uniformLocations.uVibrance,-this.vibrance)}}_defineProperty(Vibrance,"type","Vibrance"),_defineProperty(Vibrance,"defaults",{vibrance:0,mainParameter:"vibrance"}),classRegistry.setClass(Vibrance)},"./node_modules/fontfaceobserver/fontfaceobserver.standalone.js":module=>{!function(){function p(a,c){document.addEventListener?a.addEventListener("scroll",c,!1):a.attachEvent("scroll",c)}function w(a){this.g=document.createElement("div"),this.g.setAttribute("aria-hidden","true"),this.g.appendChild(document.createTextNode(a)),this.h=document.createElement("span"),this.i=document.createElement("span"),this.m=document.createElement("span"),this.j=document.createElement("span"),this.l=-1,this.h.style.cssText="max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;",this.i.style.cssText="max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;",this.j.style.cssText="max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;",this.m.style.cssText="display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;",this.h.appendChild(this.m),this.i.appendChild(this.j),this.g.appendChild(this.h),this.g.appendChild(this.i)}function x(a,c){a.g.style.cssText="max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:"+c+";"}function B(a){var c=a.g.offsetWidth,b=c+100;return a.j.style.width=b+"px",a.i.scrollLeft=b,a.h.scrollLeft=a.h.scrollWidth+100,a.l!==c&&(a.l=c,!0)}function C(a,c){function b(){var e=g;B(e)&&null!==e.g.parentNode&&c(e.l)}var g=a;p(a.h,b),p(a.i,b),B(a)}function D(a,c,b){c=c||{},b=b||window,this.family=a,this.style=c.style||"normal",this.weight=c.weight||"normal",this.stretch=c.stretch||"normal",this.context=b}var E=null,F=null,G=null,H=null;function M(a){return null===H&&(H=!!a.document.fonts),H}function N(a,c){var b=a.style,g=a.weight;if(null===G){var e=document.createElement("div");try{e.style.font="condensed 100px sans-serif"}catch(q){}G=""!==e.style.font}return[b,g,G?a.stretch:"","100px",c].join(" ")}D.prototype.load=function(a,c){var b=this,g=a||"BESbswy",e=0,q=c||3e3,J=(new Date).getTime();return new Promise((function(K,L){if(M(b.context)&&!function I(a){return null===F&&(M(a)&&/Apple/.test(window.navigator.vendor)?(a=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(window.navigator.userAgent),F=!!a&&603>parseInt(a[1],10)):F=!1),F}(b.context)){var O=new Promise((function(r,t){!function h(){(new Date).getTime()-J>=q?t(Error(q+"ms timeout exceeded")):b.context.document.fonts.load(N(b,'"'+b.family+'"'),g).then((function(n){1<=n.length?r():setTimeout(h,25)}),t)}()})),P=new Promise((function(r,t){e=setTimeout((function(){t(Error(q+"ms timeout exceeded"))}),q)}));Promise.race([P,O]).then((function(){clearTimeout(e),K(b)}),L)}else!function u(a){document.body?a():document.addEventListener?document.addEventListener("DOMContentLoaded",(function b(){document.removeEventListener("DOMContentLoaded",b),a()})):document.attachEvent("onreadystatechange",(function g(){"interactive"!=document.readyState&&"complete"!=document.readyState||(document.detachEvent("onreadystatechange",g),a())}))}((function(){function r(){var d;(d=-1!=k&&-1!=l||-1!=k&&-1!=m||-1!=l&&-1!=m)&&((d=k!=l&&k!=m&&l!=m)||(null===E&&(d=/AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent),E=!!d&&(536>parseInt(d[1],10)||536===parseInt(d[1],10)&&11>=parseInt(d[2],10))),d=E&&(k==y&&l==y&&m==y||k==z&&l==z&&m==z||k==A&&l==A&&m==A)),d=!d),d&&(null!==f.parentNode&&f.parentNode.removeChild(f),clearTimeout(e),K(b))}var h=new w(g),n=new w(g),v=new w(g),k=-1,l=-1,m=-1,y=-1,z=-1,A=-1,f=document.createElement("div");f.dir="ltr",x(h,N(b,"sans-serif")),x(n,N(b,"serif")),x(v,N(b,"monospace")),f.appendChild(h.g),f.appendChild(n.g),f.appendChild(v.g),b.context.document.body.appendChild(f),y=h.g.offsetWidth,z=n.g.offsetWidth,A=v.g.offsetWidth,function t(){if((new Date).getTime()-J>=q)null!==f.parentNode&&f.parentNode.removeChild(f),L(Error(q+"ms timeout exceeded"));else{var d=b.context.document.hidden;!0!==d&&void 0!==d||(k=h.g.offsetWidth,l=n.g.offsetWidth,m=v.g.offsetWidth,r()),e=setTimeout(t,50)}}(),C(h,(function(d){k=d,r()})),x(h,N(b,'"'+b.family+'",sans-serif')),C(n,(function(d){l=d,r()})),x(n,N(b,'"'+b.family+'",serif')),C(v,(function(d){m=d,r()})),x(v,N(b,'"'+b.family+'",monospace'))}))}))},module.exports=D}()},"./node_modules/hotkeys-js/dist/hotkeys.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{A:()=>hotkeys});const isff="undefined"!=typeof navigator&&navigator.userAgent.toLowerCase().indexOf("firefox")>0;function addEvent(object,event,method,useCapture){object.addEventListener?object.addEventListener(event,method,useCapture):object.attachEvent&&object.attachEvent("on".concat(event),method)}function removeEvent(object,event,method,useCapture){object.removeEventListener?object.removeEventListener(event,method,useCapture):object.detachEvent&&object.detachEvent("on".concat(event),method)}function getMods(modifier,key){const mods=key.slice(0,key.length-1);for(let i=0;i<mods.length;i++)mods[i]=modifier[mods[i].toLowerCase()];return mods}function getKeys(key){"string"!=typeof key&&(key="");const keys=(key=key.replace(/\s/g,"")).split(",");let index=keys.lastIndexOf("");for(;index>=0;)keys[index-1]+=",",keys.splice(index,1),index=keys.lastIndexOf("");return keys}const _keyMap={backspace:8,"":8,tab:9,clear:12,enter:13,"":13,return:13,esc:27,escape:27,space:32,left:37,up:38,right:39,down:40,del:46,delete:46,ins:45,insert:45,home:36,end:35,pageup:33,pagedown:34,capslock:20,num_0:96,num_1:97,num_2:98,num_3:99,num_4:100,num_5:101,num_6:102,num_7:103,num_8:104,num_9:105,num_multiply:106,num_add:107,num_enter:108,num_subtract:109,num_decimal:110,num_divide:111,"":20,",":188,".":190,"/":191,"`":192,"-":isff?173:189,"=":isff?61:187,";":isff?59:186,"'":222,"[":219,"]":221,"\\":220},_modifier={"":16,shift:16,"":18,alt:18,option:18,"":17,ctrl:17,control:17,"":91,cmd:91,command:91},modifierMap={16:"shiftKey",18:"altKey",17:"ctrlKey",91:"metaKey",shiftKey:16,ctrlKey:17,altKey:18,metaKey:91},_mods={16:!1,18:!1,17:!1,91:!1},_handlers={};for(let k=1;k<20;k++)_keyMap["f".concat(k)]=111+k;let _downKeys=[],winListendFocus=null,_scope="all";const elementEventMap=new Map,code=x=>_keyMap[x.toLowerCase()]||_modifier[x.toLowerCase()]||x.toUpperCase().charCodeAt(0);function setScope(scope){_scope=scope||"all"}function getScope(){return _scope||"all"}function unbind(keysInfo){if(void 0===keysInfo)Object.keys(_handlers).forEach((key=>{Array.isArray(_handlers[key])&&_handlers[key].forEach((info=>eachUnbind(info))),delete _handlers[key]})),removeKeyEvent(null);else if(Array.isArray(keysInfo))keysInfo.forEach((info=>{info.key&&eachUnbind(info)}));else if("object"==typeof keysInfo)keysInfo.key&&eachUnbind(keysInfo);else if("string"==typeof keysInfo){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];let[scope,method]=args;"function"==typeof scope&&(method=scope,scope=""),eachUnbind({key:keysInfo,scope,method,splitKey:"+"})}}const eachUnbind=_ref3=>{let{key,scope,method,splitKey="+"}=_ref3;getKeys(key).forEach((originKey=>{const unbindKeys=originKey.split(splitKey),len=unbindKeys.length,lastKey=unbindKeys[len-1],keyCode="*"===lastKey?"*":code(lastKey);if(!_handlers[keyCode])return;scope||(scope=getScope());const mods=len>1?getMods(_modifier,unbindKeys):[],unbindElements=[];_handlers[keyCode]=_handlers[keyCode].filter((record=>{const isUnbind=(!method||record.method===method)&&record.scope===scope&&function compareArray(a1,a2){const arr1=a1.length>=a2.length?a1:a2,arr2=a1.length>=a2.length?a2:a1;let isIndex=!0;for(let i=0;i<arr1.length;i++)-1===arr2.indexOf(arr1[i])&&(isIndex=!1);return isIndex}(record.mods,mods);return isUnbind&&unbindElements.push(record.element),!isUnbind})),unbindElements.forEach((element=>removeKeyEvent(element)))}))};function eventHandler(event,handler,scope,element){if(handler.element!==element)return;let modifiersMatch;if(handler.scope===scope||"all"===handler.scope){modifiersMatch=handler.mods.length>0;for(const y in _mods)Object.prototype.hasOwnProperty.call(_mods,y)&&(!_mods[y]&&handler.mods.indexOf(+y)>-1||_mods[y]&&-1===handler.mods.indexOf(+y))&&(modifiersMatch=!1);(0!==handler.mods.length||_mods[16]||_mods[18]||_mods[17]||_mods[91])&&!modifiersMatch&&"*"!==handler.shortcut||(handler.keys=[],handler.keys=handler.keys.concat(_downKeys),!1===handler.method(event,handler)&&(event.preventDefault?event.preventDefault():event.returnValue=!1,event.stopPropagation&&event.stopPropagation(),event.cancelBubble&&(event.cancelBubble=!0)))}}function dispatch(event,element){const asterisk=_handlers["*"];let key=event.keyCode||event.which||event.charCode;if(!hotkeys.filter.call(this,event))return;if(93!==key&&224!==key||(key=91),-1===_downKeys.indexOf(key)&&229!==key&&_downKeys.push(key),["metaKey","ctrlKey","altKey","shiftKey"].forEach((keyName=>{const keyNum=modifierMap[keyName];event[keyName]&&-1===_downKeys.indexOf(keyNum)?_downKeys.push(keyNum):!event[keyName]&&_downKeys.indexOf(keyNum)>-1?_downKeys.splice(_downKeys.indexOf(keyNum),1):"metaKey"===keyName&&event[keyName]&&(_downKeys=_downKeys.filter((k=>k in modifierMap||k===key)))})),key in _mods){_mods[key]=!0;for(const k in _modifier)_modifier[k]===key&&(hotkeys[k]=!0);if(!asterisk)return}for(const e in _mods)Object.prototype.hasOwnProperty.call(_mods,e)&&(_mods[e]=event[modifierMap[e]]);event.getModifierState&&(!event.altKey||event.ctrlKey)&&event.getModifierState("AltGraph")&&(-1===_downKeys.indexOf(17)&&_downKeys.push(17),-1===_downKeys.indexOf(18)&&_downKeys.push(18),_mods[17]=!0,_mods[18]=!0);const scope=getScope();if(asterisk)for(let i=0;i<asterisk.length;i++)asterisk[i].scope===scope&&("keydown"===event.type&&asterisk[i].keydown||"keyup"===event.type&&asterisk[i].keyup)&&eventHandler(event,asterisk[i],scope,element);if(!(key in _handlers))return;const handlerKey=_handlers[key],keyLen=handlerKey.length;for(let i=0;i<keyLen;i++)if(("keydown"===event.type&&handlerKey[i].keydown||"keyup"===event.type&&handlerKey[i].keyup)&&handlerKey[i].key){const record=handlerKey[i],{splitKey}=record,keyShortcut=record.key.split(splitKey),_downKeysCurrent=[];for(let a=0;a<keyShortcut.length;a++)_downKeysCurrent.push(code(keyShortcut[a]));_downKeysCurrent.sort().join("")===_downKeys.sort().join("")&&eventHandler(event,record,scope,element)}}function hotkeys(key,option,method){_downKeys=[];const keys=getKeys(key);let mods=[],scope="all",element=document,i=0,keyup=!1,keydown=!0,splitKey="+",capture=!1,single=!1;for(void 0===method&&"function"==typeof option&&(method=option),"[object Object]"===Object.prototype.toString.call(option)&&(option.scope&&(scope=option.scope),option.element&&(element=option.element),option.keyup&&(keyup=option.keyup),void 0!==option.keydown&&(keydown=option.keydown),void 0!==option.capture&&(capture=option.capture),"string"==typeof option.splitKey&&(splitKey=option.splitKey),!0===option.single&&(single=!0)),"string"==typeof option&&(scope=option),single&&unbind(key,scope);i<keys.length;i++)mods=[],(key=keys[i].split(splitKey)).length>1&&(mods=getMods(_modifier,key)),(key="*"===(key=key[key.length-1])?"*":code(key))in _handlers||(_handlers[key]=[]),_handlers[key].push({keyup,keydown,scope,mods,shortcut:keys[i],method,key:keys[i],splitKey,element});if(void 0!==element&&window){if(!elementEventMap.has(element)){const keydownListener=function(){return dispatch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:window.event,element)},keyupListenr=function(){let event=arguments.length>0&&void 0!==arguments[0]?arguments[0]:window.event;dispatch(event,element),function clearModifier(event){let key=event.keyCode||event.which||event.charCode;const i=_downKeys.indexOf(key);if(i>=0&&_downKeys.splice(i,1),event.key&&"meta"===event.key.toLowerCase()&&_downKeys.splice(0,_downKeys.length),93!==key&&224!==key||(key=91),key in _mods){_mods[key]=!1;for(const k in _modifier)_modifier[k]===key&&(hotkeys[k]=!1)}}(event)};elementEventMap.set(element,{keydownListener,keyupListenr,capture}),addEvent(element,"keydown",keydownListener,capture),addEvent(element,"keyup",keyupListenr,capture)}if(!winListendFocus){const listener=()=>{_downKeys=[]};winListendFocus={listener,capture},addEvent(window,"focus",listener,capture)}}}function removeKeyEvent(element){const values=Object.values(_handlers).flat();if(values.findIndex((_ref4=>{let{element:el}=_ref4;return el===element}))<0){const{keydownListener,keyupListenr,capture}=elementEventMap.get(element)||{};keydownListener&&keyupListenr&&(removeEvent(element,"keyup",keyupListenr,capture),removeEvent(element,"keydown",keydownListener,capture),elementEventMap.delete(element))}if(values.length<=0||elementEventMap.size<=0){if(Object.keys(elementEventMap).forEach((el=>{const{keydownListener,keyupListenr,capture}=elementEventMap.get(el)||{};keydownListener&&keyupListenr&&(removeEvent(el,"keyup",keyupListenr,capture),removeEvent(el,"keydown",keydownListener,capture),elementEventMap.delete(el))})),elementEventMap.clear(),Object.keys(_handlers).forEach((key=>delete _handlers[key])),winListendFocus){const{listener,capture}=winListendFocus;removeEvent(window,"focus",listener,capture),winListendFocus=null}}}const _api={getPressedKeyString:function getPressedKeyString(){return _downKeys.map((c=>{return x=c,Object.keys(_keyMap).find((k=>_keyMap[k]===x))||(x=>Object.keys(_modifier).find((k=>_modifier[k]===x)))(c)||String.fromCharCode(c);var x}))},setScope,getScope,deleteScope:function deleteScope(scope,newScope){let handlers,i;scope||(scope=getScope());for(const key in _handlers)if(Object.prototype.hasOwnProperty.call(_handlers,key))for(handlers=_handlers[key],i=0;i<handlers.length;)if(handlers[i].scope===scope){handlers.splice(i,1).forEach((_ref2=>{let{element}=_ref2;return removeKeyEvent(element)}))}else i++;getScope()===scope&&setScope(newScope||"all")},getPressedKeyCodes:function getPressedKeyCodes(){return _downKeys.slice(0)},getAllKeyCodes:function getAllKeyCodes(){const result=[];return Object.keys(_handlers).forEach((k=>{_handlers[k].forEach((_ref=>{let{key,scope,mods,shortcut}=_ref;result.push({scope,shortcut,mods,keys:key.split("+").map((v=>code(v)))})}))})),result},isPressed:function isPressed(keyCode){return"string"==typeof keyCode&&(keyCode=code(keyCode)),-1!==_downKeys.indexOf(keyCode)},filter:function filter(event){const target=event.target||event.srcElement,{tagName}=target;let flag=!0;const isInput="INPUT"===tagName&&!["checkbox","radio","range","button","file","reset","submit","color"].includes(target.type);return(target.isContentEditable||(isInput||"TEXTAREA"===tagName||"SELECT"===tagName)&&!target.readOnly)&&(flag=!1),flag},trigger:function trigger(shortcut){let scope=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"all";Object.keys(_handlers).forEach((key=>{_handlers[key].filter((item=>item.scope===scope&&item.shortcut===shortcut)).forEach((data=>{data&&data.method&&data.method()}))}))},unbind,keyMap:_keyMap,modifier:_modifier,modifierMap};for(const a in _api)Object.prototype.hasOwnProperty.call(_api,a)&&(hotkeys[a]=_api[a]);if("undefined"!=typeof window){const _hotkeys=window.hotkeys;hotkeys.noConflict=deep=>(deep&&window.hotkeys===hotkeys&&(window.hotkeys=_hotkeys),hotkeys),window.hotkeys=hotkeys}},"./node_modules/memoize-one/dist/memoize-one.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{A:()=>memoizeOne});var safeIsNaN=Number.isNaN||function ponyfill(value){return"number"==typeof value&&value!=value};function areInputsEqual(newInputs,lastInputs){if(newInputs.length!==lastInputs.length)return!1;for(var i=0;i<newInputs.length;i++)if(first=newInputs[i],second=lastInputs[i],!(first===second||safeIsNaN(first)&&safeIsNaN(second)))return!1;var first,second;return!0}function memoizeOne(resultFn,isEqual){void 0===isEqual&&(isEqual=areInputsEqual);var cache=null;function memoized(){for(var newArgs=[],_i=0;_i<arguments.length;_i++)newArgs[_i]=arguments[_i];if(cache&&cache.lastThis===this&&isEqual(newArgs,cache.lastArgs))return cache.lastResult;var lastResult=resultFn.apply(this,newArgs);return cache={lastResult,lastArgs:newArgs,lastThis:this},lastResult}return memoized.clear=function clear(){cache=null},memoized}},"./node_modules/pako/dist/pako.esm.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{Kc:()=>deflate_1,UD:()=>inflate_1});function zero$1(buf){let len=buf.length;for(;--len>=0;)buf[len]=0}const extra_lbits=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),extra_dbits=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),extra_blbits=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),bl_order=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),static_ltree=new Array(576);zero$1(static_ltree);const static_dtree=new Array(60);zero$1(static_dtree);const _dist_code=new Array(512);zero$1(_dist_code);const _length_code=new Array(256);zero$1(_length_code);const base_length=new Array(29);zero$1(base_length);const base_dist=new Array(30);function StaticTreeDesc(static_tree,extra_bits,extra_base,elems,max_length){this.static_tree=static_tree,this.extra_bits=extra_bits,this.extra_base=extra_base,this.elems=elems,this.max_length=max_length,this.has_stree=static_tree&&static_tree.length}let static_l_desc,static_d_desc,static_bl_desc;function TreeDesc(dyn_tree,stat_desc){this.dyn_tree=dyn_tree,this.max_code=0,this.stat_desc=stat_desc}zero$1(base_dist);const d_code=dist=>dist<256?_dist_code[dist]:_dist_code[256+(dist>>>7)],put_short=(s,w)=>{s.pending_buf[s.pending++]=255&w,s.pending_buf[s.pending++]=w>>>8&255},send_bits=(s,value,length)=>{s.bi_valid>16-length?(s.bi_buf|=value<<s.bi_valid&65535,put_short(s,s.bi_buf),s.bi_buf=value>>16-s.bi_valid,s.bi_valid+=length-16):(s.bi_buf|=value<<s.bi_valid&65535,s.bi_valid+=length)},send_code=(s,c,tree)=>{send_bits(s,tree[2*c],tree[2*c+1])},bi_reverse=(code,len)=>{let res=0;do{res|=1&code,code>>>=1,res<<=1}while(--len>0);return res>>>1},gen_codes=(tree,max_code,bl_count)=>{const next_code=new Array(16);let bits,n,code=0;for(bits=1;bits<=15;bits++)code=code+bl_count[bits-1]<<1,next_code[bits]=code;for(n=0;n<=max_code;n++){let len=tree[2*n+1];0!==len&&(tree[2*n]=bi_reverse(next_code[len]++,len))}},init_block=s=>{let n;for(n=0;n<286;n++)s.dyn_ltree[2*n]=0;for(n=0;n<30;n++)s.dyn_dtree[2*n]=0;for(n=0;n<19;n++)s.bl_tree[2*n]=0;s.dyn_ltree[512]=1,s.opt_len=s.static_len=0,s.sym_next=s.matches=0},bi_windup=s=>{s.bi_valid>8?put_short(s,s.bi_buf):s.bi_valid>0&&(s.pending_buf[s.pending++]=s.bi_buf),s.bi_buf=0,s.bi_valid=0},smaller=(tree,n,m,depth)=>{const _n2=2*n,_m2=2*m;return tree[_n2]<tree[_m2]||tree[_n2]===tree[_m2]&&depth[n]<=depth[m]},pqdownheap=(s,tree,k)=>{const v=s.heap[k];let j=k<<1;for(;j<=s.heap_len&&(j<s.heap_len&&smaller(tree,s.heap[j+1],s.heap[j],s.depth)&&j++,!smaller(tree,v,s.heap[j],s.depth));)s.heap[k]=s.heap[j],k=j,j<<=1;s.heap[k]=v},compress_block=(s,ltree,dtree)=>{let dist,lc,code,extra,sx=0;if(0!==s.sym_next)do{dist=255&s.pending_buf[s.sym_buf+sx++],dist+=(255&s.pending_buf[s.sym_buf+sx++])<<8,lc=s.pending_buf[s.sym_buf+sx++],0===dist?send_code(s,lc,ltree):(code=_length_code[lc],send_code(s,code+256+1,ltree),extra=extra_lbits[code],0!==extra&&(lc-=base_length[code],send_bits(s,lc,extra)),dist--,code=d_code(dist),send_code(s,code,dtree),extra=extra_dbits[code],0!==extra&&(dist-=base_dist[code],send_bits(s,dist,extra)))}while(sx<s.sym_next);send_code(s,256,ltree)},build_tree=(s,desc)=>{const tree=desc.dyn_tree,stree=desc.stat_desc.static_tree,has_stree=desc.stat_desc.has_stree,elems=desc.stat_desc.elems;let n,m,node,max_code=-1;for(s.heap_len=0,s.heap_max=573,n=0;n<elems;n++)0!==tree[2*n]?(s.heap[++s.heap_len]=max_code=n,s.depth[n]=0):tree[2*n+1]=0;for(;s.heap_len<2;)node=s.heap[++s.heap_len]=max_code<2?++max_code:0,tree[2*node]=1,s.depth[node]=0,s.opt_len--,has_stree&&(s.static_len-=stree[2*node+1]);for(desc.max_code=max_code,n=s.heap_len>>1;n>=1;n--)pqdownheap(s,tree,n);node=elems;do{n=s.heap[1],s.heap[1]=s.heap[s.heap_len--],pqdownheap(s,tree,1),m=s.heap[1],s.heap[--s.heap_max]=n,s.heap[--s.heap_max]=m,tree[2*node]=tree[2*n]+tree[2*m],s.depth[node]=(s.depth[n]>=s.depth[m]?s.depth[n]:s.depth[m])+1,tree[2*n+1]=tree[2*m+1]=node,s.heap[1]=node++,pqdownheap(s,tree,1)}while(s.heap_len>=2);s.heap[--s.heap_max]=s.heap[1],((s,desc)=>{const tree=desc.dyn_tree,max_code=desc.max_code,stree=desc.stat_desc.static_tree,has_stree=desc.stat_desc.has_stree,extra=desc.stat_desc.extra_bits,base=desc.stat_desc.extra_base,max_length=desc.stat_desc.max_length;let h,n,m,bits,xbits,f,overflow=0;for(bits=0;bits<=15;bits++)s.bl_count[bits]=0;for(tree[2*s.heap[s.heap_max]+1]=0,h=s.heap_max+1;h<573;h++)n=s.heap[h],bits=tree[2*tree[2*n+1]+1]+1,bits>max_length&&(bits=max_length,overflow++),tree[2*n+1]=bits,n>max_code||(s.bl_count[bits]++,xbits=0,n>=base&&(xbits=extra[n-base]),f=tree[2*n],s.opt_len+=f*(bits+xbits),has_stree&&(s.static_len+=f*(stree[2*n+1]+xbits)));if(0!==overflow){do{for(bits=max_length-1;0===s.bl_count[bits];)bits--;s.bl_count[bits]--,s.bl_count[bits+1]+=2,s.bl_count[max_length]--,overflow-=2}while(overflow>0);for(bits=max_length;0!==bits;bits--)for(n=s.bl_count[bits];0!==n;)m=s.heap[--h],m>max_code||(tree[2*m+1]!==bits&&(s.opt_len+=(bits-tree[2*m+1])*tree[2*m],tree[2*m+1]=bits),n--)}})(s,desc),gen_codes(tree,max_code,s.bl_count)},scan_tree=(s,tree,max_code)=>{let n,curlen,prevlen=-1,nextlen=tree[1],count=0,max_count=7,min_count=4;for(0===nextlen&&(max_count=138,min_count=3),tree[2*(max_code+1)+1]=65535,n=0;n<=max_code;n++)curlen=nextlen,nextlen=tree[2*(n+1)+1],++count<max_count&&curlen===nextlen||(count<min_count?s.bl_tree[2*curlen]+=count:0!==curlen?(curlen!==prevlen&&s.bl_tree[2*curlen]++,s.bl_tree[32]++):count<=10?s.bl_tree[34]++:s.bl_tree[36]++,count=0,prevlen=curlen,0===nextlen?(max_count=138,min_count=3):curlen===nextlen?(max_count=6,min_count=3):(max_count=7,min_count=4))},send_tree=(s,tree,max_code)=>{let n,curlen,prevlen=-1,nextlen=tree[1],count=0,max_count=7,min_count=4;for(0===nextlen&&(max_count=138,min_count=3),n=0;n<=max_code;n++)if(curlen=nextlen,nextlen=tree[2*(n+1)+1],!(++count<max_count&&curlen===nextlen)){if(count<min_count)do{send_code(s,curlen,s.bl_tree)}while(0!=--count);else 0!==curlen?(curlen!==prevlen&&(send_code(s,curlen,s.bl_tree),count--),send_code(s,16,s.bl_tree),send_bits(s,count-3,2)):count<=10?(send_code(s,17,s.bl_tree),send_bits(s,count-3,3)):(send_code(s,18,s.bl_tree),send_bits(s,count-11,7));count=0,prevlen=curlen,0===nextlen?(max_count=138,min_count=3):curlen===nextlen?(max_count=6,min_count=3):(max_count=7,min_count=4)}};let static_init_done=!1;const _tr_stored_block$1=(s,buf,stored_len,last)=>{send_bits(s,0+(last?1:0),3),bi_windup(s),put_short(s,stored_len),put_short(s,~stored_len),stored_len&&s.pending_buf.set(s.window.subarray(buf,buf+stored_len),s.pending),s.pending+=stored_len};var _tr_flush_block_1=(s,buf,stored_len,last)=>{let opt_lenb,static_lenb,max_blindex=0;s.level>0?(2===s.strm.data_type&&(s.strm.data_type=(s=>{let n,block_mask=4093624447;for(n=0;n<=31;n++,block_mask>>>=1)if(1&block_mask&&0!==s.dyn_ltree[2*n])return 0;if(0!==s.dyn_ltree[18]||0!==s.dyn_ltree[20]||0!==s.dyn_ltree[26])return 1;for(n=32;n<256;n++)if(0!==s.dyn_ltree[2*n])return 1;return 0})(s)),build_tree(s,s.l_desc),build_tree(s,s.d_desc),max_blindex=(s=>{let max_blindex;for(scan_tree(s,s.dyn_ltree,s.l_desc.max_code),scan_tree(s,s.dyn_dtree,s.d_desc.max_code),build_tree(s,s.bl_desc),max_blindex=18;max_blindex>=3&&0===s.bl_tree[2*bl_order[max_blindex]+1];max_blindex--);return s.opt_len+=3*(max_blindex+1)+5+5+4,max_blindex})(s),opt_lenb=s.opt_len+3+7>>>3,static_lenb=s.static_len+3+7>>>3,static_lenb<=opt_lenb&&(opt_lenb=static_lenb)):opt_lenb=static_lenb=stored_len+5,stored_len+4<=opt_lenb&&-1!==buf?_tr_stored_block$1(s,buf,stored_len,last):4===s.strategy||static_lenb===opt_lenb?(send_bits(s,2+(last?1:0),3),compress_block(s,static_ltree,static_dtree)):(send_bits(s,4+(last?1:0),3),((s,lcodes,dcodes,blcodes)=>{let rank;for(send_bits(s,lcodes-257,5),send_bits(s,dcodes-1,5),send_bits(s,blcodes-4,4),rank=0;rank<blcodes;rank++)send_bits(s,s.bl_tree[2*bl_order[rank]+1],3);send_tree(s,s.dyn_ltree,lcodes-1),send_tree(s,s.dyn_dtree,dcodes-1)})(s,s.l_desc.max_code+1,s.d_desc.max_code+1,max_blindex+1),compress_block(s,s.dyn_ltree,s.dyn_dtree)),init_block(s),last&&bi_windup(s)},trees={_tr_init:s=>{static_init_done||((()=>{let n,bits,length,code,dist;const bl_count=new Array(16);for(length=0,code=0;code<28;code++)for(base_length[code]=length,n=0;n<1<<extra_lbits[code];n++)_length_code[length++]=code;for(_length_code[length-1]=code,dist=0,code=0;code<16;code++)for(base_dist[code]=dist,n=0;n<1<<extra_dbits[code];n++)_dist_code[dist++]=code;for(dist>>=7;code<30;code++)for(base_dist[code]=dist<<7,n=0;n<1<<extra_dbits[code]-7;n++)_dist_code[256+dist++]=code;for(bits=0;bits<=15;bits++)bl_count[bits]=0;for(n=0;n<=143;)static_ltree[2*n+1]=8,n++,bl_count[8]++;for(;n<=255;)static_ltree[2*n+1]=9,n++,bl_count[9]++;for(;n<=279;)static_ltree[2*n+1]=7,n++,bl_count[7]++;for(;n<=287;)static_ltree[2*n+1]=8,n++,bl_count[8]++;for(gen_codes(static_ltree,287,bl_count),n=0;n<30;n++)static_dtree[2*n+1]=5,static_dtree[2*n]=bi_reverse(n,5);static_l_desc=new StaticTreeDesc(static_ltree,extra_lbits,257,286,15),static_d_desc=new StaticTreeDesc(static_dtree,extra_dbits,0,30,15),static_bl_desc=new StaticTreeDesc(new Array(0),extra_blbits,0,19,7)})(),static_init_done=!0),s.l_desc=new TreeDesc(s.dyn_ltree,static_l_desc),s.d_desc=new TreeDesc(s.dyn_dtree,static_d_desc),s.bl_desc=new TreeDesc(s.bl_tree,static_bl_desc),s.bi_buf=0,s.bi_valid=0,init_block(s)},_tr_stored_block:_tr_stored_block$1,_tr_flush_block:_tr_flush_block_1,_tr_tally:(s,dist,lc)=>(s.pending_buf[s.sym_buf+s.sym_next++]=dist,s.pending_buf[s.sym_buf+s.sym_next++]=dist>>8,s.pending_buf[s.sym_buf+s.sym_next++]=lc,0===dist?s.dyn_ltree[2*lc]++:(s.matches++,dist--,s.dyn_ltree[2*(_length_code[lc]+256+1)]++,s.dyn_dtree[2*d_code(dist)]++),s.sym_next===s.sym_end),_tr_align:s=>{send_bits(s,2,3),send_code(s,256,static_ltree),(s=>{16===s.bi_valid?(put_short(s,s.bi_buf),s.bi_buf=0,s.bi_valid=0):s.bi_valid>=8&&(s.pending_buf[s.pending++]=255&s.bi_buf,s.bi_buf>>=8,s.bi_valid-=8)})(s)}};var adler32_1=(adler,buf,len,pos)=>{let s1=65535&adler,s2=adler>>>16&65535,n=0;for(;0!==len;){n=len>2e3?2e3:len,len-=n;do{s1=s1+buf[pos++]|0,s2=s2+s1|0}while(--n);s1%=65521,s2%=65521}return s1|s2<<16};const crcTable=new Uint32Array((()=>{let c,table=[];for(var n=0;n<256;n++){c=n;for(var k=0;k<8;k++)c=1&c?3988292384^c>>>1:c>>>1;table[n]=c}return table})());var crc32_1=(crc,buf,len,pos)=>{const t=crcTable,end=pos+len;crc^=-1;for(let i=pos;i<end;i++)crc=crc>>>8^t[255&(crc^buf[i])];return~crc},messages={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},constants$2={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init,_tr_stored_block,_tr_flush_block,_tr_tally,_tr_align}=trees,{Z_NO_FLUSH:Z_NO_FLUSH$2,Z_PARTIAL_FLUSH,Z_FULL_FLUSH:Z_FULL_FLUSH$1,Z_FINISH:Z_FINISH$3,Z_BLOCK:Z_BLOCK$1,Z_OK:Z_OK$3,Z_STREAM_END:Z_STREAM_END$3,Z_STREAM_ERROR:Z_STREAM_ERROR$2,Z_DATA_ERROR:Z_DATA_ERROR$2,Z_BUF_ERROR:Z_BUF_ERROR$1,Z_DEFAULT_COMPRESSION:Z_DEFAULT_COMPRESSION$1,Z_FILTERED,Z_HUFFMAN_ONLY,Z_RLE,Z_FIXED,Z_DEFAULT_STRATEGY:Z_DEFAULT_STRATEGY$1,Z_UNKNOWN,Z_DEFLATED:Z_DEFLATED$2}=constants$2,err=(strm,errorCode)=>(strm.msg=messages[errorCode],errorCode),rank=f=>2*f-(f>4?9:0),zero=buf=>{let len=buf.length;for(;--len>=0;)buf[len]=0},slide_hash=s=>{let n,m,p,wsize=s.w_size;n=s.hash_size,p=n;do{m=s.head[--p],s.head[p]=m>=wsize?m-wsize:0}while(--n);n=wsize,p=n;do{m=s.prev[--p],s.prev[p]=m>=wsize?m-wsize:0}while(--n)};let HASH=(s,prev,data)=>(prev<<s.hash_shift^data)&s.hash_mask;const flush_pending=strm=>{const s=strm.state;let len=s.pending;len>strm.avail_out&&(len=strm.avail_out),0!==len&&(strm.output.set(s.pending_buf.subarray(s.pending_out,s.pending_out+len),strm.next_out),strm.next_out+=len,s.pending_out+=len,strm.total_out+=len,strm.avail_out-=len,s.pending-=len,0===s.pending&&(s.pending_out=0))},flush_block_only=(s,last)=>{_tr_flush_block(s,s.block_start>=0?s.block_start:-1,s.strstart-s.block_start,last),s.block_start=s.strstart,flush_pending(s.strm)},put_byte=(s,b)=>{s.pending_buf[s.pending++]=b},putShortMSB=(s,b)=>{s.pending_buf[s.pending++]=b>>>8&255,s.pending_buf[s.pending++]=255&b},read_buf=(strm,buf,start,size)=>{let len=strm.avail_in;return len>size&&(len=size),0===len?0:(strm.avail_in-=len,buf.set(strm.input.subarray(strm.next_in,strm.next_in+len),start),1===strm.state.wrap?strm.adler=adler32_1(strm.adler,buf,len,start):2===strm.state.wrap&&(strm.adler=crc32_1(strm.adler,buf,len,start)),strm.next_in+=len,strm.total_in+=len,len)},longest_match=(s,cur_match)=>{let match,len,chain_length=s.max_chain_length,scan=s.strstart,best_len=s.prev_length,nice_match=s.nice_match;const limit=s.strstart>s.w_size-262?s.strstart-(s.w_size-262):0,_win=s.window,wmask=s.w_mask,prev=s.prev,strend=s.strstart+258;let scan_end1=_win[scan+best_len-1],scan_end=_win[scan+best_len];s.prev_length>=s.good_match&&(chain_length>>=2),nice_match>s.lookahead&&(nice_match=s.lookahead);do{if(match=cur_match,_win[match+best_len]===scan_end&&_win[match+best_len-1]===scan_end1&&_win[match]===_win[scan]&&_win[++match]===_win[scan+1]){scan+=2,match++;do{}while(_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&scan<strend);if(len=258-(strend-scan),scan=strend-258,len>best_len){if(s.match_start=cur_match,best_len=len,len>=nice_match)break;scan_end1=_win[scan+best_len-1],scan_end=_win[scan+best_len]}}}while((cur_match=prev[cur_match&wmask])>limit&&0!=--chain_length);return best_len<=s.lookahead?best_len:s.lookahead},fill_window=s=>{const _w_size=s.w_size;let n,more,str;do{if(more=s.window_size-s.lookahead-s.strstart,s.strstart>=_w_size+(_w_size-262)&&(s.window.set(s.window.subarray(_w_size,_w_size+_w_size-more),0),s.match_start-=_w_size,s.strstart-=_w_size,s.block_start-=_w_size,s.insert>s.strstart&&(s.insert=s.strstart),slide_hash(s),more+=_w_size),0===s.strm.avail_in)break;if(n=read_buf(s.strm,s.window,s.strstart+s.lookahead,more),s.lookahead+=n,s.lookahead+s.insert>=3)for(str=s.strstart-s.insert,s.ins_h=s.window[str],s.ins_h=HASH(s,s.ins_h,s.window[str+1]);s.insert&&(s.ins_h=HASH(s,s.ins_h,s.window[str+3-1]),s.prev[str&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=str,str++,s.insert--,!(s.lookahead+s.insert<3)););}while(s.lookahead<262&&0!==s.strm.avail_in)},deflate_stored=(s,flush)=>{let len,left,have,min_block=s.pending_buf_size-5>s.w_size?s.w_size:s.pending_buf_size-5,last=0,used=s.strm.avail_in;do{if(len=65535,have=s.bi_valid+42>>3,s.strm.avail_out<have)break;if(have=s.strm.avail_out-have,left=s.strstart-s.block_start,len>left+s.strm.avail_in&&(len=left+s.strm.avail_in),len>have&&(len=have),len<min_block&&(0===len&&flush!==Z_FINISH$3||flush===Z_NO_FLUSH$2||len!==left+s.strm.avail_in))break;last=flush===Z_FINISH$3&&len===left+s.strm.avail_in?1:0,_tr_stored_block(s,0,0,last),s.pending_buf[s.pending-4]=len,s.pending_buf[s.pending-3]=len>>8,s.pending_buf[s.pending-2]=~len,s.pending_buf[s.pending-1]=~len>>8,flush_pending(s.strm),left&&(left>len&&(left=len),s.strm.output.set(s.window.subarray(s.block_start,s.block_start+left),s.strm.next_out),s.strm.next_out+=left,s.strm.avail_out-=left,s.strm.total_out+=left,s.block_start+=left,len-=left),len&&(read_buf(s.strm,s.strm.output,s.strm.next_out,len),s.strm.next_out+=len,s.strm.avail_out-=len,s.strm.total_out+=len)}while(0===last);return used-=s.strm.avail_in,used&&(used>=s.w_size?(s.matches=2,s.window.set(s.strm.input.subarray(s.strm.next_in-s.w_size,s.strm.next_in),0),s.strstart=s.w_size,s.insert=s.strstart):(s.window_size-s.strstart<=used&&(s.strstart-=s.w_size,s.window.set(s.window.subarray(s.w_size,s.w_size+s.strstart),0),s.matches<2&&s.matches++,s.insert>s.strstart&&(s.insert=s.strstart)),s.window.set(s.strm.input.subarray(s.strm.next_in-used,s.strm.next_in),s.strstart),s.strstart+=used,s.insert+=used>s.w_size-s.insert?s.w_size-s.insert:used),s.block_start=s.strstart),s.high_water<s.strstart&&(s.high_water=s.strstart),last?4:flush!==Z_NO_FLUSH$2&&flush!==Z_FINISH$3&&0===s.strm.avail_in&&s.strstart===s.block_start?2:(have=s.window_size-s.strstart,s.strm.avail_in>have&&s.block_start>=s.w_size&&(s.block_start-=s.w_size,s.strstart-=s.w_size,s.window.set(s.window.subarray(s.w_size,s.w_size+s.strstart),0),s.matches<2&&s.matches++,have+=s.w_size,s.insert>s.strstart&&(s.insert=s.strstart)),have>s.strm.avail_in&&(have=s.strm.avail_in),have&&(read_buf(s.strm,s.window,s.strstart,have),s.strstart+=have,s.insert+=have>s.w_size-s.insert?s.w_size-s.insert:have),s.high_water<s.strstart&&(s.high_water=s.strstart),have=s.bi_valid+42>>3,have=s.pending_buf_size-have>65535?65535:s.pending_buf_size-have,min_block=have>s.w_size?s.w_size:have,left=s.strstart-s.block_start,(left>=min_block||(left||flush===Z_FINISH$3)&&flush!==Z_NO_FLUSH$2&&0===s.strm.avail_in&&left<=have)&&(len=left>have?have:left,last=flush===Z_FINISH$3&&0===s.strm.avail_in&&len===left?1:0,_tr_stored_block(s,s.block_start,len,last),s.block_start+=len,flush_pending(s.strm)),last?3:1)},deflate_fast=(s,flush)=>{let hash_head,bflush;for(;;){if(s.lookahead<262){if(fill_window(s),s.lookahead<262&&flush===Z_NO_FLUSH$2)return 1;if(0===s.lookahead)break}if(hash_head=0,s.lookahead>=3&&(s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+3-1]),hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart),0!==hash_head&&s.strstart-hash_head<=s.w_size-262&&(s.match_length=longest_match(s,hash_head)),s.match_length>=3)if(bflush=_tr_tally(s,s.strstart-s.match_start,s.match_length-3),s.lookahead-=s.match_length,s.match_length<=s.max_lazy_match&&s.lookahead>=3){s.match_length--;do{s.strstart++,s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+3-1]),hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart}while(0!=--s.match_length);s.strstart++}else s.strstart+=s.match_length,s.match_length=0,s.ins_h=s.window[s.strstart],s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+1]);else bflush=_tr_tally(s,0,s.window[s.strstart]),s.lookahead--,s.strstart++;if(bflush&&(flush_block_only(s,!1),0===s.strm.avail_out))return 1}return s.insert=s.strstart<2?s.strstart:2,flush===Z_FINISH$3?(flush_block_only(s,!0),0===s.strm.avail_out?3:4):s.sym_next&&(flush_block_only(s,!1),0===s.strm.avail_out)?1:2},deflate_slow=(s,flush)=>{let hash_head,bflush,max_insert;for(;;){if(s.lookahead<262){if(fill_window(s),s.lookahead<262&&flush===Z_NO_FLUSH$2)return 1;if(0===s.lookahead)break}if(hash_head=0,s.lookahead>=3&&(s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+3-1]),hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart),s.prev_length=s.match_length,s.prev_match=s.match_start,s.match_length=2,0!==hash_head&&s.prev_length<s.max_lazy_match&&s.strstart-hash_head<=s.w_size-262&&(s.match_length=longest_match(s,hash_head),s.match_length<=5&&(s.strategy===Z_FILTERED||3===s.match_length&&s.strstart-s.match_start>4096)&&(s.match_length=2)),s.prev_length>=3&&s.match_length<=s.prev_length){max_insert=s.strstart+s.lookahead-3,bflush=_tr_tally(s,s.strstart-1-s.prev_match,s.prev_length-3),s.lookahead-=s.prev_length-1,s.prev_length-=2;do{++s.strstart<=max_insert&&(s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+3-1]),hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=s.strstart)}while(0!=--s.prev_length);if(s.match_available=0,s.match_length=2,s.strstart++,bflush&&(flush_block_only(s,!1),0===s.strm.avail_out))return 1}else if(s.match_available){if(bflush=_tr_tally(s,0,s.window[s.strstart-1]),bflush&&flush_block_only(s,!1),s.strstart++,s.lookahead--,0===s.strm.avail_out)return 1}else s.match_available=1,s.strstart++,s.lookahead--}return s.match_available&&(bflush=_tr_tally(s,0,s.window[s.strstart-1]),s.match_available=0),s.insert=s.strstart<2?s.strstart:2,flush===Z_FINISH$3?(flush_block_only(s,!0),0===s.strm.avail_out?3:4):s.sym_next&&(flush_block_only(s,!1),0===s.strm.avail_out)?1:2};function Config(good_length,max_lazy,nice_length,max_chain,func){this.good_length=good_length,this.max_lazy=max_lazy,this.nice_length=nice_length,this.max_chain=max_chain,this.func=func}const configuration_table=[new Config(0,0,0,0,deflate_stored),new Config(4,4,8,4,deflate_fast),new Config(4,5,16,8,deflate_fast),new Config(4,6,32,32,deflate_fast),new Config(4,4,16,16,deflate_slow),new Config(8,16,32,32,deflate_slow),new Config(8,16,128,128,deflate_slow),new Config(8,32,128,256,deflate_slow),new Config(32,128,258,1024,deflate_slow),new Config(32,258,258,4096,deflate_slow)];function DeflateState(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Z_DEFLATED$2,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(1146),this.dyn_dtree=new Uint16Array(122),this.bl_tree=new Uint16Array(78),zero(this.dyn_ltree),zero(this.dyn_dtree),zero(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(16),this.heap=new Uint16Array(573),zero(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(573),zero(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}const deflateStateCheck=strm=>{if(!strm)return 1;const s=strm.state;return!s||s.strm!==strm||42!==s.status&&57!==s.status&&69!==s.status&&73!==s.status&&91!==s.status&&103!==s.status&&113!==s.status&&666!==s.status?1:0},deflateResetKeep=strm=>{if(deflateStateCheck(strm))return err(strm,Z_STREAM_ERROR$2);strm.total_in=strm.total_out=0,strm.data_type=Z_UNKNOWN;const s=strm.state;return s.pending=0,s.pending_out=0,s.wrap<0&&(s.wrap=-s.wrap),s.status=2===s.wrap?57:s.wrap?42:113,strm.adler=2===s.wrap?0:1,s.last_flush=-2,_tr_init(s),Z_OK$3},deflateReset=strm=>{const ret=deflateResetKeep(strm);var s;return ret===Z_OK$3&&((s=strm.state).window_size=2*s.w_size,zero(s.head),s.max_lazy_match=configuration_table[s.level].max_lazy,s.good_match=configuration_table[s.level].good_length,s.nice_match=configuration_table[s.level].nice_length,s.max_chain_length=configuration_table[s.level].max_chain,s.strstart=0,s.block_start=0,s.lookahead=0,s.insert=0,s.match_length=s.prev_length=2,s.match_available=0,s.ins_h=0),ret},deflateInit2=(strm,level,method,windowBits,memLevel,strategy)=>{if(!strm)return Z_STREAM_ERROR$2;let wrap=1;if(level===Z_DEFAULT_COMPRESSION$1&&(level=6),windowBits<0?(wrap=0,windowBits=-windowBits):windowBits>15&&(wrap=2,windowBits-=16),memLevel<1||memLevel>9||method!==Z_DEFLATED$2||windowBits<8||windowBits>15||level<0||level>9||strategy<0||strategy>Z_FIXED||8===windowBits&&1!==wrap)return err(strm,Z_STREAM_ERROR$2);8===windowBits&&(windowBits=9);const s=new DeflateState;return strm.state=s,s.strm=strm,s.status=42,s.wrap=wrap,s.gzhead=null,s.w_bits=windowBits,s.w_size=1<<s.w_bits,s.w_mask=s.w_size-1,s.hash_bits=memLevel+7,s.hash_size=1<<s.hash_bits,s.hash_mask=s.hash_size-1,s.hash_shift=~~((s.hash_bits+3-1)/3),s.window=new Uint8Array(2*s.w_size),s.head=new Uint16Array(s.hash_size),s.prev=new Uint16Array(s.w_size),s.lit_bufsize=1<<memLevel+6,s.pending_buf_size=4*s.lit_bufsize,s.pending_buf=new Uint8Array(s.pending_buf_size),s.sym_buf=s.lit_bufsize,s.sym_end=3*(s.lit_bufsize-1),s.level=level,s.strategy=strategy,s.method=method,deflateReset(strm)};var deflate_1$2={deflateInit:(strm,level)=>deflateInit2(strm,level,Z_DEFLATED$2,15,8,Z_DEFAULT_STRATEGY$1),deflateInit2,deflateReset,deflateResetKeep,deflateSetHeader:(strm,head)=>deflateStateCheck(strm)||2!==strm.state.wrap?Z_STREAM_ERROR$2:(strm.state.gzhead=head,Z_OK$3),deflate:(strm,flush)=>{if(deflateStateCheck(strm)||flush>Z_BLOCK$1||flush<0)return strm?err(strm,Z_STREAM_ERROR$2):Z_STREAM_ERROR$2;const s=strm.state;if(!strm.output||0!==strm.avail_in&&!strm.input||666===s.status&&flush!==Z_FINISH$3)return err(strm,0===strm.avail_out?Z_BUF_ERROR$1:Z_STREAM_ERROR$2);const old_flush=s.last_flush;if(s.last_flush=flush,0!==s.pending){if(flush_pending(strm),0===strm.avail_out)return s.last_flush=-1,Z_OK$3}else if(0===strm.avail_in&&rank(flush)<=rank(old_flush)&&flush!==Z_FINISH$3)return err(strm,Z_BUF_ERROR$1);if(666===s.status&&0!==strm.avail_in)return err(strm,Z_BUF_ERROR$1);if(42===s.status&&0===s.wrap&&(s.status=113),42===s.status){let header=Z_DEFLATED$2+(s.w_bits-8<<4)<<8,level_flags=-1;if(level_flags=s.strategy>=Z_HUFFMAN_ONLY||s.level<2?0:s.level<6?1:6===s.level?2:3,header|=level_flags<<6,0!==s.strstart&&(header|=32),header+=31-header%31,putShortMSB(s,header),0!==s.strstart&&(putShortMSB(s,strm.adler>>>16),putShortMSB(s,65535&strm.adler)),strm.adler=1,s.status=113,flush_pending(strm),0!==s.pending)return s.last_flush=-1,Z_OK$3}if(57===s.status)if(strm.adler=0,put_byte(s,31),put_byte(s,139),put_byte(s,8),s.gzhead)put_byte(s,(s.gzhead.text?1:0)+(s.gzhead.hcrc?2:0)+(s.gzhead.extra?4:0)+(s.gzhead.name?8:0)+(s.gzhead.comment?16:0)),put_byte(s,255&s.gzhead.time),put_byte(s,s.gzhead.time>>8&255),put_byte(s,s.gzhead.time>>16&255),put_byte(s,s.gzhead.time>>24&255),put_byte(s,9===s.level?2:s.strategy>=Z_HUFFMAN_ONLY||s.level<2?4:0),put_byte(s,255&s.gzhead.os),s.gzhead.extra&&s.gzhead.extra.length&&(put_byte(s,255&s.gzhead.extra.length),put_byte(s,s.gzhead.extra.length>>8&255)),s.gzhead.hcrc&&(strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending,0)),s.gzindex=0,s.status=69;else if(put_byte(s,0),put_byte(s,0),put_byte(s,0),put_byte(s,0),put_byte(s,0),put_byte(s,9===s.level?2:s.strategy>=Z_HUFFMAN_ONLY||s.level<2?4:0),put_byte(s,3),s.status=113,flush_pending(strm),0!==s.pending)return s.last_flush=-1,Z_OK$3;if(69===s.status){if(s.gzhead.extra){let beg=s.pending,left=(65535&s.gzhead.extra.length)-s.gzindex;for(;s.pending+left>s.pending_buf_size;){let copy=s.pending_buf_size-s.pending;if(s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex,s.gzindex+copy),s.pending),s.pending=s.pending_buf_size,s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending-beg,beg)),s.gzindex+=copy,flush_pending(strm),0!==s.pending)return s.last_flush=-1,Z_OK$3;beg=0,left-=copy}let gzhead_extra=new Uint8Array(s.gzhead.extra);s.pending_buf.set(gzhead_extra.subarray(s.gzindex,s.gzindex+left),s.pending),s.pending+=left,s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending-beg,beg)),s.gzindex=0}s.status=73}if(73===s.status){if(s.gzhead.name){let val,beg=s.pending;do{if(s.pending===s.pending_buf_size){if(s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending-beg,beg)),flush_pending(strm),0!==s.pending)return s.last_flush=-1,Z_OK$3;beg=0}val=s.gzindex<s.gzhead.name.length?255&s.gzhead.name.charCodeAt(s.gzindex++):0,put_byte(s,val)}while(0!==val);s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending-beg,beg)),s.gzindex=0}s.status=91}if(91===s.status){if(s.gzhead.comment){let val,beg=s.pending;do{if(s.pending===s.pending_buf_size){if(s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending-beg,beg)),flush_pending(strm),0!==s.pending)return s.last_flush=-1,Z_OK$3;beg=0}val=s.gzindex<s.gzhead.comment.length?255&s.gzhead.comment.charCodeAt(s.gzindex++):0,put_byte(s,val)}while(0!==val);s.gzhead.hcrc&&s.pending>beg&&(strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending-beg,beg))}s.status=103}if(103===s.status){if(s.gzhead.hcrc){if(s.pending+2>s.pending_buf_size&&(flush_pending(strm),0!==s.pending))return s.last_flush=-1,Z_OK$3;put_byte(s,255&strm.adler),put_byte(s,strm.adler>>8&255),strm.adler=0}if(s.status=113,flush_pending(strm),0!==s.pending)return s.last_flush=-1,Z_OK$3}if(0!==strm.avail_in||0!==s.lookahead||flush!==Z_NO_FLUSH$2&&666!==s.status){let bstate=0===s.level?deflate_stored(s,flush):s.strategy===Z_HUFFMAN_ONLY?((s,flush)=>{let bflush;for(;;){if(0===s.lookahead&&(fill_window(s),0===s.lookahead)){if(flush===Z_NO_FLUSH$2)return 1;break}if(s.match_length=0,bflush=_tr_tally(s,0,s.window[s.strstart]),s.lookahead--,s.strstart++,bflush&&(flush_block_only(s,!1),0===s.strm.avail_out))return 1}return s.insert=0,flush===Z_FINISH$3?(flush_block_only(s,!0),0===s.strm.avail_out?3:4):s.sym_next&&(flush_block_only(s,!1),0===s.strm.avail_out)?1:2})(s,flush):s.strategy===Z_RLE?((s,flush)=>{let bflush,prev,scan,strend;const _win=s.window;for(;;){if(s.lookahead<=258){if(fill_window(s),s.lookahead<=258&&flush===Z_NO_FLUSH$2)return 1;if(0===s.lookahead)break}if(s.match_length=0,s.lookahead>=3&&s.strstart>0&&(scan=s.strstart-1,prev=_win[scan],prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan])){strend=s.strstart+258;do{}while(prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&scan<strend);s.match_length=258-(strend-scan),s.match_length>s.lookahead&&(s.match_length=s.lookahead)}if(s.match_length>=3?(bflush=_tr_tally(s,1,s.match_length-3),s.lookahead-=s.match_length,s.strstart+=s.match_length,s.match_length=0):(bflush=_tr_tally(s,0,s.window[s.strstart]),s.lookahead--,s.strstart++),bflush&&(flush_block_only(s,!1),0===s.strm.avail_out))return 1}return s.insert=0,flush===Z_FINISH$3?(flush_block_only(s,!0),0===s.strm.avail_out?3:4):s.sym_next&&(flush_block_only(s,!1),0===s.strm.avail_out)?1:2})(s,flush):configuration_table[s.level].func(s,flush);if(3!==bstate&&4!==bstate||(s.status=666),1===bstate||3===bstate)return 0===strm.avail_out&&(s.last_flush=-1),Z_OK$3;if(2===bstate&&(flush===Z_PARTIAL_FLUSH?_tr_align(s):flush!==Z_BLOCK$1&&(_tr_stored_block(s,0,0,!1),flush===Z_FULL_FLUSH$1&&(zero(s.head),0===s.lookahead&&(s.strstart=0,s.block_start=0,s.insert=0))),flush_pending(strm),0===strm.avail_out))return s.last_flush=-1,Z_OK$3}return flush!==Z_FINISH$3?Z_OK$3:s.wrap<=0?Z_STREAM_END$3:(2===s.wrap?(put_byte(s,255&strm.adler),put_byte(s,strm.adler>>8&255),put_byte(s,strm.adler>>16&255),put_byte(s,strm.adler>>24&255),put_byte(s,255&strm.total_in),put_byte(s,strm.total_in>>8&255),put_byte(s,strm.total_in>>16&255),put_byte(s,strm.total_in>>24&255)):(putShortMSB(s,strm.adler>>>16),putShortMSB(s,65535&strm.adler)),flush_pending(strm),s.wrap>0&&(s.wrap=-s.wrap),0!==s.pending?Z_OK$3:Z_STREAM_END$3)},deflateEnd:strm=>{if(deflateStateCheck(strm))return Z_STREAM_ERROR$2;const status=strm.state.status;return strm.state=null,113===status?err(strm,Z_DATA_ERROR$2):Z_OK$3},deflateSetDictionary:(strm,dictionary)=>{let dictLength=dictionary.length;if(deflateStateCheck(strm))return Z_STREAM_ERROR$2;const s=strm.state,wrap=s.wrap;if(2===wrap||1===wrap&&42!==s.status||s.lookahead)return Z_STREAM_ERROR$2;if(1===wrap&&(strm.adler=adler32_1(strm.adler,dictionary,dictLength,0)),s.wrap=0,dictLength>=s.w_size){0===wrap&&(zero(s.head),s.strstart=0,s.block_start=0,s.insert=0);let tmpDict=new Uint8Array(s.w_size);tmpDict.set(dictionary.subarray(dictLength-s.w_size,dictLength),0),dictionary=tmpDict,dictLength=s.w_size}const avail=strm.avail_in,next=strm.next_in,input=strm.input;for(strm.avail_in=dictLength,strm.next_in=0,strm.input=dictionary,fill_window(s);s.lookahead>=3;){let str=s.strstart,n=s.lookahead-2;do{s.ins_h=HASH(s,s.ins_h,s.window[str+3-1]),s.prev[str&s.w_mask]=s.head[s.ins_h],s.head[s.ins_h]=str,str++}while(--n);s.strstart=str,s.lookahead=2,fill_window(s)}return s.strstart+=s.lookahead,s.block_start=s.strstart,s.insert=s.lookahead,s.lookahead=0,s.match_length=s.prev_length=2,s.match_available=0,strm.next_in=next,strm.input=input,strm.avail_in=avail,s.wrap=wrap,Z_OK$3},deflateInfo:"pako deflate (from Nodeca project)"};const _has=(obj,key)=>Object.prototype.hasOwnProperty.call(obj,key);var common_assign=function(obj){const sources=Array.prototype.slice.call(arguments,1);for(;sources.length;){const source=sources.shift();if(source){if("object"!=typeof source)throw new TypeError(source+"must be non-object");for(const p in source)_has(source,p)&&(obj[p]=source[p])}}return obj},common_flattenChunks=chunks=>{let len=0;for(let i=0,l=chunks.length;i<l;i++)len+=chunks[i].length;const result=new Uint8Array(len);for(let i=0,pos=0,l=chunks.length;i<l;i++){let chunk=chunks[i];result.set(chunk,pos),pos+=chunk.length}return result};let STR_APPLY_UIA_OK=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(__){STR_APPLY_UIA_OK=!1}const _utf8len=new Uint8Array(256);for(let q=0;q<256;q++)_utf8len[q]=q>=252?6:q>=248?5:q>=240?4:q>=224?3:q>=192?2:1;_utf8len[254]=_utf8len[254]=1;var strings_string2buf=str=>{if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(str);let buf,c,c2,m_pos,i,str_len=str.length,buf_len=0;for(m_pos=0;m_pos<str_len;m_pos++)c=str.charCodeAt(m_pos),55296==(64512&c)&&m_pos+1<str_len&&(c2=str.charCodeAt(m_pos+1),56320==(64512&c2)&&(c=65536+(c-55296<<10)+(c2-56320),m_pos++)),buf_len+=c<128?1:c<2048?2:c<65536?3:4;for(buf=new Uint8Array(buf_len),i=0,m_pos=0;i<buf_len;m_pos++)c=str.charCodeAt(m_pos),55296==(64512&c)&&m_pos+1<str_len&&(c2=str.charCodeAt(m_pos+1),56320==(64512&c2)&&(c=65536+(c-55296<<10)+(c2-56320),m_pos++)),c<128?buf[i++]=c:c<2048?(buf[i++]=192|c>>>6,buf[i++]=128|63&c):c<65536?(buf[i++]=224|c>>>12,buf[i++]=128|c>>>6&63,buf[i++]=128|63&c):(buf[i++]=240|c>>>18,buf[i++]=128|c>>>12&63,buf[i++]=128|c>>>6&63,buf[i++]=128|63&c);return buf},strings_buf2string=(buf,max)=>{const len=max||buf.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(buf.subarray(0,max));let i,out;const utf16buf=new Array(2*len);for(out=0,i=0;i<len;){let c=buf[i++];if(c<128){utf16buf[out++]=c;continue}let c_len=_utf8len[c];if(c_len>4)utf16buf[out++]=65533,i+=c_len-1;else{for(c&=2===c_len?31:3===c_len?15:7;c_len>1&&i<len;)c=c<<6|63&buf[i++],c_len--;c_len>1?utf16buf[out++]=65533:c<65536?utf16buf[out++]=c:(c-=65536,utf16buf[out++]=55296|c>>10&1023,utf16buf[out++]=56320|1023&c)}}return((buf,len)=>{if(len<65534&&buf.subarray&&STR_APPLY_UIA_OK)return String.fromCharCode.apply(null,buf.length===len?buf:buf.subarray(0,len));let result="";for(let i=0;i<len;i++)result+=String.fromCharCode(buf[i]);return result})(utf16buf,out)},strings_utf8border=(buf,max)=>{(max=max||buf.length)>buf.length&&(max=buf.length);let pos=max-1;for(;pos>=0&&128==(192&buf[pos]);)pos--;return pos<0||0===pos?max:pos+_utf8len[buf[pos]]>max?pos:max};var zstream=function ZStream(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0};const toString$1=Object.prototype.toString,{Z_NO_FLUSH:Z_NO_FLUSH$1,Z_SYNC_FLUSH,Z_FULL_FLUSH,Z_FINISH:Z_FINISH$2,Z_OK:Z_OK$2,Z_STREAM_END:Z_STREAM_END$2,Z_DEFAULT_COMPRESSION,Z_DEFAULT_STRATEGY,Z_DEFLATED:Z_DEFLATED$1}=constants$2;function Deflate$1(options){this.options=common_assign({level:Z_DEFAULT_COMPRESSION,method:Z_DEFLATED$1,chunkSize:16384,windowBits:15,memLevel:8,strategy:Z_DEFAULT_STRATEGY},options||{});let opt=this.options;opt.raw&&opt.windowBits>0?opt.windowBits=-opt.windowBits:opt.gzip&&opt.windowBits>0&&opt.windowBits<16&&(opt.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new zstream,this.strm.avail_out=0;let status=deflate_1$2.deflateInit2(this.strm,opt.level,opt.method,opt.windowBits,opt.memLevel,opt.strategy);if(status!==Z_OK$2)throw new Error(messages[status]);if(opt.header&&deflate_1$2.deflateSetHeader(this.strm,opt.header),opt.dictionary){let dict;if(dict="string"==typeof opt.dictionary?strings_string2buf(opt.dictionary):"[object ArrayBuffer]"===toString$1.call(opt.dictionary)?new Uint8Array(opt.dictionary):opt.dictionary,status=deflate_1$2.deflateSetDictionary(this.strm,dict),status!==Z_OK$2)throw new Error(messages[status]);this._dict_set=!0}}function deflate$1(input,options){const deflator=new Deflate$1(options);if(deflator.push(input,!0),deflator.err)throw deflator.msg||messages[deflator.err];return deflator.result}Deflate$1.prototype.push=function(data,flush_mode){const strm=this.strm,chunkSize=this.options.chunkSize;let status,_flush_mode;if(this.ended)return!1;for(_flush_mode=flush_mode===~~flush_mode?flush_mode:!0===flush_mode?Z_FINISH$2:Z_NO_FLUSH$1,"string"==typeof data?strm.input=strings_string2buf(data):"[object ArrayBuffer]"===toString$1.call(data)?strm.input=new Uint8Array(data):strm.input=data,strm.next_in=0,strm.avail_in=strm.input.length;;)if(0===strm.avail_out&&(strm.output=new Uint8Array(chunkSize),strm.next_out=0,strm.avail_out=chunkSize),(_flush_mode===Z_SYNC_FLUSH||_flush_mode===Z_FULL_FLUSH)&&strm.avail_out<=6)this.onData(strm.output.subarray(0,strm.next_out)),strm.avail_out=0;else{if(status=deflate_1$2.deflate(strm,_flush_mode),status===Z_STREAM_END$2)return strm.next_out>0&&this.onData(strm.output.subarray(0,strm.next_out)),status=deflate_1$2.deflateEnd(this.strm),this.onEnd(status),this.ended=!0,status===Z_OK$2;if(0!==strm.avail_out){if(_flush_mode>0&&strm.next_out>0)this.onData(strm.output.subarray(0,strm.next_out)),strm.avail_out=0;else if(0===strm.avail_in)break}else this.onData(strm.output)}return!0},Deflate$1.prototype.onData=function(chunk){this.chunks.push(chunk)},Deflate$1.prototype.onEnd=function(status){status===Z_OK$2&&(this.result=common_flattenChunks(this.chunks)),this.chunks=[],this.err=status,this.msg=this.strm.msg};var deflate_1$1={Deflate:Deflate$1,deflate:deflate$1,deflateRaw:function deflateRaw$1(input,options){return(options=options||{}).raw=!0,deflate$1(input,options)},gzip:function gzip$1(input,options){return(options=options||{}).gzip=!0,deflate$1(input,options)},constants:constants$2};var inffast=function inflate_fast(strm,start){let _in,last,_out,beg,end,dmax,wsize,whave,wnext,s_window,hold,bits,lcode,dcode,lmask,dmask,here,op,len,dist,from,from_source,input,output;const state=strm.state;_in=strm.next_in,input=strm.input,last=_in+(strm.avail_in-5),_out=strm.next_out,output=strm.output,beg=_out-(start-strm.avail_out),end=_out+(strm.avail_out-257),dmax=state.dmax,wsize=state.wsize,whave=state.whave,wnext=state.wnext,s_window=state.window,hold=state.hold,bits=state.bits,lcode=state.lencode,dcode=state.distcode,lmask=(1<<state.lenbits)-1,dmask=(1<<state.distbits)-1;top:do{bits<15&&(hold+=input[_in++]<<bits,bits+=8,hold+=input[_in++]<<bits,bits+=8),here=lcode[hold&lmask];dolen:for(;;){if(op=here>>>24,hold>>>=op,bits-=op,op=here>>>16&255,0===op)output[_out++]=65535&here;else{if(!(16&op)){if(64&op){if(32&op){state.mode=16191;break top}strm.msg="invalid literal/length code",state.mode=16209;break top}here=lcode[(65535&here)+(hold&(1<<op)-1)];continue dolen}for(len=65535&here,op&=15,op&&(bits<op&&(hold+=input[_in++]<<bits,bits+=8),len+=hold&(1<<op)-1,hold>>>=op,bits-=op),bits<15&&(hold+=input[_in++]<<bits,bits+=8,hold+=input[_in++]<<bits,bits+=8),here=dcode[hold&dmask];;){if(op=here>>>24,hold>>>=op,bits-=op,op=here>>>16&255,16&op){if(dist=65535&here,op&=15,bits<op&&(hold+=input[_in++]<<bits,bits+=8,bits<op&&(hold+=input[_in++]<<bits,bits+=8)),dist+=hold&(1<<op)-1,dist>dmax){strm.msg="invalid distance too far back",state.mode=16209;break top}if(hold>>>=op,bits-=op,op=_out-beg,dist>op){if(op=dist-op,op>whave&&state.sane){strm.msg="invalid distance too far back",state.mode=16209;break top}if(from=0,from_source=s_window,0===wnext){if(from+=wsize-op,op<len){len-=op;do{output[_out++]=s_window[from++]}while(--op);from=_out-dist,from_source=output}}else if(wnext<op){if(from+=wsize+wnext-op,op-=wnext,op<len){len-=op;do{output[_out++]=s_window[from++]}while(--op);if(from=0,wnext<len){op=wnext,len-=op;do{output[_out++]=s_window[from++]}while(--op);from=_out-dist,from_source=output}}}else if(from+=wnext-op,op<len){len-=op;do{output[_out++]=s_window[from++]}while(--op);from=_out-dist,from_source=output}for(;len>2;)output[_out++]=from_source[from++],output[_out++]=from_source[from++],output[_out++]=from_source[from++],len-=3;len&&(output[_out++]=from_source[from++],len>1&&(output[_out++]=from_source[from++]))}else{from=_out-dist;do{output[_out++]=output[from++],output[_out++]=output[from++],output[_out++]=output[from++],len-=3}while(len>2);len&&(output[_out++]=output[from++],len>1&&(output[_out++]=output[from++]))}break}if(64&op){strm.msg="invalid distance code",state.mode=16209;break top}here=dcode[(65535&here)+(hold&(1<<op)-1)]}}break}}while(_in<last&&_out<end);len=bits>>3,_in-=len,bits-=len<<3,hold&=(1<<bits)-1,strm.next_in=_in,strm.next_out=_out,strm.avail_in=_in<last?last-_in+5:5-(_in-last),strm.avail_out=_out<end?end-_out+257:257-(_out-end),state.hold=hold,state.bits=bits};const lbase=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),lext=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),dbase=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),dext=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]);var inftrees=(type,lens,lens_index,codes,table,table_index,work,opts)=>{const bits=opts.bits;let incr,fill,low,mask,next,match,len=0,sym=0,min=0,max=0,root=0,curr=0,drop=0,left=0,used=0,huff=0,base=null;const count=new Uint16Array(16),offs=new Uint16Array(16);let here_bits,here_op,here_val,extra=null;for(len=0;len<=15;len++)count[len]=0;for(sym=0;sym<codes;sym++)count[lens[lens_index+sym]]++;for(root=bits,max=15;max>=1&&0===count[max];max--);if(root>max&&(root=max),0===max)return table[table_index++]=20971520,table[table_index++]=20971520,opts.bits=1,0;for(min=1;min<max&&0===count[min];min++);for(root<min&&(root=min),left=1,len=1;len<=15;len++)if(left<<=1,left-=count[len],left<0)return-1;if(left>0&&(0===type||1!==max))return-1;for(offs[1]=0,len=1;len<15;len++)offs[len+1]=offs[len]+count[len];for(sym=0;sym<codes;sym++)0!==lens[lens_index+sym]&&(work[offs[lens[lens_index+sym]]++]=sym);if(0===type?(base=extra=work,match=20):1===type?(base=lbase,extra=lext,match=257):(base=dbase,extra=dext,match=0),huff=0,sym=0,len=min,next=table_index,curr=root,drop=0,low=-1,used=1<<root,mask=used-1,1===type&&used>852||2===type&&used>592)return 1;for(;;){here_bits=len-drop,work[sym]+1<match?(here_op=0,here_val=work[sym]):work[sym]>=match?(here_op=extra[work[sym]-match],here_val=base[work[sym]-match]):(here_op=96,here_val=0),incr=1<<len-drop,fill=1<<curr,min=fill;do{fill-=incr,table[next+(huff>>drop)+fill]=here_bits<<24|here_op<<16|here_val}while(0!==fill);for(incr=1<<len-1;huff&incr;)incr>>=1;if(0!==incr?(huff&=incr-1,huff+=incr):huff=0,sym++,0==--count[len]){if(len===max)break;len=lens[lens_index+work[sym]]}if(len>root&&(huff&mask)!==low){for(0===drop&&(drop=root),next+=min,curr=len-drop,left=1<<curr;curr+drop<max&&(left-=count[curr+drop],!(left<=0));)curr++,left<<=1;if(used+=1<<curr,1===type&&used>852||2===type&&used>592)return 1;low=huff&mask,table[low]=root<<24|curr<<16|next-table_index}}return 0!==huff&&(table[next+huff]=len-drop<<24|64<<16),opts.bits=root,0};const{Z_FINISH:Z_FINISH$1,Z_BLOCK,Z_TREES,Z_OK:Z_OK$1,Z_STREAM_END:Z_STREAM_END$1,Z_NEED_DICT:Z_NEED_DICT$1,Z_STREAM_ERROR:Z_STREAM_ERROR$1,Z_DATA_ERROR:Z_DATA_ERROR$1,Z_MEM_ERROR:Z_MEM_ERROR$1,Z_BUF_ERROR,Z_DEFLATED}=constants$2,BAD=16209,zswap32=q=>(q>>>24&255)+(q>>>8&65280)+((65280&q)<<8)+((255&q)<<24);function InflateState(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}const inflateStateCheck=strm=>{if(!strm)return 1;const state=strm.state;return!state||state.strm!==strm||state.mode<16180||state.mode>16211?1:0},inflateResetKeep=strm=>{if(inflateStateCheck(strm))return Z_STREAM_ERROR$1;const state=strm.state;return strm.total_in=strm.total_out=state.total=0,strm.msg="",state.wrap&&(strm.adler=1&state.wrap),state.mode=16180,state.last=0,state.havedict=0,state.flags=-1,state.dmax=32768,state.head=null,state.hold=0,state.bits=0,state.lencode=state.lendyn=new Int32Array(852),state.distcode=state.distdyn=new Int32Array(592),state.sane=1,state.back=-1,Z_OK$1},inflateReset=strm=>{if(inflateStateCheck(strm))return Z_STREAM_ERROR$1;const state=strm.state;return state.wsize=0,state.whave=0,state.wnext=0,inflateResetKeep(strm)},inflateReset2=(strm,windowBits)=>{let wrap;if(inflateStateCheck(strm))return Z_STREAM_ERROR$1;const state=strm.state;return windowBits<0?(wrap=0,windowBits=-windowBits):(wrap=5+(windowBits>>4),windowBits<48&&(windowBits&=15)),windowBits&&(windowBits<8||windowBits>15)?Z_STREAM_ERROR$1:(null!==state.window&&state.wbits!==windowBits&&(state.window=null),state.wrap=wrap,state.wbits=windowBits,inflateReset(strm))},inflateInit2=(strm,windowBits)=>{if(!strm)return Z_STREAM_ERROR$1;const state=new InflateState;strm.state=state,state.strm=strm,state.window=null,state.mode=16180;const ret=inflateReset2(strm,windowBits);return ret!==Z_OK$1&&(strm.state=null),ret};let lenfix,distfix,virgin=!0;const fixedtables=state=>{if(virgin){lenfix=new Int32Array(512),distfix=new Int32Array(32);let sym=0;for(;sym<144;)state.lens[sym++]=8;for(;sym<256;)state.lens[sym++]=9;for(;sym<280;)state.lens[sym++]=7;for(;sym<288;)state.lens[sym++]=8;for(inftrees(1,state.lens,0,288,lenfix,0,state.work,{bits:9}),sym=0;sym<32;)state.lens[sym++]=5;inftrees(2,state.lens,0,32,distfix,0,state.work,{bits:5}),virgin=!1}state.lencode=lenfix,state.lenbits=9,state.distcode=distfix,state.distbits=5},updatewindow=(strm,src,end,copy)=>{let dist;const state=strm.state;return null===state.window&&(state.wsize=1<<state.wbits,state.wnext=0,state.whave=0,state.window=new Uint8Array(state.wsize)),copy>=state.wsize?(state.window.set(src.subarray(end-state.wsize,end),0),state.wnext=0,state.whave=state.wsize):(dist=state.wsize-state.wnext,dist>copy&&(dist=copy),state.window.set(src.subarray(end-copy,end-copy+dist),state.wnext),(copy-=dist)?(state.window.set(src.subarray(end-copy,end),0),state.wnext=copy,state.whave=state.wsize):(state.wnext+=dist,state.wnext===state.wsize&&(state.wnext=0),state.whave<state.wsize&&(state.whave+=dist))),0};var inflate_1$2={inflateReset,inflateReset2,inflateResetKeep,inflateInit:strm=>inflateInit2(strm,15),inflateInit2,inflate:(strm,flush)=>{let state,input,output,next,put,have,left,hold,bits,_in,_out,copy,from,from_source,here_bits,here_op,here_val,last_bits,last_op,last_val,len,ret,here=0;const hbuf=new Uint8Array(4);let opts,n;const order=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(inflateStateCheck(strm)||!strm.output||!strm.input&&0!==strm.avail_in)return Z_STREAM_ERROR$1;state=strm.state,16191===state.mode&&(state.mode=16192),put=strm.next_out,output=strm.output,left=strm.avail_out,next=strm.next_in,input=strm.input,have=strm.avail_in,hold=state.hold,bits=state.bits,_in=have,_out=left,ret=Z_OK$1;inf_leave:for(;;)switch(state.mode){case 16180:if(0===state.wrap){state.mode=16192;break}for(;bits<16;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(2&state.wrap&&35615===hold){0===state.wbits&&(state.wbits=15),state.check=0,hbuf[0]=255&hold,hbuf[1]=hold>>>8&255,state.check=crc32_1(state.check,hbuf,2,0),hold=0,bits=0,state.mode=16181;break}if(state.head&&(state.head.done=!1),!(1&state.wrap)||(((255&hold)<<8)+(hold>>8))%31){strm.msg="incorrect header check",state.mode=BAD;break}if((15&hold)!==Z_DEFLATED){strm.msg="unknown compression method",state.mode=BAD;break}if(hold>>>=4,bits-=4,len=8+(15&hold),0===state.wbits&&(state.wbits=len),len>15||len>state.wbits){strm.msg="invalid window size",state.mode=BAD;break}state.dmax=1<<state.wbits,state.flags=0,strm.adler=state.check=1,state.mode=512&hold?16189:16191,hold=0,bits=0;break;case 16181:for(;bits<16;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(state.flags=hold,(255&state.flags)!==Z_DEFLATED){strm.msg="unknown compression method",state.mode=BAD;break}if(57344&state.flags){strm.msg="unknown header flags set",state.mode=BAD;break}state.head&&(state.head.text=hold>>8&1),512&state.flags&&4&state.wrap&&(hbuf[0]=255&hold,hbuf[1]=hold>>>8&255,state.check=crc32_1(state.check,hbuf,2,0)),hold=0,bits=0,state.mode=16182;case 16182:for(;bits<32;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.head&&(state.head.time=hold),512&state.flags&&4&state.wrap&&(hbuf[0]=255&hold,hbuf[1]=hold>>>8&255,hbuf[2]=hold>>>16&255,hbuf[3]=hold>>>24&255,state.check=crc32_1(state.check,hbuf,4,0)),hold=0,bits=0,state.mode=16183;case 16183:for(;bits<16;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.head&&(state.head.xflags=255&hold,state.head.os=hold>>8),512&state.flags&&4&state.wrap&&(hbuf[0]=255&hold,hbuf[1]=hold>>>8&255,state.check=crc32_1(state.check,hbuf,2,0)),hold=0,bits=0,state.mode=16184;case 16184:if(1024&state.flags){for(;bits<16;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.length=hold,state.head&&(state.head.extra_len=hold),512&state.flags&&4&state.wrap&&(hbuf[0]=255&hold,hbuf[1]=hold>>>8&255,state.check=crc32_1(state.check,hbuf,2,0)),hold=0,bits=0}else state.head&&(state.head.extra=null);state.mode=16185;case 16185:if(1024&state.flags&&(copy=state.length,copy>have&&(copy=have),copy&&(state.head&&(len=state.head.extra_len-state.length,state.head.extra||(state.head.extra=new Uint8Array(state.head.extra_len)),state.head.extra.set(input.subarray(next,next+copy),len)),512&state.flags&&4&state.wrap&&(state.check=crc32_1(state.check,input,copy,next)),have-=copy,next+=copy,state.length-=copy),state.length))break inf_leave;state.length=0,state.mode=16186;case 16186:if(2048&state.flags){if(0===have)break inf_leave;copy=0;do{len=input[next+copy++],state.head&&len&&state.length<65536&&(state.head.name+=String.fromCharCode(len))}while(len&&copy<have);if(512&state.flags&&4&state.wrap&&(state.check=crc32_1(state.check,input,copy,next)),have-=copy,next+=copy,len)break inf_leave}else state.head&&(state.head.name=null);state.length=0,state.mode=16187;case 16187:if(4096&state.flags){if(0===have)break inf_leave;copy=0;do{len=input[next+copy++],state.head&&len&&state.length<65536&&(state.head.comment+=String.fromCharCode(len))}while(len&&copy<have);if(512&state.flags&&4&state.wrap&&(state.check=crc32_1(state.check,input,copy,next)),have-=copy,next+=copy,len)break inf_leave}else state.head&&(state.head.comment=null);state.mode=16188;case 16188:if(512&state.flags){for(;bits<16;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(4&state.wrap&&hold!==(65535&state.check)){strm.msg="header crc mismatch",state.mode=BAD;break}hold=0,bits=0}state.head&&(state.head.hcrc=state.flags>>9&1,state.head.done=!0),strm.adler=state.check=0,state.mode=16191;break;case 16189:for(;bits<32;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}strm.adler=state.check=zswap32(hold),hold=0,bits=0,state.mode=16190;case 16190:if(0===state.havedict)return strm.next_out=put,strm.avail_out=left,strm.next_in=next,strm.avail_in=have,state.hold=hold,state.bits=bits,Z_NEED_DICT$1;strm.adler=state.check=1,state.mode=16191;case 16191:if(flush===Z_BLOCK||flush===Z_TREES)break inf_leave;case 16192:if(state.last){hold>>>=7&bits,bits-=7&bits,state.mode=16206;break}for(;bits<3;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}switch(state.last=1&hold,hold>>>=1,bits-=1,3&hold){case 0:state.mode=16193;break;case 1:if(fixedtables(state),state.mode=16199,flush===Z_TREES){hold>>>=2,bits-=2;break inf_leave}break;case 2:state.mode=16196;break;case 3:strm.msg="invalid block type",state.mode=BAD}hold>>>=2,bits-=2;break;case 16193:for(hold>>>=7&bits,bits-=7&bits;bits<32;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if((65535&hold)!=(hold>>>16^65535)){strm.msg="invalid stored block lengths",state.mode=BAD;break}if(state.length=65535&hold,hold=0,bits=0,state.mode=16194,flush===Z_TREES)break inf_leave;case 16194:state.mode=16195;case 16195:if(copy=state.length,copy){if(copy>have&&(copy=have),copy>left&&(copy=left),0===copy)break inf_leave;output.set(input.subarray(next,next+copy),put),have-=copy,next+=copy,left-=copy,put+=copy,state.length-=copy;break}state.mode=16191;break;case 16196:for(;bits<14;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(state.nlen=257+(31&hold),hold>>>=5,bits-=5,state.ndist=1+(31&hold),hold>>>=5,bits-=5,state.ncode=4+(15&hold),hold>>>=4,bits-=4,state.nlen>286||state.ndist>30){strm.msg="too many length or distance symbols",state.mode=BAD;break}state.have=0,state.mode=16197;case 16197:for(;state.have<state.ncode;){for(;bits<3;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.lens[order[state.have++]]=7&hold,hold>>>=3,bits-=3}for(;state.have<19;)state.lens[order[state.have++]]=0;if(state.lencode=state.lendyn,state.lenbits=7,opts={bits:state.lenbits},ret=inftrees(0,state.lens,0,19,state.lencode,0,state.work,opts),state.lenbits=opts.bits,ret){strm.msg="invalid code lengths set",state.mode=BAD;break}state.have=0,state.mode=16198;case 16198:for(;state.have<state.nlen+state.ndist;){for(;here=state.lencode[hold&(1<<state.lenbits)-1],here_bits=here>>>24,here_op=here>>>16&255,here_val=65535&here,!(here_bits<=bits);){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(here_val<16)hold>>>=here_bits,bits-=here_bits,state.lens[state.have++]=here_val;else{if(16===here_val){for(n=here_bits+2;bits<n;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(hold>>>=here_bits,bits-=here_bits,0===state.have){strm.msg="invalid bit length repeat",state.mode=BAD;break}len=state.lens[state.have-1],copy=3+(3&hold),hold>>>=2,bits-=2}else if(17===here_val){for(n=here_bits+3;bits<n;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}hold>>>=here_bits,bits-=here_bits,len=0,copy=3+(7&hold),hold>>>=3,bits-=3}else{for(n=here_bits+7;bits<n;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}hold>>>=here_bits,bits-=here_bits,len=0,copy=11+(127&hold),hold>>>=7,bits-=7}if(state.have+copy>state.nlen+state.ndist){strm.msg="invalid bit length repeat",state.mode=BAD;break}for(;copy--;)state.lens[state.have++]=len}}if(state.mode===BAD)break;if(0===state.lens[256]){strm.msg="invalid code -- missing end-of-block",state.mode=BAD;break}if(state.lenbits=9,opts={bits:state.lenbits},ret=inftrees(1,state.lens,0,state.nlen,state.lencode,0,state.work,opts),state.lenbits=opts.bits,ret){strm.msg="invalid literal/lengths set",state.mode=BAD;break}if(state.distbits=6,state.distcode=state.distdyn,opts={bits:state.distbits},ret=inftrees(2,state.lens,state.nlen,state.ndist,state.distcode,0,state.work,opts),state.distbits=opts.bits,ret){strm.msg="invalid distances set",state.mode=BAD;break}if(state.mode=16199,flush===Z_TREES)break inf_leave;case 16199:state.mode=16200;case 16200:if(have>=6&&left>=258){strm.next_out=put,strm.avail_out=left,strm.next_in=next,strm.avail_in=have,state.hold=hold,state.bits=bits,inffast(strm,_out),put=strm.next_out,output=strm.output,left=strm.avail_out,next=strm.next_in,input=strm.input,have=strm.avail_in,hold=state.hold,bits=state.bits,16191===state.mode&&(state.back=-1);break}for(state.back=0;here=state.lencode[hold&(1<<state.lenbits)-1],here_bits=here>>>24,here_op=here>>>16&255,here_val=65535&here,!(here_bits<=bits);){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(here_op&&!(240&here_op)){for(last_bits=here_bits,last_op=here_op,last_val=here_val;here=state.lencode[last_val+((hold&(1<<last_bits+last_op)-1)>>last_bits)],here_bits=here>>>24,here_op=here>>>16&255,here_val=65535&here,!(last_bits+here_bits<=bits);){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}hold>>>=last_bits,bits-=last_bits,state.back+=last_bits}if(hold>>>=here_bits,bits-=here_bits,state.back+=here_bits,state.length=here_val,0===here_op){state.mode=16205;break}if(32&here_op){state.back=-1,state.mode=16191;break}if(64&here_op){strm.msg="invalid literal/length code",state.mode=BAD;break}state.extra=15&here_op,state.mode=16201;case 16201:if(state.extra){for(n=state.extra;bits<n;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.length+=hold&(1<<state.extra)-1,hold>>>=state.extra,bits-=state.extra,state.back+=state.extra}state.was=state.length,state.mode=16202;case 16202:for(;here=state.distcode[hold&(1<<state.distbits)-1],here_bits=here>>>24,here_op=here>>>16&255,here_val=65535&here,!(here_bits<=bits);){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(!(240&here_op)){for(last_bits=here_bits,last_op=here_op,last_val=here_val;here=state.distcode[last_val+((hold&(1<<last_bits+last_op)-1)>>last_bits)],here_bits=here>>>24,here_op=here>>>16&255,here_val=65535&here,!(last_bits+here_bits<=bits);){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}hold>>>=last_bits,bits-=last_bits,state.back+=last_bits}if(hold>>>=here_bits,bits-=here_bits,state.back+=here_bits,64&here_op){strm.msg="invalid distance code",state.mode=BAD;break}state.offset=here_val,state.extra=15&here_op,state.mode=16203;case 16203:if(state.extra){for(n=state.extra;bits<n;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.offset+=hold&(1<<state.extra)-1,hold>>>=state.extra,bits-=state.extra,state.back+=state.extra}if(state.offset>state.dmax){strm.msg="invalid distance too far back",state.mode=BAD;break}state.mode=16204;case 16204:if(0===left)break inf_leave;if(copy=_out-left,state.offset>copy){if(copy=state.offset-copy,copy>state.whave&&state.sane){strm.msg="invalid distance too far back",state.mode=BAD;break}copy>state.wnext?(copy-=state.wnext,from=state.wsize-copy):from=state.wnext-copy,copy>state.length&&(copy=state.length),from_source=state.window}else from_source=output,from=put-state.offset,copy=state.length;copy>left&&(copy=left),left-=copy,state.length-=copy;do{output[put++]=from_source[from++]}while(--copy);0===state.length&&(state.mode=16200);break;case 16205:if(0===left)break inf_leave;output[put++]=state.length,left--,state.mode=16200;break;case 16206:if(state.wrap){for(;bits<32;){if(0===have)break inf_leave;have--,hold|=input[next++]<<bits,bits+=8}if(_out-=left,strm.total_out+=_out,state.total+=_out,4&state.wrap&&_out&&(strm.adler=state.check=state.flags?crc32_1(state.check,output,_out,put-_out):adler32_1(state.check,output,_out,put-_out)),_out=left,4&state.wrap&&(state.flags?hold:zswap32(hold))!==state.check){strm.msg="incorrect data check",state.mode=BAD;break}hold=0,bits=0}state.mode=16207;case 16207:if(state.wrap&&state.flags){for(;bits<32;){if(0===have)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(4&state.wrap&&hold!==(4294967295&state.total)){strm.msg="incorrect length check",state.mode=BAD;break}hold=0,bits=0}state.mode=16208;case 16208:ret=Z_STREAM_END$1;break inf_leave;case BAD:ret=Z_DATA_ERROR$1;break inf_leave;case 16210:return Z_MEM_ERROR$1;default:return Z_STREAM_ERROR$1}return strm.next_out=put,strm.avail_out=left,strm.next_in=next,strm.avail_in=have,state.hold=hold,state.bits=bits,(state.wsize||_out!==strm.avail_out&&state.mode<BAD&&(state.mode<16206||flush!==Z_FINISH$1))&&updatewindow(strm,strm.output,strm.next_out,_out-strm.avail_out),_in-=strm.avail_in,_out-=strm.avail_out,strm.total_in+=_in,strm.total_out+=_out,state.total+=_out,4&state.wrap&&_out&&(strm.adler=state.check=state.flags?crc32_1(state.check,output,_out,strm.next_out-_out):adler32_1(state.check,output,_out,strm.next_out-_out)),strm.data_type=state.bits+(state.last?64:0)+(16191===state.mode?128:0)+(16199===state.mode||16194===state.mode?256:0),(0===_in&&0===_out||flush===Z_FINISH$1)&&ret===Z_OK$1&&(ret=Z_BUF_ERROR),ret},inflateEnd:strm=>{if(inflateStateCheck(strm))return Z_STREAM_ERROR$1;let state=strm.state;return state.window&&(state.window=null),strm.state=null,Z_OK$1},inflateGetHeader:(strm,head)=>{if(inflateStateCheck(strm))return Z_STREAM_ERROR$1;const state=strm.state;return 2&state.wrap?(state.head=head,head.done=!1,Z_OK$1):Z_STREAM_ERROR$1},inflateSetDictionary:(strm,dictionary)=>{const dictLength=dictionary.length;let state,dictid,ret;return inflateStateCheck(strm)?Z_STREAM_ERROR$1:(state=strm.state,0!==state.wrap&&16190!==state.mode?Z_STREAM_ERROR$1:16190===state.mode&&(dictid=1,dictid=adler32_1(dictid,dictionary,dictLength,0),dictid!==state.check)?Z_DATA_ERROR$1:(ret=updatewindow(strm,dictionary,dictLength,dictLength),ret?(state.mode=16210,Z_MEM_ERROR$1):(state.havedict=1,Z_OK$1)))},inflateInfo:"pako inflate (from Nodeca project)"};var gzheader=function GZheader(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1};const toString=Object.prototype.toString,{Z_NO_FLUSH,Z_FINISH,Z_OK,Z_STREAM_END,Z_NEED_DICT,Z_STREAM_ERROR,Z_DATA_ERROR,Z_MEM_ERROR}=constants$2;function Inflate$1(options){this.options=common_assign({chunkSize:65536,windowBits:15,to:""},options||{});const opt=this.options;opt.raw&&opt.windowBits>=0&&opt.windowBits<16&&(opt.windowBits=-opt.windowBits,0===opt.windowBits&&(opt.windowBits=-15)),!(opt.windowBits>=0&&opt.windowBits<16)||options&&options.windowBits||(opt.windowBits+=32),opt.windowBits>15&&opt.windowBits<48&&(15&opt.windowBits||(opt.windowBits|=15)),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new zstream,this.strm.avail_out=0;let status=inflate_1$2.inflateInit2(this.strm,opt.windowBits);if(status!==Z_OK)throw new Error(messages[status]);if(this.header=new gzheader,inflate_1$2.inflateGetHeader(this.strm,this.header),opt.dictionary&&("string"==typeof opt.dictionary?opt.dictionary=strings_string2buf(opt.dictionary):"[object ArrayBuffer]"===toString.call(opt.dictionary)&&(opt.dictionary=new Uint8Array(opt.dictionary)),opt.raw&&(status=inflate_1$2.inflateSetDictionary(this.strm,opt.dictionary),status!==Z_OK)))throw new Error(messages[status])}function inflate$1(input,options){const inflator=new Inflate$1(options);if(inflator.push(input),inflator.err)throw inflator.msg||messages[inflator.err];return inflator.result}Inflate$1.prototype.push=function(data,flush_mode){const strm=this.strm,chunkSize=this.options.chunkSize,dictionary=this.options.dictionary;let status,_flush_mode,last_avail_out;if(this.ended)return!1;for(_flush_mode=flush_mode===~~flush_mode?flush_mode:!0===flush_mode?Z_FINISH:Z_NO_FLUSH,"[object ArrayBuffer]"===toString.call(data)?strm.input=new Uint8Array(data):strm.input=data,strm.next_in=0,strm.avail_in=strm.input.length;;){for(0===strm.avail_out&&(strm.output=new Uint8Array(chunkSize),strm.next_out=0,strm.avail_out=chunkSize),status=inflate_1$2.inflate(strm,_flush_mode),status===Z_NEED_DICT&&dictionary&&(status=inflate_1$2.inflateSetDictionary(strm,dictionary),status===Z_OK?status=inflate_1$2.inflate(strm,_flush_mode):status===Z_DATA_ERROR&&(status=Z_NEED_DICT));strm.avail_in>0&&status===Z_STREAM_END&&strm.state.wrap>0&&0!==data[strm.next_in];)inflate_1$2.inflateReset(strm),status=inflate_1$2.inflate(strm,_flush_mode);switch(status){case Z_STREAM_ERROR:case Z_DATA_ERROR:case Z_NEED_DICT:case Z_MEM_ERROR:return this.onEnd(status),this.ended=!0,!1}if(last_avail_out=strm.avail_out,strm.next_out&&(0===strm.avail_out||status===Z_STREAM_END))if("string"===this.options.to){let next_out_utf8=strings_utf8border(strm.output,strm.next_out),tail=strm.next_out-next_out_utf8,utf8str=strings_buf2string(strm.output,next_out_utf8);strm.next_out=tail,strm.avail_out=chunkSize-tail,tail&&strm.output.set(strm.output.subarray(next_out_utf8,next_out_utf8+tail),0),this.onData(utf8str)}else this.onData(strm.output.length===strm.next_out?strm.output:strm.output.subarray(0,strm.next_out));if(status!==Z_OK||0!==last_avail_out){if(status===Z_STREAM_END)return status=inflate_1$2.inflateEnd(this.strm),this.onEnd(status),this.ended=!0,!0;if(0===strm.avail_in)break}}return!0},Inflate$1.prototype.onData=function(chunk){this.chunks.push(chunk)},Inflate$1.prototype.onEnd=function(status){status===Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=common_flattenChunks(this.chunks)),this.chunks=[],this.err=status,this.msg=this.strm.msg};var inflate_1$1={Inflate:Inflate$1,inflate:inflate$1,inflateRaw:function inflateRaw$1(input,options){return(options=options||{}).raw=!0,inflate$1(input,options)},ungzip:inflate$1,constants:constants$2};const{Deflate,deflate,deflateRaw,gzip}=deflate_1$1,{Inflate,inflate,inflateRaw,ungzip}=inflate_1$1;var deflate_1=deflate,inflate_1=inflate},"./node_modules/perfect-freehand/dist/esm/index.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";function $(e,t,u,x=h=>h){return e*x(.5-t*(.5-u))}function l(e,t){return[e[0]+t[0],e[1]+t[1]]}function a(e,t){return[e[0]-t[0],e[1]-t[1]]}function b(e,t){return[e[0]*t,e[1]*t]}function R(e){return[e[1],-e[0]]}function B(e,t){return e[0]*t[0]+e[1]*t[1]}function ue(e,t){return e[0]===t[0]&&e[1]===t[1]}function A(e,t){return function de(e){return e[0]*e[0]+e[1]*e[1]}(a(e,t))}function G(e){return function he(e,t){return[e[0]/t,e[1]/t]}(e,function ge(e){return Math.hypot(e[0],e[1])}(e))}function ie(e,t){return Math.hypot(e[1]-t[1],e[0]-t[0])}function L(e,t,u){let x=Math.sin(u),h=Math.cos(u),y=e[0]-t[0],n=e[1]-t[1],d=y*x+n*h;return[y*h-n*x+t[0],d+t[1]]}function K(e,t,u){return l(e,b(a(t,e),u))}function ee(e,t,u){return l(e,b(t,u))}__webpack_require__.d(__webpack_exports__,{$4:()=>ae});var{min:C,PI:xe}=Math,pe=.275,V=xe+1e-4;function ae(e,t={}){return function ce(e,t={}){let{size:u=16,smoothing:x=.5,thinning:h=.5,simulatePressure:y=!0,easing:n=r=>r,start:f={},end:d={},last:D=!1}=t,{cap:S=!0,easing:j=r=>r*(2-r)}=f,{cap:q=!0,easing:c=r=>--r*r*r+1}=d;if(0===e.length||u<=0)return[];let U,p=e[e.length-1].runningLength,g=!1===f.taper?0:!0===f.taper?Math.max(u,p):f.taper,T=!1===d.taper?0:!0===d.taper?Math.max(u,p):d.taper,te=Math.pow(u*x,2),_=[],M=[],H=e.slice(0,10).reduce(((r,i)=>{let o=i.pressure;if(y){let s=C(1,i.distance/u),W=C(1,1-s);o=C(1,r+s*pe*(W-r))}return(r+o)/2}),e[0].pressure),m=$(u,h,e[e.length-1].pressure,n),X=e[0].vector,z=e[0].point,F=z,O=z,E=F,J=!1;for(let r=0;r<e.length;r++){let{pressure:i}=e[r],{point:o,vector:s,distance:W,runningLength:I}=e[r];if(r<e.length-1&&p-I<3)continue;if(h){if(y){let v=C(1,W/u),Z=C(1,1-v);i=C(1,H+v*pe*(Z-H))}m=$(u,h,i,n)}else m=u/2;void 0===U&&(U=m);let le=I<g?j(I/g):1,fe=p-I<T?c((p-I)/T):1;m=Math.max(.01,m*Math.min(le,fe));let re=(r<e.length-1?e[r+1]:e[r]).vector,Y=r<e.length-1?B(s,re):1,ne=null!==Y&&Y<0;if(B(s,X)<0&&!J||ne){let v=b(R(X),m);for(let Z=1/13,w=0;w<=1;w+=Z)O=L(a(o,v),o,V*w),_.push(O),E=L(l(o,v),o,V*-w),M.push(E);z=O,F=E,ne&&(J=!0);continue}if(J=!1,r===e.length-1){let v=b(R(s),m);_.push(a(o,v)),M.push(l(o,v));continue}let oe=b(R(K(re,s,Y)),m);O=a(o,oe),(r<=1||A(z,O)>te)&&(_.push(O),z=O),E=l(o,oe),(r<=1||A(F,E)>te)&&(M.push(E),F=E),H=i,X=s}let P=e[0].point.slice(0,2),k=e.length>1?e[e.length-1].point.slice(0,2):l(e[0].point,[1,1]),Q=[],N=[];if(1===e.length){if(!g&&!T||D){let r=ee(P,G(R(a(P,k))),-(U||m)),i=[];for(let o=1/13,s=o;s<=1;s+=o)i.push(L(r,P,2*V*s));return i}}else{if(!(g||T&&1===e.length))if(S)for(let i=1/13,o=i;o<=1;o+=i){let s=L(M[0],P,V*o);Q.push(s)}else{let i=a(_[0],M[0]),o=b(i,.5),s=b(i,.51);Q.push(a(P,o),a(P,s),l(P,s),l(P,o))}let r=R(function se(e){return[-e[0],-e[1]]}(e[e.length-1].vector));if(T||g&&1===e.length)N.push(k);else if(q){let i=ee(k,r,m);for(let o=1/29,s=o;s<1;s+=o)N.push(L(i,k,3*V*s))}else N.push(l(k,b(r,m)),l(k,b(r,.99*m)),a(k,b(r,.99*m)),a(k,b(r,m)))}return _.concat(N,M.reverse(),Q)}(function me(e,t={}){var q;let{streamline:u=.5,size:x=16,last:h=!1}=t;if(0===e.length)return[];let y=.15+.85*(1-u),n=Array.isArray(e[0])?e:e.map((({x:c,y:p,pressure:g=.5})=>[c,p,g]));if(2===n.length){let c=n[1];n=n.slice(0,-1);for(let p=1;p<5;p++)n.push(K(n[0],c,p/4))}1===n.length&&(n=[...n,[...l(n[0],[1,1]),...n[0].slice(2)]]);let f=[{point:[n[0][0],n[0][1]],pressure:n[0][2]>=0?n[0][2]:.25,vector:[1,1],distance:0,runningLength:0}],d=!1,D=0,S=f[0],j=n.length-1;for(let c=1;c<n.length;c++){let p=h&&c===j?n[c].slice(0,2):K(S.point,n[c],y);if(ue(S.point,p))continue;let g=ie(p,S.point);if(D+=g,c<j&&!d){if(D<x)continue;d=!0}S={point:p,pressure:n[c][2]>=0?n[c][2]:.5,vector:G(a(S.point,p)),distance:g,runningLength:D},f.push(S)}return f[0].vector=(null==(q=f[1])?void 0:q.vector)||[0,0],f}(e,t),t)}},"./node_modules/react-resizable-panels/dist/react-resizable-panels.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;__webpack_require__.d(__webpack_exports__,{TW:()=>PanelResizeHandle,YZ:()=>PanelGroup,Zk:()=>Panel});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/next/dist/compiled/react/index.js"),console=__webpack_require__("./node_modules/console-browserify/index.js");const{createElement,createContext,forwardRef,useCallback,useContext,useEffect,useImperativeHandle,useLayoutEffect,useMemo,useRef,useState}=react__WEBPACK_IMPORTED_MODULE_0___namespace_cache||(react__WEBPACK_IMPORTED_MODULE_0___namespace_cache=__webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__,2)),useId=(react__WEBPACK_IMPORTED_MODULE_0___namespace_cache||(react__WEBPACK_IMPORTED_MODULE_0___namespace_cache=__webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__,2)))["useId".toString()],useIsomorphicLayoutEffect=!("undefined"==typeof window||void 0===window.document||void 0===window.document.createElement)?useLayoutEffect:()=>{},wrappedUseId="function"==typeof useId?useId:()=>null;let counter=0;function useUniqueId(idFromParams=null){const idFromUseId=wrappedUseId(),idRef=useRef(idFromParams||idFromUseId||null);return null===idRef.current&&(idRef.current=""+counter++),idRef.current}const PanelGroupContext=createContext(null);function PanelWithForwardedRef({children=null,className:classNameFromProps="",collapsedSize=0,collapsible=!1,defaultSize=null,forwardedRef,id:idFromProps=null,maxSize=100,minSize=10,onCollapse=null,onResize=null,order=null,style:styleFromProps={},tagName:Type="div"}){const context=useContext(PanelGroupContext);if(null===context)throw Error("Panel components must be rendered within a PanelGroup container");const panelId=useUniqueId(idFromProps),{collapsePanel,expandPanel,getPanelStyle,registerPanel,resizePanel,unregisterPanel}=context,callbacksRef=useRef({onCollapse,onResize});if(useEffect((()=>{callbacksRef.current.onCollapse=onCollapse,callbacksRef.current.onResize=onResize})),minSize<0||minSize>100)throw Error(`Panel minSize must be between 0 and 100, but was ${minSize}`);if(maxSize<0||maxSize>100)throw Error(`Panel maxSize must be between 0 and 100, but was ${maxSize}`);if(null!==defaultSize){if(defaultSize<0||defaultSize>100)throw Error(`Panel defaultSize must be between 0 and 100, but was ${defaultSize}`);minSize>defaultSize&&!collapsible&&(console.error(`Panel minSize ${minSize} cannot be greater than defaultSize ${defaultSize}`),defaultSize=minSize)}const style=getPanelStyle(panelId,defaultSize),committedValuesRef=useRef({size:parseSizeFromStyle(style)}),panelDataRef=useRef({callbacksRef,collapsedSize,collapsible,defaultSize,id:panelId,maxSize,minSize,order});return useIsomorphicLayoutEffect((()=>{committedValuesRef.current.size=parseSizeFromStyle(style),panelDataRef.current.callbacksRef=callbacksRef,panelDataRef.current.collapsedSize=collapsedSize,panelDataRef.current.collapsible=collapsible,panelDataRef.current.defaultSize=defaultSize,panelDataRef.current.id=panelId,panelDataRef.current.maxSize=maxSize,panelDataRef.current.minSize=minSize,panelDataRef.current.order=order})),useIsomorphicLayoutEffect((()=>(registerPanel(panelId,panelDataRef),()=>{unregisterPanel(panelId)})),[order,panelId,registerPanel,unregisterPanel]),useImperativeHandle(forwardedRef,(()=>({collapse:()=>collapsePanel(panelId),expand:()=>expandPanel(panelId),getCollapsed:()=>0===committedValuesRef.current.size,getSize:()=>committedValuesRef.current.size,resize:percentage=>resizePanel(panelId,percentage)})),[collapsePanel,expandPanel,panelId,resizePanel]),createElement(Type,{children,className:classNameFromProps,"data-panel":"","data-panel-collapsible":collapsible||void 0,"data-panel-id":panelId,"data-panel-size":parseFloat(""+style.flexGrow).toFixed(1),id:`data-panel-id-${panelId}`,style:{...style,...styleFromProps}})}PanelGroupContext.displayName="PanelGroupContext";const Panel=forwardRef(((props,ref)=>createElement(PanelWithForwardedRef,{...props,forwardedRef:ref})));function parseSizeFromStyle(style){const{flexGrow}=style;return"string"==typeof flexGrow?parseFloat(flexGrow):flexGrow}PanelWithForwardedRef.displayName="Panel",Panel.displayName="forwardRef(Panel)";function adjustByDelta(event,panels,idBefore,idAfter,delta,prevSizes,panelSizeBeforeCollapse,initialDragState){const{sizes:initialSizes}=initialDragState||{},baseSizes=initialSizes||prevSizes;if(0===delta)return baseSizes;const panelsArray=panelsMapToSortedArray(panels),nextSizes=baseSizes.concat();let deltaApplied=0;{const pivotId=delta<0?idAfter:idBefore,index=panelsArray.findIndex((panel=>panel.current.id===pivotId)),panel=panelsArray[index],baseSize=baseSizes[index],nextSize=safeResizePanel(panel,Math.abs(delta),baseSize,event);if(baseSize===nextSize)return baseSizes;0===nextSize&&baseSize>0&&panelSizeBeforeCollapse.set(pivotId,baseSize),delta=delta<0?baseSize-nextSize:nextSize-baseSize}let pivotId=delta<0?idBefore:idAfter,index=panelsArray.findIndex((panel=>panel.current.id===pivotId));for(;;){const panel=panelsArray[index],baseSize=baseSizes[index],nextSize=safeResizePanel(panel,0-(Math.abs(delta)-Math.abs(deltaApplied)),baseSize,event);if(baseSize!==nextSize&&(0===nextSize&&baseSize>0&&panelSizeBeforeCollapse.set(panel.current.id,baseSize),deltaApplied+=baseSize-nextSize,nextSizes[index]=nextSize,deltaApplied.toPrecision(10).localeCompare(Math.abs(delta).toPrecision(10),void 0,{numeric:!0})>=0))break;if(delta<0){if(--index<0)break}else if(++index>=panelsArray.length)break}return 0===deltaApplied?baseSizes:(pivotId=delta<0?idAfter:idBefore,index=panelsArray.findIndex((panel=>panel.current.id===pivotId)),nextSizes[index]=baseSizes[index]+deltaApplied,nextSizes)}function callPanelCallbacks(panelsArray,sizes,panelIdToLastNotifiedSizeMap){sizes.forEach(((size,index)=>{const panelRef=panelsArray[index];if(!panelRef)return;const{callbacksRef,collapsedSize,collapsible,id}=panelRef.current,lastNotifiedSize=panelIdToLastNotifiedSizeMap[id];if(lastNotifiedSize!==size){panelIdToLastNotifiedSizeMap[id]=size;const{onCollapse,onResize}=callbacksRef.current;onResize&&onResize(size,lastNotifiedSize),collapsible&&onCollapse&&(null!=lastNotifiedSize&&lastNotifiedSize!==collapsedSize||size===collapsedSize?lastNotifiedSize!==collapsedSize&&size===collapsedSize&&onCollapse(!0):onCollapse(!1))}}))}function getBeforeAndAfterIds(id,panelsArray){if(panelsArray.length<2)return[null,null];const index=panelsArray.findIndex((panel=>panel.current.id===id));if(index<0)return[null,null];const isLastPanel=index===panelsArray.length-1;return[isLastPanel?panelsArray[index-1].current.id:id,isLastPanel?id:panelsArray[index+1].current.id]}function getFlexGrow(panels,id,sizes){if(1===panels.size)return"100";const size=sizes[panelsMapToSortedArray(panels).findIndex((panel=>panel.current.id===id))];return null==size?"0":size.toPrecision(10)}function getPanelGroup(id){const element=document.querySelector(`[data-panel-group-id="${id}"]`);return element||null}function getResizeHandle(id){const element=document.querySelector(`[data-panel-resize-handle-id="${id}"]`);return element||null}function getResizeHandles(){return Array.from(document.querySelectorAll("[data-panel-resize-handle-id]"))}function getResizeHandlesForGroup(groupId){return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${groupId}"]`))}function getResizeHandlePanelIds(groupId,handleId,panelsArray){const handle=getResizeHandle(handleId),handles=getResizeHandlesForGroup(groupId),index=handle?handles.indexOf(handle):-1;return[panelsArray[index]?.current?.id??null,panelsArray[index+1]?.current?.id??null]}function panelsMapToSortedArray(panels){return Array.from(panels.values()).sort(((panelA,panelB)=>{const orderA=panelA.current.order,orderB=panelB.current.order;return null==orderA&&null==orderB?0:null==orderA?-1:null==orderB?1:orderA-orderB}))}function safeResizePanel(panel,delta,prevSize,event){const nextSizeUnsafe=prevSize+delta,{collapsedSize,collapsible,maxSize,minSize}=panel.current;if(collapsible)if(prevSize>collapsedSize){if(nextSizeUnsafe<=minSize/2+collapsedSize)return collapsedSize}else{const isKeyboardEvent=event?.type?.startsWith("key");if(!isKeyboardEvent&&nextSizeUnsafe<minSize)return collapsedSize}return Math.min(maxSize,Math.max(minSize,nextSizeUnsafe))}function assert(expectedCondition,message="Assertion failed!"){if(!expectedCondition)throw console.error(message),Error(message)}function useWindowSplitterPanelGroupBehavior({committedValuesRef,groupId,panels,setSizes,sizes,panelSizeBeforeCollapse}){useEffect((()=>{const{direction,panels}=committedValuesRef.current,groupElement=getPanelGroup(groupId),{height,width}=groupElement.getBoundingClientRect(),cleanupFunctions=getResizeHandlesForGroup(groupId).map((handle=>{const handleId=handle.getAttribute("data-panel-resize-handle-id"),panelsArray=panelsMapToSortedArray(panels),[idBefore,idAfter]=getResizeHandlePanelIds(groupId,handleId,panelsArray);if(null==idBefore||null==idAfter)return()=>{};let minSize=0,maxSize=100,totalMinSize=0,totalMaxSize=0;panelsArray.forEach((panelData=>{panelData.current.id===idBefore?(maxSize=panelData.current.maxSize,minSize=panelData.current.minSize):(totalMinSize+=panelData.current.minSize,totalMaxSize+=panelData.current.maxSize)}));const ariaValueMax=Math.min(maxSize,100-totalMinSize),ariaValueMin=Math.max(minSize,100*(panelsArray.length-1)-totalMaxSize),flexGrow=getFlexGrow(panels,idBefore,sizes);handle.setAttribute("aria-valuemax",""+Math.round(ariaValueMax)),handle.setAttribute("aria-valuemin",""+Math.round(ariaValueMin)),handle.setAttribute("aria-valuenow",""+Math.round(parseInt(flexGrow)));const onKeyDown=event=>{if(!event.defaultPrevented)switch(event.key){case"Enter":{event.preventDefault();const index=panelsArray.findIndex((panel=>panel.current.id===idBefore));if(index>=0){const panelData=panelsArray[index],size=sizes[index];if(null!=size){let delta=0;delta=size.toPrecision(10)<=panelData.current.minSize.toPrecision(10)?"horizontal"===direction?width:height:-("horizontal"===direction?width:height);const nextSizes=adjustByDelta(event,panels,idBefore,idAfter,delta,sizes,panelSizeBeforeCollapse.current,null);sizes!==nextSizes&&setSizes(nextSizes)}}break}}};handle.addEventListener("keydown",onKeyDown);const panelBefore=function getPanel(id){const element=document.querySelector(`[data-panel-id="${id}"]`);return element||null}(idBefore);return null!=panelBefore&&handle.setAttribute("aria-controls",panelBefore.id),()=>{handle.removeAttribute("aria-valuemax"),handle.removeAttribute("aria-valuemin"),handle.removeAttribute("aria-valuenow"),handle.removeEventListener("keydown",onKeyDown),null!=panelBefore&&handle.removeAttribute("aria-controls")}}));return()=>{cleanupFunctions.forEach((cleanupFunction=>cleanupFunction()))}}),[committedValuesRef,groupId,panels,panelSizeBeforeCollapse,setSizes,sizes])}function useWindowSplitterResizeHandlerBehavior({disabled,handleId,resizeHandler}){useEffect((()=>{if(disabled||null==resizeHandler)return;const handleElement=getResizeHandle(handleId);if(null==handleElement)return;const onKeyDown=event=>{if(!event.defaultPrevented)switch(event.key){case"ArrowDown":case"ArrowLeft":case"ArrowRight":case"ArrowUp":case"End":case"Home":event.preventDefault(),resizeHandler(event);break;case"F6":{event.preventDefault();const handles=getResizeHandles(),index=function getResizeHandleIndex(id){return getResizeHandles().findIndex((handle=>handle.getAttribute("data-panel-resize-handle-id")===id))??null}(handleId);assert(null!==index);handles[event.shiftKey?index>0?index-1:handles.length-1:index+1<handles.length?index+1:0].focus();break}}};return handleElement.addEventListener("keydown",onKeyDown),()=>{handleElement.removeEventListener("keydown",onKeyDown)}}),[disabled,handleId,resizeHandler])}function getDragOffset(event,handleId,direction,initialOffset=0,initialHandleElementRect=null){const isHorizontal="horizontal"===direction;let pointerOffset=0;if(isMouseEvent(event))pointerOffset=isHorizontal?event.clientX:event.clientY;else{if(!isTouchEvent(event))return 0;{const firstTouch=event.touches[0];pointerOffset=isHorizontal?firstTouch.screenX:firstTouch.screenY}}const handleElement=getResizeHandle(handleId),rect=initialHandleElementRect||handleElement.getBoundingClientRect();return pointerOffset-(isHorizontal?rect.left:rect.top)-initialOffset}function isMouseEvent(event){return event.type.startsWith("mouse")}function isTouchEvent(event){return event.type.startsWith("touch")}let currentState=null,element=null;function getCursorStyle(state){switch(state){case"horizontal":return"ew-resize";case"horizontal-max":return"w-resize";case"horizontal-min":return"e-resize";case"vertical":return"ns-resize";case"vertical-max":return"n-resize";case"vertical-min":return"s-resize"}}function setGlobalCursorStyle(state){if(currentState===state)return;currentState=state;const style=getCursorStyle(state);null===element&&(element=document.createElement("style"),document.head.appendChild(element)),element.innerHTML=`*{cursor: ${style}!important;}`}function getSerializationKey(panels){return panels.map((panel=>{const{minSize,order}=panel.current;return order?`${order}:${minSize}`:`${minSize}`})).sort(((a,b)=>a.localeCompare(b))).join(",")}function loadSerializedPanelGroupState(autoSaveId,storage){try{const serialized=storage.getItem(`PanelGroup:sizes:${autoSaveId}`);if(serialized){const parsed=JSON.parse(serialized);if("object"==typeof parsed&&null!=parsed)return parsed}}catch(error){}return null}function savePanelGroupLayout(autoSaveId,panels,sizes,storage){const key=getSerializationKey(panels),state=loadSerializedPanelGroupState(autoSaveId,storage)||{};state[key]=sizes;try{storage.setItem(`PanelGroup:sizes:${autoSaveId}`,JSON.stringify(state))}catch(error){console.error(error)}}const debounceMap={};function initializeDefaultStorage(storageObject){try{if("undefined"==typeof localStorage)throw new Error("localStorage not supported in this environment");storageObject.getItem=name=>localStorage.getItem(name),storageObject.setItem=(name,value)=>{localStorage.setItem(name,value)}}catch(error){console.error(error),storageObject.getItem=()=>null,storageObject.setItem=()=>{}}}const defaultStorage={getItem:name=>(initializeDefaultStorage(defaultStorage),defaultStorage.getItem(name)),setItem:(name,value)=>{initializeDefaultStorage(defaultStorage),defaultStorage.setItem(name,value)}};function PanelGroupWithForwardedRef({autoSaveId,children=null,className:classNameFromProps="",direction,disablePointerEventsDuringResize=!1,forwardedRef,id:idFromProps=null,onLayout,storage=defaultStorage,style:styleFromProps={},tagName:Type="div"}){const groupId=useUniqueId(idFromProps),[activeHandleId,setActiveHandleId]=useState(null),[panels,setPanels]=useState(new Map),initialDragStateRef=useRef(null),callbacksRef=useRef({onLayout});useEffect((()=>{callbacksRef.current.onLayout=onLayout}));const panelIdToLastNotifiedSizeMapRef=useRef({}),[sizes,setSizes]=useState([]),panelSizeBeforeCollapse=useRef(new Map),prevDeltaRef=useRef(0),committedValuesRef=useRef({direction,panels,sizes});useImperativeHandle(forwardedRef,(()=>({getLayout:()=>{const{sizes}=committedValuesRef.current;return sizes},setLayout:sizes=>{assert(100===sizes.reduce(((accumulated,current)=>accumulated+current),0),"Panel sizes must add up to 100%");const{panels}=committedValuesRef.current,panelIdToLastNotifiedSizeMap=panelIdToLastNotifiedSizeMapRef.current,panelsArray=panelsMapToSortedArray(panels);setSizes(sizes),callPanelCallbacks(panelsArray,sizes,panelIdToLastNotifiedSizeMap)}})),[]),useIsomorphicLayoutEffect((()=>{committedValuesRef.current.direction=direction,committedValuesRef.current.panels=panels,committedValuesRef.current.sizes=sizes})),useWindowSplitterPanelGroupBehavior({committedValuesRef,groupId,panels,setSizes,sizes,panelSizeBeforeCollapse}),useEffect((()=>{const{onLayout}=callbacksRef.current,{panels,sizes}=committedValuesRef.current;if(sizes.length>0){onLayout&&onLayout(sizes);const panelIdToLastNotifiedSizeMap=panelIdToLastNotifiedSizeMapRef.current;callPanelCallbacks(panelsMapToSortedArray(panels),sizes,panelIdToLastNotifiedSizeMap)}}),[sizes]),useIsomorphicLayoutEffect((()=>{if(committedValuesRef.current.sizes.length===panels.size)return;let defaultSizes=null;if(autoSaveId){const panelsArray=panelsMapToSortedArray(panels);defaultSizes=function loadPanelLayout(autoSaveId,panels,storage){const state=loadSerializedPanelGroupState(autoSaveId,storage);if(state)return state[getSerializationKey(panels)]??null;return null}(autoSaveId,panelsArray,storage)}if(null!=defaultSizes)setSizes(defaultSizes);else{const panelsArray=panelsMapToSortedArray(panels);let panelsWithNullDefaultSize=0,totalDefaultSize=0,totalMinSize=0;if(panelsArray.forEach((panel=>{totalMinSize+=panel.current.minSize,null===panel.current.defaultSize?panelsWithNullDefaultSize++:totalDefaultSize+=panel.current.defaultSize})),totalDefaultSize>100)throw new Error("Default panel sizes cannot exceed 100%");if(panelsArray.length>1&&0===panelsWithNullDefaultSize&&100!==totalDefaultSize)throw new Error("Invalid default sizes specified for panels");if(totalMinSize>100)throw new Error("Minimum panel sizes cannot exceed 100%");setSizes(panelsArray.map((panel=>null===panel.current.defaultSize?(100-totalDefaultSize)/panelsWithNullDefaultSize:panel.current.defaultSize)))}}),[autoSaveId,panels,storage]),useEffect((()=>{if(autoSaveId){if(0===sizes.length||sizes.length!==panels.size)return;const panelsArray=panelsMapToSortedArray(panels);debounceMap[autoSaveId]||(debounceMap[autoSaveId]=function debounce(callback,durationMs=10){let timeoutId=null;return(...args)=>{null!==timeoutId&&clearTimeout(timeoutId),timeoutId=setTimeout((()=>{callback(...args)}),durationMs)}}(savePanelGroupLayout,100)),debounceMap[autoSaveId](autoSaveId,panelsArray,sizes,storage)}}),[autoSaveId,panels,sizes,storage]);const getPanelStyle=useCallback(((id,defaultSize)=>{const{panels}=committedValuesRef.current;if(0===panels.size)return{flexBasis:0,flexGrow:null!=defaultSize?defaultSize:void 0,flexShrink:1,overflow:"hidden"};return{flexBasis:0,flexGrow:getFlexGrow(panels,id,sizes),flexShrink:1,overflow:"hidden",pointerEvents:disablePointerEventsDuringResize&&null!==activeHandleId?"none":void 0}}),[activeHandleId,disablePointerEventsDuringResize,sizes]),registerPanel=useCallback(((id,panelRef)=>{setPanels((prevPanels=>{if(prevPanels.has(id))return prevPanels;const nextPanels=new Map(prevPanels);return nextPanels.set(id,panelRef),nextPanels}))}),[]),registerResizeHandle=useCallback((handleId=>event=>{event.preventDefault();const{direction,panels,sizes:prevSizes}=committedValuesRef.current,panelsArray=panelsMapToSortedArray(panels),[idBefore,idAfter]=getResizeHandlePanelIds(groupId,handleId,panelsArray);if(null==idBefore||null==idAfter)return;let movement=function getMovement(event,groupId,handleId,panelsArray,direction,prevSizes,initialDragState){const{dragOffset=0,dragHandleRect,sizes:initialSizes}=initialDragState||{},baseSizes=initialSizes||prevSizes;if(function isKeyDown(event){return"keydown"===event.type}(event)){const isHorizontal="horizontal"===direction,rect=getPanelGroup(groupId).getBoundingClientRect(),groupSizeInPixels=isHorizontal?rect.width:rect.height,delta=groupSizeInPixels/(event.shiftKey?10:100);let movement=0;switch(event.key){case"ArrowDown":movement=isHorizontal?0:delta;break;case"ArrowLeft":movement=isHorizontal?-delta:0;break;case"ArrowRight":movement=isHorizontal?delta:0;break;case"ArrowUp":movement=isHorizontal?0:-delta;break;case"End":movement=groupSizeInPixels;break;case"Home":movement=-groupSizeInPixels}const[idBefore,idAfter]=getResizeHandlePanelIds(groupId,handleId,panelsArray),targetPanelId=movement<0?idBefore:idAfter,targetPanelIndex=panelsArray.findIndex((panel=>panel.current.id===targetPanelId)),targetPanel=panelsArray[targetPanelIndex];if(targetPanel.current.collapsible){const baseSize=baseSizes[targetPanelIndex];0!==baseSize&&baseSize.toPrecision(10)!==targetPanel.current.minSize.toPrecision(10)||(movement=movement<0?-targetPanel.current.minSize*groupSizeInPixels:targetPanel.current.minSize*groupSizeInPixels)}return movement}return getDragOffset(event,handleId,direction,dragOffset,dragHandleRect)}(event,groupId,handleId,panelsArray,direction,prevSizes,initialDragStateRef.current);if(0===movement)return;const rect=getPanelGroup(groupId).getBoundingClientRect(),isHorizontal="horizontal"===direction;"rtl"===document.dir&&isHorizontal&&(movement=-movement);const delta=movement/(isHorizontal?rect.width:rect.height)*100,nextSizes=adjustByDelta(event,panels,idBefore,idAfter,delta,prevSizes,panelSizeBeforeCollapse.current,initialDragStateRef.current),sizesChanged=!function areEqual(arrayA,arrayB){if(arrayA.length!==arrayB.length)return!1;for(let index=0;index<arrayA.length;index++)if(arrayA[index]!==arrayB[index])return!1;return!0}(prevSizes,nextSizes);if((isMouseEvent(event)||isTouchEvent(event))&&prevDeltaRef.current!=delta&&setGlobalCursorStyle(sizesChanged?isHorizontal?"horizontal":"vertical":isHorizontal?movement<0?"horizontal-min":"horizontal-max":movement<0?"vertical-min":"vertical-max"),sizesChanged){const panelIdToLastNotifiedSizeMap=panelIdToLastNotifiedSizeMapRef.current;setSizes(nextSizes),callPanelCallbacks(panelsArray,nextSizes,panelIdToLastNotifiedSizeMap)}prevDeltaRef.current=delta}),[groupId]),unregisterPanel=useCallback((id=>{setPanels((prevPanels=>{if(!prevPanels.has(id))return prevPanels;const nextPanels=new Map(prevPanels);return nextPanels.delete(id),nextPanels}))}),[]),collapsePanel=useCallback((id=>{const{panels,sizes:prevSizes}=committedValuesRef.current,panel=panels.get(id);if(null==panel)return;const{collapsedSize,collapsible}=panel.current;if(!collapsible)return;const panelsArray=panelsMapToSortedArray(panels),index=panelsArray.indexOf(panel);if(index<0)return;const currentSize=prevSizes[index];if(currentSize===collapsedSize)return;panelSizeBeforeCollapse.current.set(id,currentSize);const[idBefore,idAfter]=getBeforeAndAfterIds(id,panelsArray);if(null==idBefore||null==idAfter)return;const nextSizes=adjustByDelta(null,panels,idBefore,idAfter,index===panelsArray.length-1?currentSize:collapsedSize-currentSize,prevSizes,panelSizeBeforeCollapse.current,null);if(prevSizes!==nextSizes){const panelIdToLastNotifiedSizeMap=panelIdToLastNotifiedSizeMapRef.current;setSizes(nextSizes),callPanelCallbacks(panelsArray,nextSizes,panelIdToLastNotifiedSizeMap)}}),[]),expandPanel=useCallback((id=>{const{panels,sizes:prevSizes}=committedValuesRef.current,panel=panels.get(id);if(null==panel)return;const{collapsedSize,minSize}=panel.current,sizeBeforeCollapse=panelSizeBeforeCollapse.current.get(id)||minSize;if(!sizeBeforeCollapse)return;const panelsArray=panelsMapToSortedArray(panels),index=panelsArray.indexOf(panel);if(index<0)return;if(prevSizes[index]!==collapsedSize)return;const[idBefore,idAfter]=getBeforeAndAfterIds(id,panelsArray);if(null==idBefore||null==idAfter)return;const nextSizes=adjustByDelta(null,panels,idBefore,idAfter,index===panelsArray.length-1?collapsedSize-sizeBeforeCollapse:sizeBeforeCollapse,prevSizes,panelSizeBeforeCollapse.current,null);if(prevSizes!==nextSizes){const panelIdToLastNotifiedSizeMap=panelIdToLastNotifiedSizeMapRef.current;setSizes(nextSizes),callPanelCallbacks(panelsArray,nextSizes,panelIdToLastNotifiedSizeMap)}}),[]),resizePanel=useCallback(((id,nextSize)=>{const{panels,sizes:prevSizes}=committedValuesRef.current,panel=panels.get(id);if(null==panel)return;const{collapsedSize,collapsible,maxSize,minSize}=panel.current,panelsArray=panelsMapToSortedArray(panels),index=panelsArray.indexOf(panel);if(index<0)return;const currentSize=prevSizes[index];if(currentSize===nextSize)return;collapsible&&nextSize===collapsedSize||(nextSize=Math.min(maxSize,Math.max(minSize,nextSize)));const[idBefore,idAfter]=getBeforeAndAfterIds(id,panelsArray);if(null==idBefore||null==idAfter)return;const nextSizes=adjustByDelta(null,panels,idBefore,idAfter,index===panelsArray.length-1?currentSize-nextSize:nextSize-currentSize,prevSizes,panelSizeBeforeCollapse.current,null);if(prevSizes!==nextSizes){const panelIdToLastNotifiedSizeMap=panelIdToLastNotifiedSizeMapRef.current;setSizes(nextSizes),callPanelCallbacks(panelsArray,nextSizes,panelIdToLastNotifiedSizeMap)}}),[]),context=useMemo((()=>({activeHandleId,collapsePanel,direction,expandPanel,getPanelStyle,groupId,registerPanel,registerResizeHandle,resizePanel,startDragging:(id,event)=>{if(setActiveHandleId(id),isMouseEvent(event)||isTouchEvent(event)){const handleElement=getResizeHandle(id);initialDragStateRef.current={dragHandleRect:handleElement.getBoundingClientRect(),dragOffset:getDragOffset(event,id,direction),sizes:committedValuesRef.current.sizes}}},stopDragging:()=>{!function resetGlobalCursorStyle(){null!==element&&(document.head.removeChild(element),currentState=null,element=null)}(),setActiveHandleId(null),initialDragStateRef.current=null},unregisterPanel})),[activeHandleId,collapsePanel,direction,expandPanel,getPanelStyle,groupId,registerPanel,registerResizeHandle,resizePanel,unregisterPanel]),style={display:"flex",flexDirection:"horizontal"===direction?"row":"column",height:"100%",overflow:"hidden",width:"100%"};return createElement(PanelGroupContext.Provider,{children:createElement(Type,{children,className:classNameFromProps,"data-panel-group":"","data-panel-group-direction":direction,"data-panel-group-id":groupId,style:{...style,...styleFromProps}}),value:context})}const PanelGroup=forwardRef(((props,ref)=>createElement(PanelGroupWithForwardedRef,{...props,forwardedRef:ref})));function PanelResizeHandle({children=null,className:classNameFromProps="",disabled=!1,id:idFromProps=null,onDragging,style:styleFromProps={},tagName:Type="div"}){const divElementRef=useRef(null),callbacksRef=useRef({onDragging});useEffect((()=>{callbacksRef.current.onDragging=onDragging}));const panelGroupContext=useContext(PanelGroupContext);if(null===panelGroupContext)throw Error("PanelResizeHandle components must be rendered within a PanelGroup container");const{activeHandleId,direction,groupId,registerResizeHandle,startDragging,stopDragging}=panelGroupContext,resizeHandleId=useUniqueId(idFromProps),isDragging=activeHandleId===resizeHandleId,[isFocused,setIsFocused]=useState(!1),[resizeHandler,setResizeHandler]=useState(null),stopDraggingAndBlur=useCallback((()=>{divElementRef.current.blur(),stopDragging();const{onDragging}=callbacksRef.current;onDragging&&onDragging(!1)}),[stopDragging]);useEffect((()=>{if(disabled)setResizeHandler(null);else{const resizeHandler=registerResizeHandle(resizeHandleId);setResizeHandler((()=>resizeHandler))}}),[disabled,resizeHandleId,registerResizeHandle]),useEffect((()=>{if(disabled||null==resizeHandler||!isDragging)return;const onMove=event=>{resizeHandler(event)},onMouseLeave=event=>{resizeHandler(event)},targetDocument=divElementRef.current.ownerDocument;return targetDocument.body.addEventListener("contextmenu",stopDraggingAndBlur),targetDocument.body.addEventListener("mousemove",onMove),targetDocument.body.addEventListener("touchmove",onMove),targetDocument.body.addEventListener("mouseleave",onMouseLeave),window.addEventListener("mouseup",stopDraggingAndBlur),window.addEventListener("touchend",stopDraggingAndBlur),()=>{targetDocument.body.removeEventListener("contextmenu",stopDraggingAndBlur),targetDocument.body.removeEventListener("mousemove",onMove),targetDocument.body.removeEventListener("touchmove",onMove),targetDocument.body.removeEventListener("mouseleave",onMouseLeave),window.removeEventListener("mouseup",stopDraggingAndBlur),window.removeEventListener("touchend",stopDraggingAndBlur)}}),[direction,disabled,isDragging,resizeHandler,stopDraggingAndBlur]),useWindowSplitterResizeHandlerBehavior({disabled,handleId:resizeHandleId,resizeHandler});const style={cursor:getCursorStyle(direction),touchAction:"none",userSelect:"none"};return createElement(Type,{children,className:classNameFromProps,"data-resize-handle-active":isDragging?"pointer":isFocused?"keyboard":void 0,"data-panel-group-direction":direction,"data-panel-group-id":groupId,"data-panel-resize-handle-enabled":!disabled,"data-panel-resize-handle-id":resizeHandleId,onBlur:()=>setIsFocused(!1),onFocus:()=>setIsFocused(!0),onMouseDown:event=>{startDragging(resizeHandleId,event.nativeEvent);const{onDragging}=callbacksRef.current;onDragging&&onDragging(!0)},onMouseUp:stopDraggingAndBlur,onTouchCancel:stopDraggingAndBlur,onTouchEnd:stopDraggingAndBlur,onTouchStart:event=>{startDragging(resizeHandleId,event.nativeEvent);const{onDragging}=callbacksRef.current;onDragging&&onDragging(!0)},ref:divElementRef,role:"separator",style:{...style,...styleFromProps},tabIndex:0})}PanelGroupWithForwardedRef.displayName="PanelGroup",PanelGroup.displayName="forwardRef(PanelGroup)",PanelResizeHandle.displayName="PanelResizeHandle"},"./node_modules/roughjs/bin/rough.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";function rotatePoints(points,center,degrees){if(points&&points.length){const[cx,cy]=center,angle=Math.PI/180*degrees,cos=Math.cos(angle),sin=Math.sin(angle);for(const p of points){const[x,y]=p;p[0]=(x-cx)*cos-(y-cy)*sin+cx,p[1]=(x-cx)*sin+(y-cy)*cos+cy}}}function areSamePoints(p1,p2){return p1[0]===p2[0]&&p1[1]===p2[1]}function hachureLines(polygons,hachureGap,hachureAngle,hachureStepOffset=1){const angle=hachureAngle,gap=Math.max(hachureGap,.1),polygonList=polygons[0]&&polygons[0][0]&&"number"==typeof polygons[0][0]?[polygons]:polygons,rotationCenter=[0,0];if(angle)for(const polygon of polygonList)rotatePoints(polygon,rotationCenter,angle);const lines=function straightHachureLines(polygons,gap,hachureStepOffset){const vertexArray=[];for(const polygon of polygons){const vertices=[...polygon];areSamePoints(vertices[0],vertices[vertices.length-1])||vertices.push([vertices[0][0],vertices[0][1]]),vertices.length>2&&vertexArray.push(vertices)}const lines=[];gap=Math.max(gap,.1);const edges=[];for(const vertices of vertexArray)for(let i=0;i<vertices.length-1;i++){const p1=vertices[i],p2=vertices[i+1];if(p1[1]!==p2[1]){const ymin=Math.min(p1[1],p2[1]);edges.push({ymin,ymax:Math.max(p1[1],p2[1]),x:ymin===p1[1]?p1[0]:p2[0],islope:(p2[0]-p1[0])/(p2[1]-p1[1])})}}if(edges.sort(((e1,e2)=>e1.ymin<e2.ymin?-1:e1.ymin>e2.ymin?1:e1.x<e2.x?-1:e1.x>e2.x?1:e1.ymax===e2.ymax?0:(e1.ymax-e2.ymax)/Math.abs(e1.ymax-e2.ymax))),!edges.length)return lines;let activeEdges=[],y=edges[0].ymin,iteration=0;for(;activeEdges.length||edges.length;){if(edges.length){let ix=-1;for(let i=0;i<edges.length&&!(edges[i].ymin>y);i++)ix=i;edges.splice(0,ix+1).forEach((edge=>{activeEdges.push({s:y,edge})}))}if(activeEdges=activeEdges.filter((ae=>!(ae.edge.ymax<=y))),activeEdges.sort(((ae1,ae2)=>ae1.edge.x===ae2.edge.x?0:(ae1.edge.x-ae2.edge.x)/Math.abs(ae1.edge.x-ae2.edge.x))),(1!==hachureStepOffset||iteration%gap==0)&&activeEdges.length>1)for(let i=0;i<activeEdges.length;i+=2){const nexti=i+1;if(nexti>=activeEdges.length)break;const ce=activeEdges[i].edge,ne=activeEdges[nexti].edge;lines.push([[Math.round(ce.x),y],[Math.round(ne.x),y]])}y+=hachureStepOffset,activeEdges.forEach((ae=>{ae.edge.x=ae.edge.x+hachureStepOffset*ae.edge.islope})),iteration++}return lines}(polygonList,gap,hachureStepOffset);if(angle){for(const polygon of polygonList)rotatePoints(polygon,rotationCenter,-angle);!function rotateLines(lines,center,degrees){const points=[];lines.forEach((line=>points.push(...line))),rotatePoints(points,center,degrees)}(lines,rotationCenter,-angle)}return lines}function polygonHachureLines(polygonList,o){var _a;const angle=o.hachureAngle+90;let gap=o.hachureGap;gap<0&&(gap=4*o.strokeWidth),gap=Math.round(Math.max(gap,.1));let skipOffset=1;return o.roughness>=1&&((null===(_a=o.randomizer)||void 0===_a?void 0:_a.next())||Math.random())>.7&&(skipOffset=gap),hachureLines(polygonList,gap,angle,skipOffset||1)}__webpack_require__.d(__webpack_exports__,{A:()=>rough});class HachureFiller{constructor(helper){this.helper=helper}fillPolygons(polygonList,o){return this._fillPolygons(polygonList,o)}_fillPolygons(polygonList,o){const lines=polygonHachureLines(polygonList,o);return{type:"fillSketch",ops:this.renderLines(lines,o)}}renderLines(lines,o){const ops=[];for(const line of lines)ops.push(...this.helper.doubleLineOps(line[0][0],line[0][1],line[1][0],line[1][1],o));return ops}}function lineLength(line){const p1=line[0],p2=line[1];return Math.sqrt(Math.pow(p1[0]-p2[0],2)+Math.pow(p1[1]-p2[1],2))}class ZigZagFiller extends HachureFiller{fillPolygons(polygonList,o){let gap=o.hachureGap;gap<0&&(gap=4*o.strokeWidth),gap=Math.max(gap,.1);const lines=polygonHachureLines(polygonList,Object.assign({},o,{hachureGap:gap})),zigZagAngle=Math.PI/180*o.hachureAngle,zigzagLines=[],dgx=.5*gap*Math.cos(zigZagAngle),dgy=.5*gap*Math.sin(zigZagAngle);for(const[p1,p2]of lines)lineLength([p1,p2])&&zigzagLines.push([[p1[0]-dgx,p1[1]+dgy],[...p2]],[[p1[0]+dgx,p1[1]-dgy],[...p2]]);return{type:"fillSketch",ops:this.renderLines(zigzagLines,o)}}}class HatchFiller extends HachureFiller{fillPolygons(polygonList,o){const set=this._fillPolygons(polygonList,o),o2=Object.assign({},o,{hachureAngle:o.hachureAngle+90}),set2=this._fillPolygons(polygonList,o2);return set.ops=set.ops.concat(set2.ops),set}}class DotFiller{constructor(helper){this.helper=helper}fillPolygons(polygonList,o){const lines=polygonHachureLines(polygonList,o=Object.assign({},o,{hachureAngle:0}));return this.dotsOnLines(lines,o)}dotsOnLines(lines,o){const ops=[];let gap=o.hachureGap;gap<0&&(gap=4*o.strokeWidth),gap=Math.max(gap,.1);let fweight=o.fillWeight;fweight<0&&(fweight=o.strokeWidth/2);const ro=gap/4;for(const line of lines){const length=lineLength(line),dl=length/gap,count=Math.ceil(dl)-1,offset=length-count*gap,x=(line[0][0]+line[1][0])/2-gap/4,minY=Math.min(line[0][1],line[1][1]);for(let i=0;i<count;i++){const y=minY+offset+i*gap,cx=x-ro+2*Math.random()*ro,cy=y-ro+2*Math.random()*ro,el=this.helper.ellipse(cx,cy,fweight,fweight,o);ops.push(...el.ops)}}return{type:"fillSketch",ops}}}class DashedFiller{constructor(helper){this.helper=helper}fillPolygons(polygonList,o){const lines=polygonHachureLines(polygonList,o);return{type:"fillSketch",ops:this.dashedLine(lines,o)}}dashedLine(lines,o){const offset=o.dashOffset<0?o.hachureGap<0?4*o.strokeWidth:o.hachureGap:o.dashOffset,gap=o.dashGap<0?o.hachureGap<0?4*o.strokeWidth:o.hachureGap:o.dashGap,ops=[];return lines.forEach((line=>{const length=lineLength(line),count=Math.floor(length/(offset+gap)),startOffset=(length+gap-count*(offset+gap))/2;let p1=line[0],p2=line[1];p1[0]>p2[0]&&(p1=line[1],p2=line[0]);const alpha=Math.atan((p2[1]-p1[1])/(p2[0]-p1[0]));for(let i=0;i<count;i++){const lstart=i*(offset+gap),lend=lstart+offset,start=[p1[0]+lstart*Math.cos(alpha)+startOffset*Math.cos(alpha),p1[1]+lstart*Math.sin(alpha)+startOffset*Math.sin(alpha)],end=[p1[0]+lend*Math.cos(alpha)+startOffset*Math.cos(alpha),p1[1]+lend*Math.sin(alpha)+startOffset*Math.sin(alpha)];ops.push(...this.helper.doubleLineOps(start[0],start[1],end[0],end[1],o))}})),ops}}class ZigZagLineFiller{constructor(helper){this.helper=helper}fillPolygons(polygonList,o){const gap=o.hachureGap<0?4*o.strokeWidth:o.hachureGap,zo=o.zigzagOffset<0?gap:o.zigzagOffset,lines=polygonHachureLines(polygonList,o=Object.assign({},o,{hachureGap:gap+zo}));return{type:"fillSketch",ops:this.zigzagLines(lines,zo,o)}}zigzagLines(lines,zo,o){const ops=[];return lines.forEach((line=>{const length=lineLength(line),count=Math.round(length/(2*zo));let p1=line[0],p2=line[1];p1[0]>p2[0]&&(p1=line[1],p2=line[0]);const alpha=Math.atan((p2[1]-p1[1])/(p2[0]-p1[0]));for(let i=0;i<count;i++){const lstart=2*i*zo,lend=2*(i+1)*zo,dz=Math.sqrt(2*Math.pow(zo,2)),start=[p1[0]+lstart*Math.cos(alpha),p1[1]+lstart*Math.sin(alpha)],end=[p1[0]+lend*Math.cos(alpha),p1[1]+lend*Math.sin(alpha)],middle=[start[0]+dz*Math.cos(alpha+Math.PI/4),start[1]+dz*Math.sin(alpha+Math.PI/4)];ops.push(...this.helper.doubleLineOps(start[0],start[1],middle[0],middle[1],o),...this.helper.doubleLineOps(middle[0],middle[1],end[0],end[1],o))}})),ops}}const fillers={};class Random{constructor(seed){this.seed=seed}next(){return this.seed?(2**31-1&(this.seed=Math.imul(48271,this.seed)))/2**31:Math.random()}}const PARAMS={A:7,a:7,C:6,c:6,H:1,h:1,L:2,l:2,M:2,m:2,Q:4,q:4,S:4,s:4,T:2,t:2,V:1,v:1,Z:0,z:0};function isType(token,type){return token.type===type}function parsePath(d){const segments=[],tokens=function tokenize(d){const tokens=new Array;for(;""!==d;)if(d.match(/^([ \t\r\n,]+)/))d=d.substr(RegExp.$1.length);else if(d.match(/^([aAcChHlLmMqQsStTvVzZ])/))tokens[tokens.length]={type:0,text:RegExp.$1},d=d.substr(RegExp.$1.length);else{if(!d.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))return[];tokens[tokens.length]={type:1,text:`${parseFloat(RegExp.$1)}`},d=d.substr(RegExp.$1.length)}return tokens[tokens.length]={type:2,text:""},tokens}(d);let mode="BOD",index=0,token=tokens[index];for(;!isType(token,2);){let paramsCount=0;const params=[];if("BOD"===mode){if("M"!==token.text&&"m"!==token.text)return parsePath("M0,0"+d);index++,paramsCount=PARAMS[token.text],mode=token.text}else isType(token,1)?paramsCount=PARAMS[mode]:(index++,paramsCount=PARAMS[token.text],mode=token.text);if(!(index+paramsCount<tokens.length))throw new Error("Path data ended short");for(let i=index;i<index+paramsCount;i++){const numbeToken=tokens[i];if(!isType(numbeToken,1))throw new Error("Param not a number: "+mode+","+numbeToken.text);params[params.length]=+numbeToken.text}if("number"!=typeof PARAMS[mode])throw new Error("Bad segment: "+mode);{const segment={key:mode,data:params};segments.push(segment),index+=paramsCount,token=tokens[index],"M"===mode&&(mode="L"),"m"===mode&&(mode="l")}}return segments}function absolutize(segments){let cx=0,cy=0,subx=0,suby=0;const out=[];for(const{key,data}of segments)switch(key){case"M":out.push({key:"M",data:[...data]}),[cx,cy]=data,[subx,suby]=data;break;case"m":cx+=data[0],cy+=data[1],out.push({key:"M",data:[cx,cy]}),subx=cx,suby=cy;break;case"L":out.push({key:"L",data:[...data]}),[cx,cy]=data;break;case"l":cx+=data[0],cy+=data[1],out.push({key:"L",data:[cx,cy]});break;case"C":out.push({key:"C",data:[...data]}),cx=data[4],cy=data[5];break;case"c":{const newdata=data.map(((d,i)=>i%2?d+cy:d+cx));out.push({key:"C",data:newdata}),cx=newdata[4],cy=newdata[5];break}case"Q":out.push({key:"Q",data:[...data]}),cx=data[2],cy=data[3];break;case"q":{const newdata=data.map(((d,i)=>i%2?d+cy:d+cx));out.push({key:"Q",data:newdata}),cx=newdata[2],cy=newdata[3];break}case"A":out.push({key:"A",data:[...data]}),cx=data[5],cy=data[6];break;case"a":cx+=data[5],cy+=data[6],out.push({key:"A",data:[data[0],data[1],data[2],data[3],data[4],cx,cy]});break;case"H":out.push({key:"H",data:[...data]}),cx=data[0];break;case"h":cx+=data[0],out.push({key:"H",data:[cx]});break;case"V":out.push({key:"V",data:[...data]}),cy=data[0];break;case"v":cy+=data[0],out.push({key:"V",data:[cy]});break;case"S":out.push({key:"S",data:[...data]}),cx=data[2],cy=data[3];break;case"s":{const newdata=data.map(((d,i)=>i%2?d+cy:d+cx));out.push({key:"S",data:newdata}),cx=newdata[2],cy=newdata[3];break}case"T":out.push({key:"T",data:[...data]}),cx=data[0],cy=data[1];break;case"t":cx+=data[0],cy+=data[1],out.push({key:"T",data:[cx,cy]});break;case"Z":case"z":out.push({key:"Z",data:[]}),cx=subx,cy=suby}return out}function normalize(segments){const out=[];let lastType="",cx=0,cy=0,subx=0,suby=0,lcx=0,lcy=0;for(const{key,data}of segments){switch(key){case"M":out.push({key:"M",data:[...data]}),[cx,cy]=data,[subx,suby]=data;break;case"C":out.push({key:"C",data:[...data]}),cx=data[4],cy=data[5],lcx=data[2],lcy=data[3];break;case"L":out.push({key:"L",data:[...data]}),[cx,cy]=data;break;case"H":cx=data[0],out.push({key:"L",data:[cx,cy]});break;case"V":cy=data[0],out.push({key:"L",data:[cx,cy]});break;case"S":{let cx1=0,cy1=0;"C"===lastType||"S"===lastType?(cx1=cx+(cx-lcx),cy1=cy+(cy-lcy)):(cx1=cx,cy1=cy),out.push({key:"C",data:[cx1,cy1,...data]}),lcx=data[0],lcy=data[1],cx=data[2],cy=data[3];break}case"T":{const[x,y]=data;let x1=0,y1=0;"Q"===lastType||"T"===lastType?(x1=cx+(cx-lcx),y1=cy+(cy-lcy)):(x1=cx,y1=cy);const cx1=cx+2*(x1-cx)/3,cy1=cy+2*(y1-cy)/3,cx2=x+2*(x1-x)/3,cy2=y+2*(y1-y)/3;out.push({key:"C",data:[cx1,cy1,cx2,cy2,x,y]}),lcx=x1,lcy=y1,cx=x,cy=y;break}case"Q":{const[x1,y1,x,y]=data,cx1=cx+2*(x1-cx)/3,cy1=cy+2*(y1-cy)/3,cx2=x+2*(x1-x)/3,cy2=y+2*(y1-y)/3;out.push({key:"C",data:[cx1,cy1,cx2,cy2,x,y]}),lcx=x1,lcy=y1,cx=x,cy=y;break}case"A":{const r1=Math.abs(data[0]),r2=Math.abs(data[1]),angle=data[2],largeArcFlag=data[3],sweepFlag=data[4],x=data[5],y=data[6];if(0===r1||0===r2)out.push({key:"C",data:[cx,cy,x,y,x,y]}),cx=x,cy=y;else if(cx!==x||cy!==y){arcToCubicCurves(cx,cy,x,y,r1,r2,angle,largeArcFlag,sweepFlag).forEach((function(curve){out.push({key:"C",data:curve})})),cx=x,cy=y}break}case"Z":out.push({key:"Z",data:[]}),cx=subx,cy=suby}lastType=key}return out}function rotate(x,y,angleRad){return[x*Math.cos(angleRad)-y*Math.sin(angleRad),x*Math.sin(angleRad)+y*Math.cos(angleRad)]}function arcToCubicCurves(x1,y1,x2,y2,r1,r2,angle,largeArcFlag,sweepFlag,recursive){const angleRad=function degToRad(degrees){return Math.PI*degrees/180}(angle);let params=[],f1=0,f2=0,cx=0,cy=0;if(recursive)[f1,f2,cx,cy]=recursive;else{[x1,y1]=rotate(x1,y1,-angleRad),[x2,y2]=rotate(x2,y2,-angleRad);const x=(x1-x2)/2,y=(y1-y2)/2;let h=x*x/(r1*r1)+y*y/(r2*r2);h>1&&(h=Math.sqrt(h),r1*=h,r2*=h);const r1Pow=r1*r1,r2Pow=r2*r2,left=r1Pow*r2Pow-r1Pow*y*y-r2Pow*x*x,right=r1Pow*y*y+r2Pow*x*x,k=(largeArcFlag===sweepFlag?-1:1)*Math.sqrt(Math.abs(left/right));cx=k*r1*y/r2+(x1+x2)/2,cy=k*-r2*x/r1+(y1+y2)/2,f1=Math.asin(parseFloat(((y1-cy)/r2).toFixed(9))),f2=Math.asin(parseFloat(((y2-cy)/r2).toFixed(9))),x1<cx&&(f1=Math.PI-f1),x2<cx&&(f2=Math.PI-f2),f1<0&&(f1=2*Math.PI+f1),f2<0&&(f2=2*Math.PI+f2),sweepFlag&&f1>f2&&(f1-=2*Math.PI),!sweepFlag&&f2>f1&&(f2-=2*Math.PI)}let df=f2-f1;if(Math.abs(df)>120*Math.PI/180){const f2old=f2,x2old=x2,y2old=y2;f2=sweepFlag&&f2>f1?f1+120*Math.PI/180*1:f1+120*Math.PI/180*-1,params=arcToCubicCurves(x2=cx+r1*Math.cos(f2),y2=cy+r2*Math.sin(f2),x2old,y2old,r1,r2,angle,0,sweepFlag,[f2,f2old,cx,cy])}df=f2-f1;const c1=Math.cos(f1),s1=Math.sin(f1),c2=Math.cos(f2),s2=Math.sin(f2),t=Math.tan(df/4),hx=4/3*r1*t,hy=4/3*r2*t,m1=[x1,y1],m2=[x1+hx*s1,y1-hy*c1],m3=[x2+hx*s2,y2-hy*c2],m4=[x2,y2];if(m2[0]=2*m1[0]-m2[0],m2[1]=2*m1[1]-m2[1],recursive)return[m2,m3,m4].concat(params);{params=[m2,m3,m4].concat(params);const curves=[];for(let i=0;i<params.length;i+=3){const r1=rotate(params[i][0],params[i][1],angleRad),r2=rotate(params[i+1][0],params[i+1][1],angleRad),r3=rotate(params[i+2][0],params[i+2][1],angleRad);curves.push([r1[0],r1[1],r2[0],r2[1],r3[0],r3[1]])}return curves}}const helper={randOffset:function randOffset(x,o){return _offsetOpt(x,o)},randOffsetWithRange:function randOffsetWithRange(min,max,o){return _offset(min,max,o)},ellipse:function ellipse(x,y,width,height,o){const params=generateEllipseParams(width,height,o);return ellipseWithParams(x,y,o,params).opset},doubleLineOps:function doubleLineFillOps(x1,y1,x2,y2,o){return _doubleLine(x1,y1,x2,y2,o,!0)}};function line(x1,y1,x2,y2,o){return{type:"path",ops:_doubleLine(x1,y1,x2,y2,o)}}function linearPath(points,close,o){const len=(points||[]).length;if(len>2){const ops=[];for(let i=0;i<len-1;i++)ops.push(..._doubleLine(points[i][0],points[i][1],points[i+1][0],points[i+1][1],o));return close&&ops.push(..._doubleLine(points[len-1][0],points[len-1][1],points[0][0],points[0][1],o)),{type:"path",ops}}return 2===len?line(points[0][0],points[0][1],points[1][0],points[1][1],o):{type:"path",ops:[]}}function rectangle(x,y,width,height,o){return function polygon(points,o){return linearPath(points,!0,o)}([[x,y],[x+width,y],[x+width,y+height],[x,y+height]],o)}function curve(inputPoints,o){if(inputPoints.length){const pointsList="number"==typeof inputPoints[0][0]?[inputPoints]:inputPoints,o1=_curveWithOffset(pointsList[0],1*(1+.2*o.roughness),o),o2=o.disableMultiStroke?[]:_curveWithOffset(pointsList[0],1.5*(1+.22*o.roughness),cloneOptionsAlterSeed(o));for(let i=1;i<pointsList.length;i++){const points=pointsList[i];if(points.length){const underlay=_curveWithOffset(points,1*(1+.2*o.roughness),o),overlay=o.disableMultiStroke?[]:_curveWithOffset(points,1.5*(1+.22*o.roughness),cloneOptionsAlterSeed(o));for(const item of underlay)"move"!==item.op&&o1.push(item);for(const item of overlay)"move"!==item.op&&o2.push(item)}}return{type:"path",ops:o1.concat(o2)}}return{type:"path",ops:[]}}function generateEllipseParams(width,height,o){const psq=Math.sqrt(2*Math.PI*Math.sqrt((Math.pow(width/2,2)+Math.pow(height/2,2))/2)),stepCount=Math.ceil(Math.max(o.curveStepCount,o.curveStepCount/Math.sqrt(200)*psq)),increment=2*Math.PI/stepCount;let rx=Math.abs(width/2),ry=Math.abs(height/2);const curveFitRandomness=1-o.curveFitting;return rx+=_offsetOpt(rx*curveFitRandomness,o),ry+=_offsetOpt(ry*curveFitRandomness,o),{increment,rx,ry}}function ellipseWithParams(x,y,o,ellipseParams){const[ap1,cp1]=_computeEllipsePoints(ellipseParams.increment,x,y,ellipseParams.rx,ellipseParams.ry,1,ellipseParams.increment*_offset(.1,_offset(.4,1,o),o),o);let o1=_curve(ap1,null,o);if(!o.disableMultiStroke&&0!==o.roughness){const[ap2]=_computeEllipsePoints(ellipseParams.increment,x,y,ellipseParams.rx,ellipseParams.ry,1.5,0,o),o2=_curve(ap2,null,o);o1=o1.concat(o2)}return{estimatedPoints:cp1,opset:{type:"path",ops:o1}}}function arc(x,y,width,height,start,stop,closed,roughClosure,o){const cx=x,cy=y;let rx=Math.abs(width/2),ry=Math.abs(height/2);rx+=_offsetOpt(.01*rx,o),ry+=_offsetOpt(.01*ry,o);let strt=start,stp=stop;for(;strt<0;)strt+=2*Math.PI,stp+=2*Math.PI;stp-strt>2*Math.PI&&(strt=0,stp=2*Math.PI);const ellipseInc=2*Math.PI/o.curveStepCount,arcInc=Math.min(ellipseInc/2,(stp-strt)/2),ops=_arc(arcInc,cx,cy,rx,ry,strt,stp,1,o);if(!o.disableMultiStroke){const o2=_arc(arcInc,cx,cy,rx,ry,strt,stp,1.5,o);ops.push(...o2)}return closed&&(roughClosure?ops.push(..._doubleLine(cx,cy,cx+rx*Math.cos(strt),cy+ry*Math.sin(strt),o),..._doubleLine(cx,cy,cx+rx*Math.cos(stp),cy+ry*Math.sin(stp),o)):ops.push({op:"lineTo",data:[cx,cy]},{op:"lineTo",data:[cx+rx*Math.cos(strt),cy+ry*Math.sin(strt)]})),{type:"path",ops}}function svgPath(path,o){const segments=normalize(absolutize(parsePath(path))),ops=[];let first=[0,0],current=[0,0];for(const{key,data}of segments)switch(key){case"M":current=[data[0],data[1]],first=[data[0],data[1]];break;case"L":ops.push(..._doubleLine(current[0],current[1],data[0],data[1],o)),current=[data[0],data[1]];break;case"C":{const[x1,y1,x2,y2,x,y]=data;ops.push(..._bezierTo(x1,y1,x2,y2,x,y,current,o)),current=[x,y];break}case"Z":ops.push(..._doubleLine(current[0],current[1],first[0],first[1],o)),current=[first[0],first[1]]}return{type:"path",ops}}function solidFillPolygon(polygonList,o){const ops=[];for(const points of polygonList)if(points.length){const offset=o.maxRandomnessOffset||0,len=points.length;if(len>2){ops.push({op:"move",data:[points[0][0]+_offsetOpt(offset,o),points[0][1]+_offsetOpt(offset,o)]});for(let i=1;i<len;i++)ops.push({op:"lineTo",data:[points[i][0]+_offsetOpt(offset,o),points[i][1]+_offsetOpt(offset,o)]})}}return{type:"fillPath",ops}}function patternFillPolygons(polygonList,o){return function getFiller(o,helper){let fillerName=o.fillStyle||"hachure";if(!fillers[fillerName])switch(fillerName){case"zigzag":fillers[fillerName]||(fillers[fillerName]=new ZigZagFiller(helper));break;case"cross-hatch":fillers[fillerName]||(fillers[fillerName]=new HatchFiller(helper));break;case"dots":fillers[fillerName]||(fillers[fillerName]=new DotFiller(helper));break;case"dashed":fillers[fillerName]||(fillers[fillerName]=new DashedFiller(helper));break;case"zigzag-line":fillers[fillerName]||(fillers[fillerName]=new ZigZagLineFiller(helper));break;default:fillerName="hachure",fillers[fillerName]||(fillers[fillerName]=new HachureFiller(helper))}return fillers[fillerName]}(o,helper).fillPolygons(polygonList,o)}function cloneOptionsAlterSeed(ops){const result=Object.assign({},ops);return result.randomizer=void 0,ops.seed&&(result.seed=ops.seed+1),result}function random(ops){return ops.randomizer||(ops.randomizer=new Random(ops.seed||0)),ops.randomizer.next()}function _offset(min,max,ops,roughnessGain=1){return ops.roughness*roughnessGain*(random(ops)*(max-min)+min)}function _offsetOpt(x,ops,roughnessGain=1){return _offset(-x,x,ops,roughnessGain)}function _doubleLine(x1,y1,x2,y2,o,filling=!1){const singleStroke=filling?o.disableMultiStrokeFill:o.disableMultiStroke,o1=_line(x1,y1,x2,y2,o,!0,!1);if(singleStroke)return o1;const o2=_line(x1,y1,x2,y2,o,!0,!0);return o1.concat(o2)}function _line(x1,y1,x2,y2,o,move,overlay){const lengthSq=Math.pow(x1-x2,2)+Math.pow(y1-y2,2),length=Math.sqrt(lengthSq);let roughnessGain=1;roughnessGain=length<200?1:length>500?.4:-.0016668*length+1.233334;let offset=o.maxRandomnessOffset||0;offset*offset*100>lengthSq&&(offset=length/10);const halfOffset=offset/2,divergePoint=.2+.2*random(o);let midDispX=o.bowing*o.maxRandomnessOffset*(y2-y1)/200,midDispY=o.bowing*o.maxRandomnessOffset*(x1-x2)/200;midDispX=_offsetOpt(midDispX,o,roughnessGain),midDispY=_offsetOpt(midDispY,o,roughnessGain);const ops=[],randomHalf=()=>_offsetOpt(halfOffset,o,roughnessGain),randomFull=()=>_offsetOpt(offset,o,roughnessGain),preserveVertices=o.preserveVertices;return move&&(overlay?ops.push({op:"move",data:[x1+(preserveVertices?0:randomHalf()),y1+(preserveVertices?0:randomHalf())]}):ops.push({op:"move",data:[x1+(preserveVertices?0:_offsetOpt(offset,o,roughnessGain)),y1+(preserveVertices?0:_offsetOpt(offset,o,roughnessGain))]})),overlay?ops.push({op:"bcurveTo",data:[midDispX+x1+(x2-x1)*divergePoint+randomHalf(),midDispY+y1+(y2-y1)*divergePoint+randomHalf(),midDispX+x1+2*(x2-x1)*divergePoint+randomHalf(),midDispY+y1+2*(y2-y1)*divergePoint+randomHalf(),x2+(preserveVertices?0:randomHalf()),y2+(preserveVertices?0:randomHalf())]}):ops.push({op:"bcurveTo",data:[midDispX+x1+(x2-x1)*divergePoint+randomFull(),midDispY+y1+(y2-y1)*divergePoint+randomFull(),midDispX+x1+2*(x2-x1)*divergePoint+randomFull(),midDispY+y1+2*(y2-y1)*divergePoint+randomFull(),x2+(preserveVertices?0:randomFull()),y2+(preserveVertices?0:randomFull())]}),ops}function _curveWithOffset(points,offset,o){if(!points.length)return[];const ps=[];ps.push([points[0][0]+_offsetOpt(offset,o),points[0][1]+_offsetOpt(offset,o)]),ps.push([points[0][0]+_offsetOpt(offset,o),points[0][1]+_offsetOpt(offset,o)]);for(let i=1;i<points.length;i++)ps.push([points[i][0]+_offsetOpt(offset,o),points[i][1]+_offsetOpt(offset,o)]),i===points.length-1&&ps.push([points[i][0]+_offsetOpt(offset,o),points[i][1]+_offsetOpt(offset,o)]);return _curve(ps,null,o)}function _curve(points,closePoint,o){const len=points.length,ops=[];if(len>3){const b=[],s=1-o.curveTightness;ops.push({op:"move",data:[points[1][0],points[1][1]]});for(let i=1;i+2<len;i++){const cachedVertArray=points[i];b[0]=[cachedVertArray[0],cachedVertArray[1]],b[1]=[cachedVertArray[0]+(s*points[i+1][0]-s*points[i-1][0])/6,cachedVertArray[1]+(s*points[i+1][1]-s*points[i-1][1])/6],b[2]=[points[i+1][0]+(s*points[i][0]-s*points[i+2][0])/6,points[i+1][1]+(s*points[i][1]-s*points[i+2][1])/6],b[3]=[points[i+1][0],points[i+1][1]],ops.push({op:"bcurveTo",data:[b[1][0],b[1][1],b[2][0],b[2][1],b[3][0],b[3][1]]})}if(closePoint&&2===closePoint.length){const ro=o.maxRandomnessOffset;ops.push({op:"lineTo",data:[closePoint[0]+_offsetOpt(ro,o),closePoint[1]+_offsetOpt(ro,o)]})}}else 3===len?(ops.push({op:"move",data:[points[1][0],points[1][1]]}),ops.push({op:"bcurveTo",data:[points[1][0],points[1][1],points[2][0],points[2][1],points[2][0],points[2][1]]})):2===len&&ops.push(..._line(points[0][0],points[0][1],points[1][0],points[1][1],o,!0,!0));return ops}function _computeEllipsePoints(increment,cx,cy,rx,ry,offset,overlap,o){const corePoints=[],allPoints=[];if(0===o.roughness){increment/=4,allPoints.push([cx+rx*Math.cos(-increment),cy+ry*Math.sin(-increment)]);for(let angle=0;angle<=2*Math.PI;angle+=increment){const p=[cx+rx*Math.cos(angle),cy+ry*Math.sin(angle)];corePoints.push(p),allPoints.push(p)}allPoints.push([cx+rx*Math.cos(0),cy+ry*Math.sin(0)]),allPoints.push([cx+rx*Math.cos(increment),cy+ry*Math.sin(increment)])}else{const radOffset=_offsetOpt(.5,o)-Math.PI/2;allPoints.push([_offsetOpt(offset,o)+cx+.9*rx*Math.cos(radOffset-increment),_offsetOpt(offset,o)+cy+.9*ry*Math.sin(radOffset-increment)]);const endAngle=2*Math.PI+radOffset-.01;for(let angle=radOffset;angle<endAngle;angle+=increment){const p=[_offsetOpt(offset,o)+cx+rx*Math.cos(angle),_offsetOpt(offset,o)+cy+ry*Math.sin(angle)];corePoints.push(p),allPoints.push(p)}allPoints.push([_offsetOpt(offset,o)+cx+rx*Math.cos(radOffset+2*Math.PI+.5*overlap),_offsetOpt(offset,o)+cy+ry*Math.sin(radOffset+2*Math.PI+.5*overlap)]),allPoints.push([_offsetOpt(offset,o)+cx+.98*rx*Math.cos(radOffset+overlap),_offsetOpt(offset,o)+cy+.98*ry*Math.sin(radOffset+overlap)]),allPoints.push([_offsetOpt(offset,o)+cx+.9*rx*Math.cos(radOffset+.5*overlap),_offsetOpt(offset,o)+cy+.9*ry*Math.sin(radOffset+.5*overlap)])}return[allPoints,corePoints]}function _arc(increment,cx,cy,rx,ry,strt,stp,offset,o){const radOffset=strt+_offsetOpt(.1,o),points=[];points.push([_offsetOpt(offset,o)+cx+.9*rx*Math.cos(radOffset-increment),_offsetOpt(offset,o)+cy+.9*ry*Math.sin(radOffset-increment)]);for(let angle=radOffset;angle<=stp;angle+=increment)points.push([_offsetOpt(offset,o)+cx+rx*Math.cos(angle),_offsetOpt(offset,o)+cy+ry*Math.sin(angle)]);return points.push([cx+rx*Math.cos(stp),cy+ry*Math.sin(stp)]),points.push([cx+rx*Math.cos(stp),cy+ry*Math.sin(stp)]),_curve(points,null,o)}function _bezierTo(x1,y1,x2,y2,x,y,current,o){const ops=[],ros=[o.maxRandomnessOffset||1,(o.maxRandomnessOffset||1)+.3];let f=[0,0];const iterations=o.disableMultiStroke?1:2,preserveVertices=o.preserveVertices;for(let i=0;i<iterations;i++)0===i?ops.push({op:"move",data:[current[0],current[1]]}):ops.push({op:"move",data:[current[0]+(preserveVertices?0:_offsetOpt(ros[0],o)),current[1]+(preserveVertices?0:_offsetOpt(ros[0],o))]}),f=preserveVertices?[x,y]:[x+_offsetOpt(ros[i],o),y+_offsetOpt(ros[i],o)],ops.push({op:"bcurveTo",data:[x1+_offsetOpt(ros[i],o),y1+_offsetOpt(ros[i],o),x2+_offsetOpt(ros[i],o),y2+_offsetOpt(ros[i],o),f[0],f[1]]});return ops}function clone(p){return[...p]}function curveToBezier(pointsIn,curveTightness=0){const len=pointsIn.length;if(len<3)throw new Error("A curve must have at least three points.");const out=[];if(3===len)out.push(clone(pointsIn[0]),clone(pointsIn[1]),clone(pointsIn[2]),clone(pointsIn[2]));else{const points=[];points.push(pointsIn[0],pointsIn[0]);for(let i=1;i<pointsIn.length;i++)points.push(pointsIn[i]),i===pointsIn.length-1&&points.push(pointsIn[i]);const b=[],s=1-curveTightness;out.push(clone(points[0]));for(let i=1;i+2<points.length;i++){const cachedVertArray=points[i];b[0]=[cachedVertArray[0],cachedVertArray[1]],b[1]=[cachedVertArray[0]+(s*points[i+1][0]-s*points[i-1][0])/6,cachedVertArray[1]+(s*points[i+1][1]-s*points[i-1][1])/6],b[2]=[points[i+1][0]+(s*points[i][0]-s*points[i+2][0])/6,points[i+1][1]+(s*points[i][1]-s*points[i+2][1])/6],b[3]=[points[i+1][0],points[i+1][1]],out.push(b[1],b[2],b[3])}}return out}function distanceSq(p1,p2){return Math.pow(p1[0]-p2[0],2)+Math.pow(p1[1]-p2[1],2)}function distanceToSegmentSq(p,v,w){const l2=distanceSq(v,w);if(0===l2)return distanceSq(p,v);let t=((p[0]-v[0])*(w[0]-v[0])+(p[1]-v[1])*(w[1]-v[1]))/l2;return t=Math.max(0,Math.min(1,t)),distanceSq(p,lerp(v,w,t))}function lerp(a,b,t){return[a[0]+(b[0]-a[0])*t,a[1]+(b[1]-a[1])*t]}function getPointsOnBezierCurveWithSplitting(points,offset,tolerance,newPoints){const outPoints=newPoints||[];if(function flatness(points,offset){const p1=points[offset+0],p2=points[offset+1],p3=points[offset+2],p4=points[offset+3];let ux=3*p2[0]-2*p1[0]-p4[0];ux*=ux;let uy=3*p2[1]-2*p1[1]-p4[1];uy*=uy;let vx=3*p3[0]-2*p4[0]-p1[0];vx*=vx;let vy=3*p3[1]-2*p4[1]-p1[1];return vy*=vy,ux<vx&&(ux=vx),uy<vy&&(uy=vy),ux+uy}(points,offset)<tolerance){const p0=points[offset+0];if(outPoints.length){(function distance(p1,p2){return Math.sqrt(distanceSq(p1,p2))})(outPoints[outPoints.length-1],p0)>1&&outPoints.push(p0)}else outPoints.push(p0);outPoints.push(points[offset+3])}else{const t=.5,p1=points[offset+0],p2=points[offset+1],p3=points[offset+2],p4=points[offset+3],q1=lerp(p1,p2,t),q2=lerp(p2,p3,t),q3=lerp(p3,p4,t),r1=lerp(q1,q2,t),r2=lerp(q2,q3,t),red=lerp(r1,r2,t);getPointsOnBezierCurveWithSplitting([p1,q1,r1,red],0,tolerance,outPoints),getPointsOnBezierCurveWithSplitting([red,r2,q3,p4],0,tolerance,outPoints)}return outPoints}function simplify(points,distance){return simplifyPoints(points,0,points.length,distance)}function simplifyPoints(points,start,end,epsilon,newPoints){const outPoints=newPoints||[],s=points[start],e=points[end-1];let maxDistSq=0,maxNdx=1;for(let i=start+1;i<end-1;++i){const distSq=distanceToSegmentSq(points[i],s,e);distSq>maxDistSq&&(maxDistSq=distSq,maxNdx=i)}return Math.sqrt(maxDistSq)>epsilon?(simplifyPoints(points,start,maxNdx+1,epsilon,outPoints),simplifyPoints(points,maxNdx,end,epsilon,outPoints)):(outPoints.length||outPoints.push(s),outPoints.push(e)),outPoints}function pointsOnBezierCurves(points,tolerance=.15,distance){const newPoints=[],numSegments=(points.length-1)/3;for(let i=0;i<numSegments;i++){getPointsOnBezierCurveWithSplitting(points,3*i,tolerance,newPoints)}return distance&&distance>0?simplifyPoints(newPoints,0,newPoints.length,distance):newPoints}const NOS="none";class RoughGenerator{constructor(config){this.defaultOptions={maxRandomnessOffset:2,roughness:1,bowing:1,stroke:"#000",strokeWidth:1,curveTightness:0,curveFitting:.95,curveStepCount:9,fillStyle:"hachure",fillWeight:-1,hachureAngle:-41,hachureGap:-1,dashOffset:-1,dashGap:-1,zigzagOffset:-1,seed:0,disableMultiStroke:!1,disableMultiStrokeFill:!1,preserveVertices:!1,fillShapeRoughnessGain:.8},this.config=config||{},this.config.options&&(this.defaultOptions=this._o(this.config.options))}static newSeed(){return function randomSeed(){return Math.floor(Math.random()*2**31)}()}_o(options){return options?Object.assign({},this.defaultOptions,options):this.defaultOptions}_d(shape,sets,options){return{shape,sets:sets||[],options:options||this.defaultOptions}}line(x1,y1,x2,y2,options){const o=this._o(options);return this._d("line",[line(x1,y1,x2,y2,o)],o)}rectangle(x,y,width,height,options){const o=this._o(options),paths=[],outline=rectangle(x,y,width,height,o);if(o.fill){const points=[[x,y],[x+width,y],[x+width,y+height],[x,y+height]];"solid"===o.fillStyle?paths.push(solidFillPolygon([points],o)):paths.push(patternFillPolygons([points],o))}return o.stroke!==NOS&&paths.push(outline),this._d("rectangle",paths,o)}ellipse(x,y,width,height,options){const o=this._o(options),paths=[],ellipseParams=generateEllipseParams(width,height,o),ellipseResponse=ellipseWithParams(x,y,o,ellipseParams);if(o.fill)if("solid"===o.fillStyle){const shape=ellipseWithParams(x,y,o,ellipseParams).opset;shape.type="fillPath",paths.push(shape)}else paths.push(patternFillPolygons([ellipseResponse.estimatedPoints],o));return o.stroke!==NOS&&paths.push(ellipseResponse.opset),this._d("ellipse",paths,o)}circle(x,y,diameter,options){const ret=this.ellipse(x,y,diameter,diameter,options);return ret.shape="circle",ret}linearPath(points,options){const o=this._o(options);return this._d("linearPath",[linearPath(points,!1,o)],o)}arc(x,y,width,height,start,stop,closed=!1,options){const o=this._o(options),paths=[],outline=arc(x,y,width,height,start,stop,closed,!0,o);if(closed&&o.fill)if("solid"===o.fillStyle){const fillOptions=Object.assign({},o);fillOptions.disableMultiStroke=!0;const shape=arc(x,y,width,height,start,stop,!0,!1,fillOptions);shape.type="fillPath",paths.push(shape)}else paths.push(function patternFillArc(x,y,width,height,start,stop,o){const cx=x,cy=y;let rx=Math.abs(width/2),ry=Math.abs(height/2);rx+=_offsetOpt(.01*rx,o),ry+=_offsetOpt(.01*ry,o);let strt=start,stp=stop;for(;strt<0;)strt+=2*Math.PI,stp+=2*Math.PI;stp-strt>2*Math.PI&&(strt=0,stp=2*Math.PI);const increment=(stp-strt)/o.curveStepCount,points=[];for(let angle=strt;angle<=stp;angle+=increment)points.push([cx+rx*Math.cos(angle),cy+ry*Math.sin(angle)]);return points.push([cx+rx*Math.cos(stp),cy+ry*Math.sin(stp)]),points.push([cx,cy]),patternFillPolygons([points],o)}(x,y,width,height,start,stop,o));return o.stroke!==NOS&&paths.push(outline),this._d("arc",paths,o)}curve(points,options){const o=this._o(options),paths=[],outline=curve(points,o);if(o.fill&&o.fill!==NOS)if("solid"===o.fillStyle){const fillShape=curve(points,Object.assign(Object.assign({},o),{disableMultiStroke:!0,roughness:o.roughness?o.roughness+o.fillShapeRoughnessGain:0}));paths.push({type:"fillPath",ops:this._mergedShape(fillShape.ops)})}else{const polyPoints=[],inputPoints=points;if(inputPoints.length){const pointsList="number"==typeof inputPoints[0][0]?[inputPoints]:inputPoints;for(const points of pointsList)points.length<3?polyPoints.push(...points):3===points.length?polyPoints.push(...pointsOnBezierCurves(curveToBezier([points[0],points[0],points[1],points[2]]),10,(1+o.roughness)/2)):polyPoints.push(...pointsOnBezierCurves(curveToBezier(points),10,(1+o.roughness)/2))}polyPoints.length&&paths.push(patternFillPolygons([polyPoints],o))}return o.stroke!==NOS&&paths.push(outline),this._d("curve",paths,o)}polygon(points,options){const o=this._o(options),paths=[],outline=linearPath(points,!0,o);return o.fill&&("solid"===o.fillStyle?paths.push(solidFillPolygon([points],o)):paths.push(patternFillPolygons([points],o))),o.stroke!==NOS&&paths.push(outline),this._d("polygon",paths,o)}path(d,options){const o=this._o(options),paths=[];if(!d)return this._d("path",paths,o);d=(d||"").replace(/\n/g," ").replace(/(-\s)/g,"-").replace("/(ss)/g"," ");const hasFill=o.fill&&"transparent"!==o.fill&&o.fill!==NOS,hasStroke=o.stroke!==NOS,simplified=!!(o.simplification&&o.simplification<1),sets=function pointsOnPath(path,tolerance,distance){const normalized=normalize(absolutize(parsePath(path))),sets=[];let currentPoints=[],start=[0,0],pendingCurve=[];const appendPendingCurve=()=>{pendingCurve.length>=4&&currentPoints.push(...pointsOnBezierCurves(pendingCurve,tolerance)),pendingCurve=[]},appendPendingPoints=()=>{appendPendingCurve(),currentPoints.length&&(sets.push(currentPoints),currentPoints=[])};for(const{key,data}of normalized)switch(key){case"M":appendPendingPoints(),start=[data[0],data[1]],currentPoints.push(start);break;case"L":appendPendingCurve(),currentPoints.push([data[0],data[1]]);break;case"C":if(!pendingCurve.length){const lastPoint=currentPoints.length?currentPoints[currentPoints.length-1]:start;pendingCurve.push([lastPoint[0],lastPoint[1]])}pendingCurve.push([data[0],data[1]]),pendingCurve.push([data[2],data[3]]),pendingCurve.push([data[4],data[5]]);break;case"Z":appendPendingCurve(),currentPoints.push([start[0],start[1]])}if(appendPendingPoints(),!distance)return sets;const out=[];for(const set of sets){const simplifiedSet=simplify(set,distance);simplifiedSet.length&&out.push(simplifiedSet)}return out}(d,1,simplified?4-4*(o.simplification||1):(1+o.roughness)/2),shape=svgPath(d,o);if(hasFill)if("solid"===o.fillStyle)if(1===sets.length){const fillShape=svgPath(d,Object.assign(Object.assign({},o),{disableMultiStroke:!0,roughness:o.roughness?o.roughness+o.fillShapeRoughnessGain:0}));paths.push({type:"fillPath",ops:this._mergedShape(fillShape.ops)})}else paths.push(solidFillPolygon(sets,o));else paths.push(patternFillPolygons(sets,o));return hasStroke&&(simplified?sets.forEach((set=>{paths.push(linearPath(set,!1,o))})):paths.push(shape)),this._d("path",paths,o)}opsToPath(drawing,fixedDecimals){let path="";for(const item of drawing.ops){const data="number"==typeof fixedDecimals&&fixedDecimals>=0?item.data.map((d=>+d.toFixed(fixedDecimals))):item.data;switch(item.op){case"move":path+=`M${data[0]} ${data[1]} `;break;case"bcurveTo":path+=`C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;break;case"lineTo":path+=`L${data[0]} ${data[1]} `}}return path.trim()}toPaths(drawable){const sets=drawable.sets||[],o=drawable.options||this.defaultOptions,paths=[];for(const drawing of sets){let path=null;switch(drawing.type){case"path":path={d:this.opsToPath(drawing),stroke:o.stroke,strokeWidth:o.strokeWidth,fill:NOS};break;case"fillPath":path={d:this.opsToPath(drawing),stroke:NOS,strokeWidth:0,fill:o.fill||NOS};break;case"fillSketch":path=this.fillSketch(drawing,o)}path&&paths.push(path)}return paths}fillSketch(drawing,o){let fweight=o.fillWeight;return fweight<0&&(fweight=o.strokeWidth/2),{d:this.opsToPath(drawing),stroke:o.fill||NOS,strokeWidth:fweight,fill:NOS}}_mergedShape(input){return input.filter(((d,i)=>0===i||"move"!==d.op))}}class RoughCanvas{constructor(canvas,config){this.canvas=canvas,this.ctx=this.canvas.getContext("2d"),this.gen=new RoughGenerator(config)}draw(drawable){const sets=drawable.sets||[],o=drawable.options||this.getDefaultOptions(),ctx=this.ctx,precision=drawable.options.fixedDecimalPlaceDigits;for(const drawing of sets)switch(drawing.type){case"path":ctx.save(),ctx.strokeStyle="none"===o.stroke?"transparent":o.stroke,ctx.lineWidth=o.strokeWidth,o.strokeLineDash&&ctx.setLineDash(o.strokeLineDash),o.strokeLineDashOffset&&(ctx.lineDashOffset=o.strokeLineDashOffset),this._drawToContext(ctx,drawing,precision),ctx.restore();break;case"fillPath":{ctx.save(),ctx.fillStyle=o.fill||"";const fillRule="curve"===drawable.shape||"polygon"===drawable.shape||"path"===drawable.shape?"evenodd":"nonzero";this._drawToContext(ctx,drawing,precision,fillRule),ctx.restore();break}case"fillSketch":this.fillSketch(ctx,drawing,o)}}fillSketch(ctx,drawing,o){let fweight=o.fillWeight;fweight<0&&(fweight=o.strokeWidth/2),ctx.save(),o.fillLineDash&&ctx.setLineDash(o.fillLineDash),o.fillLineDashOffset&&(ctx.lineDashOffset=o.fillLineDashOffset),ctx.strokeStyle=o.fill||"",ctx.lineWidth=fweight,this._drawToContext(ctx,drawing,o.fixedDecimalPlaceDigits),ctx.restore()}_drawToContext(ctx,drawing,fixedDecimals,rule="nonzero"){ctx.beginPath();for(const item of drawing.ops){const data="number"==typeof fixedDecimals&&fixedDecimals>=0?item.data.map((d=>+d.toFixed(fixedDecimals))):item.data;switch(item.op){case"move":ctx.moveTo(data[0],data[1]);break;case"bcurveTo":ctx.bezierCurveTo(data[0],data[1],data[2],data[3],data[4],data[5]);break;case"lineTo":ctx.lineTo(data[0],data[1])}}"fillPath"===drawing.type?ctx.fill(rule):ctx.stroke()}get generator(){return this.gen}getDefaultOptions(){return this.gen.defaultOptions}line(x1,y1,x2,y2,options){const d=this.gen.line(x1,y1,x2,y2,options);return this.draw(d),d}rectangle(x,y,width,height,options){const d=this.gen.rectangle(x,y,width,height,options);return this.draw(d),d}ellipse(x,y,width,height,options){const d=this.gen.ellipse(x,y,width,height,options);return this.draw(d),d}circle(x,y,diameter,options){const d=this.gen.circle(x,y,diameter,options);return this.draw(d),d}linearPath(points,options){const d=this.gen.linearPath(points,options);return this.draw(d),d}polygon(points,options){const d=this.gen.polygon(points,options);return this.draw(d),d}arc(x,y,width,height,start,stop,closed=!1,options){const d=this.gen.arc(x,y,width,height,start,stop,closed,options);return this.draw(d),d}curve(points,options){const d=this.gen.curve(points,options);return this.draw(d),d}path(d,options){const drawing=this.gen.path(d,options);return this.draw(drawing),drawing}}const SVGNS="http://www.w3.org/2000/svg";class RoughSVG{constructor(svg,config){this.svg=svg,this.gen=new RoughGenerator(config)}draw(drawable){const sets=drawable.sets||[],o=drawable.options||this.getDefaultOptions(),doc=this.svg.ownerDocument||window.document,g=doc.createElementNS(SVGNS,"g"),precision=drawable.options.fixedDecimalPlaceDigits;for(const drawing of sets){let path=null;switch(drawing.type){case"path":path=doc.createElementNS(SVGNS,"path"),path.setAttribute("d",this.opsToPath(drawing,precision)),path.setAttribute("stroke",o.stroke),path.setAttribute("stroke-width",o.strokeWidth+""),path.setAttribute("fill","none"),o.strokeLineDash&&path.setAttribute("stroke-dasharray",o.strokeLineDash.join(" ").trim()),o.strokeLineDashOffset&&path.setAttribute("stroke-dashoffset",`${o.strokeLineDashOffset}`);break;case"fillPath":path=doc.createElementNS(SVGNS,"path"),path.setAttribute("d",this.opsToPath(drawing,precision)),path.setAttribute("stroke","none"),path.setAttribute("stroke-width","0"),path.setAttribute("fill",o.fill||""),"curve"!==drawable.shape&&"polygon"!==drawable.shape||path.setAttribute("fill-rule","evenodd");break;case"fillSketch":path=this.fillSketch(doc,drawing,o)}path&&g.appendChild(path)}return g}fillSketch(doc,drawing,o){let fweight=o.fillWeight;fweight<0&&(fweight=o.strokeWidth/2);const path=doc.createElementNS(SVGNS,"path");return path.setAttribute("d",this.opsToPath(drawing,o.fixedDecimalPlaceDigits)),path.setAttribute("stroke",o.fill||""),path.setAttribute("stroke-width",fweight+""),path.setAttribute("fill","none"),o.fillLineDash&&path.setAttribute("stroke-dasharray",o.fillLineDash.join(" ").trim()),o.fillLineDashOffset&&path.setAttribute("stroke-dashoffset",`${o.fillLineDashOffset}`),path}get generator(){return this.gen}getDefaultOptions(){return this.gen.defaultOptions}opsToPath(drawing,fixedDecimalPlaceDigits){return this.gen.opsToPath(drawing,fixedDecimalPlaceDigits)}line(x1,y1,x2,y2,options){const d=this.gen.line(x1,y1,x2,y2,options);return this.draw(d)}rectangle(x,y,width,height,options){const d=this.gen.rectangle(x,y,width,height,options);return this.draw(d)}ellipse(x,y,width,height,options){const d=this.gen.ellipse(x,y,width,height,options);return this.draw(d)}circle(x,y,diameter,options){const d=this.gen.circle(x,y,diameter,options);return this.draw(d)}linearPath(points,options){const d=this.gen.linearPath(points,options);return this.draw(d)}polygon(points,options){const d=this.gen.polygon(points,options);return this.draw(d)}arc(x,y,width,height,start,stop,closed=!1,options){const d=this.gen.arc(x,y,width,height,start,stop,closed,options);return this.draw(d)}curve(points,options){const d=this.gen.curve(points,options);return this.draw(d)}path(d,options){const drawing=this.gen.path(d,options);return this.draw(drawing)}}const rough={canvas:(canvas,config)=>new RoughCanvas(canvas,config),svg:(svg,config)=>new RoughSVG(svg,config),generator:config=>new RoughGenerator(config),newSeed:()=>RoughGenerator.newSeed()}}}]);